[
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/",
	"title": "Python",
	"tags": [],
	"description": "",
	"content": "Link  https://dfrieds.com/#articles https://www.pythonforbeginners.com/python-tutorial https://ericcchase.com/portfolio/sql-python-pandas/ https://realpython.com/ https://phyblas.hinaboshi.com/saraban/python https://www.programiz.com/ https://pandas.pydata.org/ https://www.w3schools.com/python/default.asp https://codeloop.org http://www.daydev.com/category/developer/s6-programming-language/python  "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/short_introduction/10-minutes/",
	"title": "10 minutes to pandas",
	"tags": [],
	"description": "",
	"content": "This is a short introduction to pandas, geared mainly for new users. You can see more complex recipes in the Cookbook.\n Reference : https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html\n Customarily, we import as follows:\nIn [1]: import numpy as np In [2]: import pandas as pd Object creation See the Data Structure Intro section.\nCreating a Series by passing a list of values, letting pandas create a default integer index:\nIn [3]: s = pd.Series([1, 3, 5, np.nan, 6, 8]) In [4]: s Out[4]: 0 1.0 1 3.0 2 5.0 3 NaN 4 6.0 5 8.0 dtype: float64 Creating a DataFrame by passing a NumPy array, with a datetime index and labeled columns:\nIn [5]: dates = pd.date_range(\u0026#39;20130101\u0026#39;, periods=6) In [6]: dates Out[6]: DatetimeIndex([\u0026#39;2013-01-01\u0026#39;, \u0026#39;2013-01-02\u0026#39;, \u0026#39;2013-01-03\u0026#39;, \u0026#39;2013-01-04\u0026#39;, \u0026#39;2013-01-05\u0026#39;, \u0026#39;2013-01-06\u0026#39;], dtype=\u0026#39;datetime64[ns]\u0026#39;, freq=\u0026#39;D\u0026#39;) In [7]: df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) In [8]: df Out[8]: A B C D 2013-01-01 0.469112 -0.282863 -1.509059 -1.135632 2013-01-02 1.212112 -0.173215 0.119209 -1.044236 2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 2013-01-04 0.721555 -0.706771 -1.039575 0.271860 2013-01-05 -0.424972 0.567020 0.276232 -1.087401 2013-01-06 -0.673690 0.113648 -1.478427 0.524988 Creating a DataFrame by passing a dict of objects that can be converted to series-like.\nIn [9]: df2 = pd.DataFrame({\u0026#39;A\u0026#39;: 1., ...: \u0026#39;B\u0026#39;: pd.Timestamp(\u0026#39;20130102\u0026#39;), ...: \u0026#39;C\u0026#39;: pd.Series(1, index=list(range(4)), dtype=\u0026#39;float32\u0026#39;), ...: \u0026#39;D\u0026#39;: np.array([3] * 4, dtype=\u0026#39;int32\u0026#39;), ...: \u0026#39;E\u0026#39;: pd.Categorical([\u0026#34;test\u0026#34;, \u0026#34;train\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;train\u0026#34;]), ...: \u0026#39;F\u0026#39;: \u0026#39;foo\u0026#39;}) ...: In [10]: df2 Out[10]: A B C D E F 0 1.0 2013-01-02 1.0 3 test foo 1 1.0 2013-01-02 1.0 3 train foo 2 1.0 2013-01-02 1.0 3 test foo 3 1.0 2013-01-02 1.0 3 train foo The columns of the resulting DataFrame have different dtypes.\nIn [11]: df2.dtypes Out[11]: A float64 B datetime64[ns] C float32 D int32 E category F object dtype: object If you’re using IPython, tab completion for column names (as well as public attributes) is automatically enabled. Here’s a subset of the attributes that will be completed:\nIn [12]: df2.\u0026lt;TAB\u0026gt; # noqa: E225, E999 df2.A df2.bool df2.abs df2.boxplot df2.add df2.C df2.add_prefix df2.clip df2.add_suffix df2.columns df2.align df2.copy df2.all df2.count df2.any df2.combine df2.append df2.D df2.apply df2.describe df2.applymap df2.diff df2.B df2.duplicated As you can see, the columns A, B, C, and D are automatically tab completed. E and F are there as well; the rest of the attributes have been truncated for brevity.\nViewing data See the Basics section.\nHere is how to view the top and bottom rows of the frame:\nIn [13]: df.head() Out[13]: A B C D 2013-01-01 0.469112 -0.282863 -1.509059 -1.135632 2013-01-02 1.212112 -0.173215 0.119209 -1.044236 2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 2013-01-04 0.721555 -0.706771 -1.039575 0.271860 2013-01-05 -0.424972 0.567020 0.276232 -1.087401 In [14]: df.tail(3) Out[14]: A B C D 2013-01-04 0.721555 -0.706771 -1.039575 0.271860 2013-01-05 -0.424972 0.567020 0.276232 -1.087401 2013-01-06 -0.673690 0.113648 -1.478427 0.524988 Display the index, columns:\nIn [15]: df.index Out[15]: DatetimeIndex([\u0026#39;2013-01-01\u0026#39;, \u0026#39;2013-01-02\u0026#39;, \u0026#39;2013-01-03\u0026#39;, \u0026#39;2013-01-04\u0026#39;, \u0026#39;2013-01-05\u0026#39;, \u0026#39;2013-01-06\u0026#39;], dtype=\u0026#39;datetime64[ns]\u0026#39;, freq=\u0026#39;D\u0026#39;) In [16]: df.columns Out[16]: Index([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;], dtype=\u0026#39;object\u0026#39;) DataFrame.to_numpy() gives a NumPy representation of the underlying data. Note that this can be an expensive operation when your DataFrame has columns with different data types, which comes down to a fundamental difference between pandas and NumPy: NumPy arrays have one dtype for the entire array, while pandas DataFrames have one dtype per column. When you call DataFrame.to_numpy(), pandas will find the NumPy dtype that can hold all of the dtypes in the DataFrame. This may end up being object, which requires casting every value to a Python object.\nFor df, our DataFrame of all floating-point values, DataFrame.to_numpy() is fast and doesn’t require copying data.\nIn [17]: df.to_numpy() Out[17]: array([[ 0.4691, -0.2829, -1.5091, -1.1356], [ 1.2121, -0.1732, 0.1192, -1.0442], [-0.8618, -2.1046, -0.4949, 1.0718], [ 0.7216, -0.7068, -1.0396, 0.2719], [-0.425 , 0.567 , 0.2762, -1.0874], [-0.6737, 0.1136, -1.4784, 0.525 ]]) For df2, the DataFrame with multiple dtypes, DataFrame.to_numpy() is relatively expensive.\nIn [18]: df2.to_numpy() Out[18]: array([[1.0, Timestamp(\u0026#39;2013-01-02 00:00:00\u0026#39;), 1.0, 3, \u0026#39;test\u0026#39;, \u0026#39;foo\u0026#39;], [1.0, Timestamp(\u0026#39;2013-01-02 00:00:00\u0026#39;), 1.0, 3, \u0026#39;train\u0026#39;, \u0026#39;foo\u0026#39;], [1.0, Timestamp(\u0026#39;2013-01-02 00:00:00\u0026#39;), 1.0, 3, \u0026#39;test\u0026#39;, \u0026#39;foo\u0026#39;], [1.0, Timestamp(\u0026#39;2013-01-02 00:00:00\u0026#39;), 1.0, 3, \u0026#39;train\u0026#39;, \u0026#39;foo\u0026#39;]], dtype=object) Note\nDataFrame.to_numpy() does not include the index or column labels in the output.\ndescribe() shows a quick statistic summary of your data:\nIn [19]: df.describe() Out[19]: A B C D count 6.000000 6.000000 6.000000 6.000000 mean 0.073711 -0.431125 -0.687758 -0.233103 std 0.843157 0.922818 0.779887 0.973118 min -0.861849 -2.104569 -1.509059 -1.135632 25% -0.611510 -0.600794 -1.368714 -1.076610 50% 0.022070 -0.228039 -0.767252 -0.386188 75% 0.658444 0.041933 -0.034326 0.461706 max 1.212112 0.567020 0.276232 1.071804 Transposing your data:\nIn [20]: df.T Out[20]: 2013-01-01 2013-01-02 2013-01-03 2013-01-04 2013-01-05 2013-01-06 A 0.469112 1.212112 -0.861849 0.721555 -0.424972 -0.673690 B -0.282863 -0.173215 -2.104569 -0.706771 0.567020 0.113648 C -1.509059 0.119209 -0.494929 -1.039575 0.276232 -1.478427 D -1.135632 -1.044236 1.071804 0.271860 -1.087401 0.524988 Sorting by an axis:\nIn [21]: df.sort_index(axis=1, ascending=False) Out[21]: D C B A 2013-01-01 -1.135632 -1.509059 -0.282863 0.469112 2013-01-02 -1.044236 0.119209 -0.173215 1.212112 2013-01-03 1.071804 -0.494929 -2.104569 -0.861849 2013-01-04 0.271860 -1.039575 -0.706771 0.721555 2013-01-05 -1.087401 0.276232 0.567020 -0.424972 2013-01-06 0.524988 -1.478427 0.113648 -0.673690 Sorting by values:\nIn [22]: df.sort_values(by=\u0026#39;B\u0026#39;) Out[22]: A B C D 2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 2013-01-04 0.721555 -0.706771 -1.039575 0.271860 2013-01-01 0.469112 -0.282863 -1.509059 -1.135632 2013-01-02 1.212112 -0.173215 0.119209 -1.044236 2013-01-06 -0.673690 0.113648 -1.478427 0.524988 2013-01-05 -0.424972 0.567020 0.276232 -1.087401 Selection Note\nWhile standard Python / Numpy expressions for selecting and setting are intuitive and come in handy for interactive work, for production code, we recommend the optimized pandas data access methods, .at, .iat, .loc and .iloc.\nSee the indexing documentation Indexing and Selecting Data and MultiIndex / Advanced Indexing.\nGetting Selecting a single column, which yields a Series, equivalent to df.A:\nIn [23]: df[\u0026#39;A\u0026#39;] Out[23]: 2013-01-01 0.469112 2013-01-02 1.212112 2013-01-03 -0.861849 2013-01-04 0.721555 2013-01-05 -0.424972 2013-01-06 -0.673690 Freq: D, Name: A, dtype: float64 Selecting via [], which slices the rows.\nIn [24]: df[0:3] Out[24]: A B C D 2013-01-01 0.469112 -0.282863 -1.509059 -1.135632 2013-01-02 1.212112 -0.173215 0.119209 -1.044236 2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 In [25]: df[\u0026#39;20130102\u0026#39;:\u0026#39;20130104\u0026#39;] Out[25]: A B C D 2013-01-02 1.212112 -0.173215 0.119209 -1.044236 2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 2013-01-04 0.721555 -0.706771 -1.039575 0.271860 Selection by label See more in Selection by Label.\nFor getting a cross section using a label:\nIn [26]: df.loc[dates[0]] Out[26]: A 0.469112 B -0.282863 C -1.509059 D -1.135632 Name: 2013-01-01 00:00:00, dtype: float64 Selecting on a multi-axis by label:\nIn [27]: df.loc[:, [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]] Out[27]: A B 2013-01-01 0.469112 -0.282863 2013-01-02 1.212112 -0.173215 2013-01-03 -0.861849 -2.104569 2013-01-04 0.721555 -0.706771 2013-01-05 -0.424972 0.567020 2013-01-06 -0.673690 0.113648 Showing label slicing, both endpoints are included:\nIn [28]: df.loc[\u0026#39;20130102\u0026#39;:\u0026#39;20130104\u0026#39;, [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]] Out[28]: A B 2013-01-02 1.212112 -0.173215 2013-01-03 -0.861849 -2.104569 2013-01-04 0.721555 -0.706771 Reduction in the dimensions of the returned object:\nIn [29]: df.loc[\u0026#39;20130102\u0026#39;, [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]] Out[29]: A 1.212112 B -0.173215 Name: 2013-01-02 00:00:00, dtype: float64 For getting a scalar value:\nIn [30]: df.loc[dates[0], \u0026#39;A\u0026#39;] Out[30]: 0.4691122999071863 For getting fast access to a scalar (equivalent to the prior method):\nIn [31]: df.at[dates[0], \u0026#39;A\u0026#39;] Out[31]: 0.4691122999071863 Selection by position See more in Selection by Position.\nSelect via the position of the passed integers:\nIn [32]: df.iloc[3] Out[32]: A 0.721555 B -0.706771 C -1.039575 D 0.271860 Name: 2013-01-04 00:00:00, dtype: float64 By integer slices, acting similar to numpy/python:\nIn [33]: df.iloc[3:5, 0:2] Out[33]: A B 2013-01-04 0.721555 -0.706771 2013-01-05 -0.424972 0.567020 By lists of integer position locations, similar to the numpy/python style:\nIn [34]: df.iloc[[1, 2, 4], [0, 2]] Out[34]: A C 2013-01-02 1.212112 0.119209 2013-01-03 -0.861849 -0.494929 2013-01-05 -0.424972 0.276232 For slicing rows explicitly:\nIn [35]: df.iloc[1:3, :] Out[35]: A B C D 2013-01-02 1.212112 -0.173215 0.119209 -1.044236 2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 For slicing columns explicitly:\nIn [36]: df.iloc[:, 1:3] Out[36]: B C 2013-01-01 -0.282863 -1.509059 2013-01-02 -0.173215 0.119209 2013-01-03 -2.104569 -0.494929 2013-01-04 -0.706771 -1.039575 2013-01-05 0.567020 0.276232 2013-01-06 0.113648 -1.478427 For getting a value explicitly:\nIn [37]: df.iloc[1, 1] Out[37]: -0.17321464905330858 For getting fast access to a scalar (equivalent to the prior method):\nIn [38]: df.iat[1, 1] Out[38]: -0.17321464905330858 Boolean indexing Using a single column’s values to select data.\nIn [39]: df[df[\u0026#39;A\u0026#39;] \u0026gt; 0] Out[39]: A B C D 2013-01-01 0.469112 -0.282863 -1.509059 -1.135632 2013-01-02 1.212112 -0.173215 0.119209 -1.044236 2013-01-04 0.721555 -0.706771 -1.039575 0.271860 Selecting values from a DataFrame where a boolean condition is met.\nIn [40]: df[df \u0026gt; 0] Out[40]: A B C D 2013-01-01 0.469112 NaN NaN NaN 2013-01-02 1.212112 NaN 0.119209 NaN 2013-01-03 NaN NaN NaN 1.071804 2013-01-04 0.721555 NaN NaN 0.271860 2013-01-05 NaN 0.567020 0.276232 NaN 2013-01-06 NaN 0.113648 NaN 0.524988 Using the isin() method for filtering:\nIn [41]: df2 = df.copy() In [42]: df2[\u0026#39;E\u0026#39;] = [\u0026#39;one\u0026#39;, \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;three\u0026#39;] In [43]: df2 Out[43]: A B C D E 2013-01-01 0.469112 -0.282863 -1.509059 -1.135632 one 2013-01-02 1.212112 -0.173215 0.119209 -1.044236 one 2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 two 2013-01-04 0.721555 -0.706771 -1.039575 0.271860 three 2013-01-05 -0.424972 0.567020 0.276232 -1.087401 four 2013-01-06 -0.673690 0.113648 -1.478427 0.524988 three In [44]: df2[df2[\u0026#39;E\u0026#39;].isin([\u0026#39;two\u0026#39;, \u0026#39;four\u0026#39;])] Out[44]: A B C D E 2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 two 2013-01-05 -0.424972 0.567020 0.276232 -1.087401 four Setting Setting a new column automatically aligns the data by the indexes.\nIn [45]: s1 = pd.Series([1, 2, 3, 4, 5, 6], index=pd.date_range(\u0026#39;20130102\u0026#39;, periods=6)) In [46]: s1 Out[46]: 2013-01-02 1 2013-01-03 2 2013-01-04 3 2013-01-05 4 2013-01-06 5 2013-01-07 6 Freq: D, dtype: int64 In [47]: df[\u0026#39;F\u0026#39;] = s1 Setting values by label:\nIn [48]: df.at[dates[0], \u0026#39;A\u0026#39;] = 0 Setting values by position:\nIn [49]: df.iat[0, 1] = 0 Setting by assigning with a NumPy array:\nIn [50]: df.loc[:, \u0026#39;D\u0026#39;] = np.array([5] * len(df)) The result of the prior setting operations.\nIn [51]: df Out[51]: A B C D F 2013-01-01 0.000000 0.000000 -1.509059 5 NaN 2013-01-02 1.212112 -0.173215 0.119209 5 1.0 2013-01-03 -0.861849 -2.104569 -0.494929 5 2.0 2013-01-04 0.721555 -0.706771 -1.039575 5 3.0 2013-01-05 -0.424972 0.567020 0.276232 5 4.0 2013-01-06 -0.673690 0.113648 -1.478427 5 5.0 A where operation with setting.\nIn [52]: df2 = df.copy() In [53]: df2[df2 \u0026gt; 0] = -df2 In [54]: df2 Out[54]: A B C D F 2013-01-01 0.000000 0.000000 -1.509059 -5 NaN 2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0 2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0 2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0 2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0 2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0 Missing data pandas primarily uses the value np.nan to represent missing data. It is by default not included in computations. See the Missing Data section.\nReindexing allows you to change/add/delete the index on a specified axis. This returns a copy of the data.\nIn [55]: df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + [\u0026#39;E\u0026#39;]) In [56]: df1.loc[dates[0]:dates[1], \u0026#39;E\u0026#39;] = 1 In [57]: df1 Out[57]: A B C D F E 2013-01-01 0.000000 0.000000 -1.509059 5 NaN 1.0 2013-01-02 1.212112 -0.173215 0.119209 5 1.0 1.0 2013-01-03 -0.861849 -2.104569 -0.494929 5 2.0 NaN 2013-01-04 0.721555 -0.706771 -1.039575 5 3.0 NaN To drop any rows that have missing data.\nIn [58]: df1.dropna(how=\u0026#39;any\u0026#39;) Out[58]: A B C D F E 2013-01-02 1.212112 -0.173215 0.119209 5 1.0 1.0 Filling missing data.\nIn [59]: df1.fillna(value=5) Out[59]: A B C D F E 2013-01-01 0.000000 0.000000 -1.509059 5 5.0 1.0 2013-01-02 1.212112 -0.173215 0.119209 5 1.0 1.0 2013-01-03 -0.861849 -2.104569 -0.494929 5 2.0 5.0 2013-01-04 0.721555 -0.706771 -1.039575 5 3.0 5.0 To get the boolean mask where values are nan.\nIn [60]: pd.isna(df1) Out[60]: A B C D F E 2013-01-01 False False False False True False 2013-01-02 False False False False False False 2013-01-03 False False False False False True 2013-01-04 False False False False False True Operations See the Basic section on Binary Ops.\nStats Operations in general exclude missing data.\nPerforming a descriptive statistic:\nIn [61]: df.mean() Out[61]: A -0.004474 B -0.383981 C -0.687758 D 5.000000 F 3.000000 dtype: float64 Same operation on the other axis:\nIn [62]: df.mean(1) Out[62]: 2013-01-01 0.872735 2013-01-02 1.431621 2013-01-03 0.707731 2013-01-04 1.395042 2013-01-05 1.883656 2013-01-06 1.592306 Freq: D, dtype: float64 Operating with objects that have different dimensionality and need alignment. In addition, pandas automatically broadcasts along the specified dimension.\nIn [63]: s = pd.Series([1, 3, 5, np.nan, 6, 8], index=dates).shift(2) In [64]: s Out[64]: 2013-01-01 NaN 2013-01-02 NaN 2013-01-03 1.0 2013-01-04 3.0 2013-01-05 5.0 2013-01-06 NaN Freq: D, dtype: float64 In [65]: df.sub(s, axis=\u0026#39;index\u0026#39;) Out[65]: A B C D F 2013-01-01 NaN NaN NaN NaN NaN 2013-01-02 NaN NaN NaN NaN NaN 2013-01-03 -1.861849 -3.104569 -1.494929 4.0 1.0 2013-01-04 -2.278445 -3.706771 -4.039575 2.0 0.0 2013-01-05 -5.424972 -4.432980 -4.723768 0.0 -1.0 2013-01-06 NaN NaN NaN NaN NaN Apply Applying functions to the data:\nIn [66]: df.apply(np.cumsum) Out[66]: A B C D F 2013-01-01 0.000000 0.000000 -1.509059 5 NaN 2013-01-02 1.212112 -0.173215 -1.389850 10 1.0 2013-01-03 0.350263 -2.277784 -1.884779 15 3.0 2013-01-04 1.071818 -2.984555 -2.924354 20 6.0 2013-01-05 0.646846 -2.417535 -2.648122 25 10.0 2013-01-06 -0.026844 -2.303886 -4.126549 30 15.0 In [67]: df.apply(lambda x: x.max() - x.min()) Out[67]: A 2.073961 B 2.671590 C 1.785291 D 0.000000 F 4.000000 dtype: float64 Histogramming See more at Histogramming and Discretization.\nIn [68]: s = pd.Series(np.random.randint(0, 7, size=10)) In [69]: s Out[69]: 0 4 1 2 2 1 3 2 4 6 5 4 6 4 7 6 8 4 9 4 dtype: int64 In [70]: s.value_counts() Out[70]: 4 5 6 2 2 2 1 1 dtype: int64 String Methods Series is equipped with a set of string processing methods in the str attribute that make it easy to operate on each element of the array, as in the code snippet below. Note that pattern-matching in str generally uses regular expressions by default (and in some cases always uses them). See more at Vectorized String Methods.\nIn [71]: s = pd.Series([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;Aaba\u0026#39;, \u0026#39;Baca\u0026#39;, np.nan, \u0026#39;CABA\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;]) In [72]: s.str.lower() Out[72]: 0 a 1 b 2 c 3 aaba 4 baca 5 NaN 6 caba 7 dog 8 cat dtype: object Merge Concat pandas provides various facilities for easily combining together Series and DataFrame objects with various kinds of set logic for the indexes and relational algebra functionality in the case of join / merge-type operations.\nSee the Merging section.\nConcatenating pandas objects together with concat():\nIn [73]: df = pd.DataFrame(np.random.randn(10, 4)) In [74]: df Out[74]: 0 1 2 3 0 -0.548702 1.467327 -1.015962 -0.483075 1 1.637550 -1.217659 -0.291519 -1.745505 2 -0.263952 0.991460 -0.919069 0.266046 3 -0.709661 1.669052 1.037882 -1.705775 4 -0.919854 -0.042379 1.247642 -0.009920 5 0.290213 0.495767 0.362949 1.548106 6 -1.131345 -0.089329 0.337863 -0.945867 7 -0.932132 1.956030 0.017587 -0.016692 8 -0.575247 0.254161 -1.143704 0.215897 9 1.193555 -0.077118 -0.408530 -0.862495 # break it into pieces In [75]: pieces = [df[:3], df[3:7], df[7:]] In [76]: pd.concat(pieces) Out[76]: 0 1 2 3 0 -0.548702 1.467327 -1.015962 -0.483075 1 1.637550 -1.217659 -0.291519 -1.745505 2 -0.263952 0.991460 -0.919069 0.266046 3 -0.709661 1.669052 1.037882 -1.705775 4 -0.919854 -0.042379 1.247642 -0.009920 5 0.290213 0.495767 0.362949 1.548106 6 -1.131345 -0.089329 0.337863 -0.945867 7 -0.932132 1.956030 0.017587 -0.016692 8 -0.575247 0.254161 -1.143704 0.215897 9 1.193555 -0.077118 -0.408530 -0.862495 Note\nAdding a column to a DataFrame is relatively fast. However, adding a row requires a copy, and may be expensive. We recommend passing a pre-built list of records to the DataFrame constructor instead of building a DataFrame by iteratively appending records to it. See Appending to dataframe for more.\nJoin SQL style merges. See the Database style joining section.\nIn [77]: left = pd.DataFrame({\u0026#39;key\u0026#39;: [\u0026#39;foo\u0026#39;, \u0026#39;foo\u0026#39;], \u0026#39;lval\u0026#39;: [1, 2]}) In [78]: right = pd.DataFrame({\u0026#39;key\u0026#39;: [\u0026#39;foo\u0026#39;, \u0026#39;foo\u0026#39;], \u0026#39;rval\u0026#39;: [4, 5]}) In [79]: left Out[79]: key lval 0 foo 1 1 foo 2 In [80]: right Out[80]: key rval 0 foo 4 1 foo 5 In [81]: pd.merge(left, right, on=\u0026#39;key\u0026#39;) Out[81]: key lval rval 0 foo 1 4 1 foo 1 5 2 foo 2 4 3 foo 2 5 Another example that can be given is:\nIn [82]: left = pd.DataFrame({\u0026#39;key\u0026#39;: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], \u0026#39;lval\u0026#39;: [1, 2]}) In [83]: right = pd.DataFrame({\u0026#39;key\u0026#39;: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], \u0026#39;rval\u0026#39;: [4, 5]}) In [84]: left Out[84]: key lval 0 foo 1 1 bar 2 In [85]: right Out[85]: key rval 0 foo 4 1 bar 5 In [86]: pd.merge(left, right, on=\u0026#39;key\u0026#39;) Out[86]: key lval rval 0 foo 1 4 1 bar 2 5 Grouping By “group by” we are referring to a process involving one or more of the following steps:\n   Splitting the data into groups based on some criteria\n  Applying a function to each group independently\n  Combining the results into a data structure\n   See the Grouping section.\nIn [87]: df = pd.DataFrame({\u0026#39;A\u0026#39;: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, ....: \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;foo\u0026#39;], ....: \u0026#39;B\u0026#39;: [\u0026#39;one\u0026#39;, \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, ....: \u0026#39;two\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;one\u0026#39;, \u0026#39;three\u0026#39;], ....: \u0026#39;C\u0026#39;: np.random.randn(8), ....: \u0026#39;D\u0026#39;: np.random.randn(8)}) ....: In [88]: df Out[88]: A B C D 0 foo one 1.346061 -1.577585 1 bar one 1.511763 0.396823 2 foo two 1.627081 -0.105381 3 bar three -0.990582 -0.532532 4 foo two -0.441652 1.453749 5 bar two 1.211526 1.208843 6 foo one 0.268520 -0.080952 7 foo three 0.024580 -0.264610 Grouping and then applying the sum() function to the resulting groups.\nIn [89]: df.groupby(\u0026#39;A\u0026#39;).sum() Out[89]: C D A bar 1.732707 1.073134 foo 2.824590 -0.574779 Grouping by multiple columns forms a hierarchical index, and again we can apply the sum() function.\nIn [90]: df.groupby([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]).sum() Out[90]: C D A B bar one 1.511763 0.396823 three -0.990582 -0.532532 two 1.211526 1.208843 foo one 1.614581 -1.658537 three 0.024580 -0.264610 two 1.185429 1.348368 Reshaping See the sections on Hierarchical Indexing and Reshaping.\nStack In [91]: tuples = list(zip(*[[\u0026#39;bar\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;, \u0026#39;baz\u0026#39;, ....: \u0026#39;foo\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;qux\u0026#39;, \u0026#39;qux\u0026#39;], ....: [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, ....: \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;]])) ....: In [92]: index = pd.MultiIndex.from_tuples(tuples, names=[\u0026#39;first\u0026#39;, \u0026#39;second\u0026#39;]) In [93]: df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]) In [94]: df2 = df[:4] In [95]: df2 Out[95]: A B first second bar one -0.727965 -0.589346 two 0.339969 -0.693205 baz one -0.339355 0.593616 two 0.884345 1.591431 The stack() method “compresses” a level in the DataFrame’s columns.\nIn [96]: stacked = df2.stack() In [97]: stacked Out[97]: first second bar one A -0.727965 B -0.589346 two A 0.339969 B -0.693205 baz one A -0.339355 B 0.593616 two A 0.884345 B 1.591431 dtype: float64 With a “stacked” DataFrame or Series (having a MultiIndex as the index), the inverse operation of stack() is unstack(), which by default unstacks the last level:\nIn [98]: stacked.unstack() Out[98]: A B first second bar one -0.727965 -0.589346 two 0.339969 -0.693205 baz one -0.339355 0.593616 two 0.884345 1.591431 In [99]: stacked.unstack(1) Out[99]: second one two first bar A -0.727965 0.339969 B -0.589346 -0.693205 baz A -0.339355 0.884345 B 0.593616 1.591431 In [100]: stacked.unstack(0) Out[100]: first bar baz second one A -0.727965 -0.339355 B -0.589346 0.593616 two A 0.339969 0.884345 B -0.693205 1.591431 Pivot tables See the section on Pivot Tables.\nIn [101]: df = pd.DataFrame({\u0026#39;A\u0026#39;: [\u0026#39;one\u0026#39;, \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;] * 3, .....: \u0026#39;B\u0026#39;: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] * 4, .....: \u0026#39;C\u0026#39;: [\u0026#39;foo\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;bar\u0026#39;] * 2, .....: \u0026#39;D\u0026#39;: np.random.randn(12), .....: \u0026#39;E\u0026#39;: np.random.randn(12)}) .....: In [102]: df Out[102]: A B C D E 0 one A foo -1.202872 0.047609 1 one B foo -1.814470 -0.136473 2 two C foo 1.018601 -0.561757 3 three A bar -0.595447 -1.623033 4 one B bar 1.395433 0.029399 5 one C bar -0.392670 -0.542108 6 two A foo 0.007207 0.282696 7 three B foo 1.928123 -0.087302 8 one C foo -0.055224 -1.575170 9 one A bar 2.395985 1.771208 10 two B bar 1.552825 0.816482 11 three C bar 0.166599 1.100230 We can produce pivot tables from this data very easily:\nIn [103]: pd.pivot_table(df, values=\u0026#39;D\u0026#39;, index=[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;], columns=[\u0026#39;C\u0026#39;]) Out[103]: C bar foo A B one A 2.395985 -1.202872 B 1.395433 -1.814470 C -0.392670 -0.055224 three A -0.595447 NaN B NaN 1.928123 C 0.166599 NaN two A NaN 0.007207 B 1.552825 NaN C NaN 1.018601 Time series pandas has simple, powerful, and efficient functionality for performing resampling operations during frequency conversion (e.g., converting secondly data into 5-minutely data). This is extremely common in, but not limited to, financial applications. See the Time Series section.\nIn [104]: rng = pd.date_range(\u0026#39;1/1/2012\u0026#39;, periods=100, freq=\u0026#39;S\u0026#39;) In [105]: ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng) In [106]: ts.resample(\u0026#39;5Min\u0026#39;).sum() Out[106]: 2012-01-01 24182 Freq: 5T, dtype: int64 Time zone representation:\nIn [107]: rng = pd.date_range(\u0026#39;3/6/2012 00:00\u0026#39;, periods=5, freq=\u0026#39;D\u0026#39;) In [108]: ts = pd.Series(np.random.randn(len(rng)), rng) In [109]: ts Out[109]: 2012-03-06 1.857704 2012-03-07 -1.193545 2012-03-08 0.677510 2012-03-09 -0.153931 2012-03-10 0.520091 Freq: D, dtype: float64 In [110]: ts_utc = ts.tz_localize(\u0026#39;UTC\u0026#39;) In [111]: ts_utc Out[111]: 2012-03-06 00:00:00+00:00 1.857704 2012-03-07 00:00:00+00:00 -1.193545 2012-03-08 00:00:00+00:00 0.677510 2012-03-09 00:00:00+00:00 -0.153931 2012-03-10 00:00:00+00:00 0.520091 Freq: D, dtype: float64 Converting to another time zone:\nIn [112]: ts_utc.tz_convert(\u0026#39;US/Eastern\u0026#39;) Out[112]: 2012-03-05 19:00:00-05:00 1.857704 2012-03-06 19:00:00-05:00 -1.193545 2012-03-07 19:00:00-05:00 0.677510 2012-03-08 19:00:00-05:00 -0.153931 2012-03-09 19:00:00-05:00 0.520091 Freq: D, dtype: float64 Converting between time span representations:\nIn [113]: rng = pd.date_range(\u0026#39;1/1/2012\u0026#39;, periods=5, freq=\u0026#39;M\u0026#39;) In [114]: ts = pd.Series(np.random.randn(len(rng)), index=rng) In [115]: ts Out[115]: 2012-01-31 -1.475051 2012-02-29 0.722570 2012-03-31 -0.322646 2012-04-30 -1.601631 2012-05-31 0.778033 Freq: M, dtype: float64 In [116]: ps = ts.to_period() In [117]: ps Out[117]: 2012-01 -1.475051 2012-02 0.722570 2012-03 -0.322646 2012-04 -1.601631 2012-05 0.778033 Freq: M, dtype: float64 In [118]: ps.to_timestamp() Out[118]: 2012-01-01 -1.475051 2012-02-01 0.722570 2012-03-01 -0.322646 2012-04-01 -1.601631 2012-05-01 0.778033 Freq: MS, dtype: float64 Converting between period and timestamp enables some convenient arithmetic functions to be used. In the following example, we convert a quarterly frequency with year ending in November to 9am of the end of the month following the quarter end:\nIn [119]: prng = pd.period_range(\u0026#39;1990Q1\u0026#39;, \u0026#39;2000Q4\u0026#39;, freq=\u0026#39;Q-NOV\u0026#39;) In [120]: ts = pd.Series(np.random.randn(len(prng)), prng) In [121]: ts.index = (prng.asfreq(\u0026#39;M\u0026#39;, \u0026#39;e\u0026#39;) + 1).asfreq(\u0026#39;H\u0026#39;, \u0026#39;s\u0026#39;) + 9 In [122]: ts.head() Out[122]: 1990-03-01 09:00 -0.289342 1990-06-01 09:00 0.233141 1990-09-01 09:00 -0.223540 1990-12-01 09:00 0.542054 1991-03-01 09:00 -0.688585 Freq: H, dtype: float64 Categoricals pandas can include categorical data in a DataFrame. For full docs, see the categorical introduction and the API documentation.\nIn [123]: df = pd.DataFrame({\u0026#34;id\u0026#34;: [1, 2, 3, 4, 5, 6], .....: \u0026#34;raw_grade\u0026#34;: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;]}) .....: Convert the raw grades to a categorical data type.\nIn [124]: df[\u0026#34;grade\u0026#34;] = df[\u0026#34;raw_grade\u0026#34;].astype(\u0026#34;category\u0026#34;) In [125]: df[\u0026#34;grade\u0026#34;] Out[125]: 0 a 1 b 2 b 3 a 4 a 5 e Name: grade, dtype: category Categories (3, object): [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;e\u0026#39;] Rename the categories to more meaningful names (assigning to Series.cat.categories() is in place!).\nIn [126]: df[\u0026#34;grade\u0026#34;].cat.categories = [\u0026#34;very good\u0026#34;, \u0026#34;good\u0026#34;, \u0026#34;very bad\u0026#34;] Reorder the categories and simultaneously add the missing categories (methods under Series.cat() return a new Series by default).\nIn [127]: df[\u0026#34;grade\u0026#34;] = df[\u0026#34;grade\u0026#34;].cat.set_categories([\u0026#34;very bad\u0026#34;, \u0026#34;bad\u0026#34;, \u0026#34;medium\u0026#34;, .....: \u0026#34;good\u0026#34;, \u0026#34;very good\u0026#34;]) .....: In [128]: df[\u0026#34;grade\u0026#34;] Out[128]: 0 very good 1 good 2 good 3 very good 4 very good 5 very bad Name: grade, dtype: category Categories (5, object): [\u0026#39;very bad\u0026#39;, \u0026#39;bad\u0026#39;, \u0026#39;medium\u0026#39;, \u0026#39;good\u0026#39;, \u0026#39;very good\u0026#39;] Sorting is per order in the categories, not lexical order.\nIn [129]: df.sort_values(by=\u0026#34;grade\u0026#34;) Out[129]: id raw_grade grade 5 6 e very bad 1 2 b good 2 3 b good 0 1 a very good 3 4 a very good 4 5 a very good Grouping by a categorical column also shows empty categories.\nIn [130]: df.groupby(\u0026#34;grade\u0026#34;).size() Out[130]: grade very bad 1 bad 0 medium 0 good 2 very good 3 dtype: int64 Plotting See the Plotting docs.\nWe use the standard convention for referencing the matplotlib API:\nIn [131]: import matplotlib.pyplot as plt In [132]: plt.close(\u0026#39;all\u0026#39;) In [133]: ts = pd.Series(np.random.randn(1000), .....: index=pd.date_range(\u0026#39;1/1/2000\u0026#39;, periods=1000)) .....: In [134]: ts = ts.cumsum() In [135]: ts.plot() Out[135]: \u0026lt;matplotlib.axes._subplots.AxesSubplot at 0x7f9f2d195a00\u0026gt; ![../_images/series_plot_basic.png](https://pandas.pydata.org/pandas-docs/stable/_images/series_plot_basic.png) On a DataFrame, the plot() method is a convenience to plot all of the columns with labels:\nIn [136]: df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, .....: columns=[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;]) .....: In [137]: df = df.cumsum() In [138]: plt.figure() Out[138]: \u0026lt;Figure size 640x480 with 0 Axes\u0026gt; In [139]: df.plot() Out[139]: \u0026lt;matplotlib.axes._subplots.AxesSubplot at 0x7f9f2d1b4400\u0026gt; In [140]: plt.legend(loc=\u0026#39;best\u0026#39;) Out[140]: \u0026lt;matplotlib.legend.Legend at 0x7f9f2d133790\u0026gt; Getting data in/out CSV Writing to a csv file.\nIn [141]: df.to_csv(\u0026#39;foo.csv\u0026#39;) Reading from a csv file.\nIn [142]: pd.read_csv(\u0026#39;foo.csv\u0026#39;) Out[142]: Unnamed: 0 A B C D 0 2000-01-01 0.350262 0.843315 1.798556 0.782234 1 2000-01-02 -0.586873 0.034907 1.923792 -0.562651 2 2000-01-03 -1.245477 -0.963406 2.269575 -1.612566 3 2000-01-04 -0.252830 -0.498066 3.176886 -1.275581 4 2000-01-05 -1.044057 0.118042 2.768571 0.386039 .. ... ... ... ... ... 995 2002-09-22 -48.017654 31.474551 69.146374 -47.541670 996 2002-09-23 -47.207912 32.627390 68.505254 -48.828331 997 2002-09-24 -48.907133 31.990402 67.310924 -49.391051 998 2002-09-25 -50.146062 33.716770 67.717434 -49.037577 999 2002-09-26 -49.724318 33.479952 68.108014 -48.822030 [1000 rows x 5 columns] HDF5 Reading and writing to HDFStores.\nWriting to a HDF5 Store.\nIn [143]: df.to_hdf(\u0026#39;foo.h5\u0026#39;, \u0026#39;df\u0026#39;) Reading from a HDF5 Store. In [144]: pd.read_hdf(\u0026#39;foo.h5\u0026#39;, \u0026#39;df\u0026#39;) Out[144]: A B C D 2000-01-01 0.350262 0.843315 1.798556 0.782234 2000-01-02 -0.586873 0.034907 1.923792 -0.562651 2000-01-03 -1.245477 -0.963406 2.269575 -1.612566 2000-01-04 -0.252830 -0.498066 3.176886 -1.275581 2000-01-05 -1.044057 0.118042 2.768571 0.386039 ... ... ... ... ... 2002-09-22 -48.017654 31.474551 69.146374 -47.541670 2002-09-23 -47.207912 32.627390 68.505254 -48.828331 2002-09-24 -48.907133 31.990402 67.310924 -49.391051 2002-09-25 -50.146062 33.716770 67.717434 -49.037577 2002-09-26 -49.724318 33.479952 68.108014 -48.822030 [1000 rows x 4 columns] Excel Reading and writing to MS Excel.\nWriting to an excel file.\nIn [145]: df.to_excel(\u0026#39;foo.xlsx\u0026#39;, sheet_name=\u0026#39;Sheet1\u0026#39;) Reading from an excel file. In [146]: pd.read_excel(\u0026#39;foo.xlsx\u0026#39;, \u0026#39;Sheet1\u0026#39;, index_col=None, na_values=[\u0026#39;NA\u0026#39;]) Out[146]: Unnamed: 0 A B C D 0 2000-01-01 0.350262 0.843315 1.798556 0.782234 1 2000-01-02 -0.586873 0.034907 1.923792 -0.562651 2 2000-01-03 -1.245477 -0.963406 2.269575 -1.612566 3 2000-01-04 -0.252830 -0.498066 3.176886 -1.275581 4 2000-01-05 -1.044057 0.118042 2.768571 0.386039 .. ... ... ... ... ... 995 2002-09-22 -48.017654 31.474551 69.146374 -47.541670 996 2002-09-23 -47.207912 32.627390 68.505254 -48.828331 997 2002-09-24 -48.907133 31.990402 67.310924 -49.391051 998 2002-09-25 -50.146062 33.716770 67.717434 -49.037577 999 2002-09-26 -49.724318 33.479952 68.108014 -48.822030 [1000 rows x 5 columns] Gotchas If you are attempting to perform an operation you might see an exception like:\n\u0026gt;\u0026gt;\u0026gt; if pd.Series([False, True, False]): ... print(\u0026#34;I was true\u0026#34;) Traceback ... ValueError: The truth value of an array is ambiguous. Use a.empty, a.any() or a.all(). See Comparisons for an explanation and what to do.\nSee Gotchas as well.\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/short_introduction/essential_snippets/",
	"title": "19 Essential Snippets in Pandas",
	"tags": [],
	"description": "",
	"content": " Aug 26, 2016\n After playing around with Pandas Python Data Analysis Library for about a month, I’ve compiled a pretty large list of useful snippets that I find myself reusing over and over again. These tips can save you some time sifting through the comprehensive Pandas docs.\nFor this article, we are starting with a DataFrame filled with Pizza orders. If you’re brand new to Pandas, here’s a few translations and key terms.\n DataFrame - Indexed rows and columns of data, like a spreadsheet or database table. Series = Single column of data. Axis - 0 == Rows, 1 == Columns Shape - (number_of_rows, number_of_columns) in a DataFrame  1. Importing a CSV File There are a ton of options for the read_csv function that can simplify preprocessing of data. Nobody want to waste time cleaning data, so see if you can knock it out when import the initial file.\ndf = pd.read_csv(\u0026#39;pizza.csv\u0026#39;) Need to parse dates? Just pass in the corresponding column name(s).\ndf = pd.read_csv(\u0026#39;pizza.csv\u0026#39;, parse_dates=[\u0026#39;dates\u0026#39;]) Only need a few specific columns?\ndf = pd.read_csv(\u0026#39;pizza.csv\u0026#39;, usecols=[\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;]) 2. Exploring Data in a DataFrame The first thing you probably want to do is see what the data looks like. Here a few ways to check out Pandas data.\ndf.head() # first five rows df.tail() # last five rows df.sample(5) # random sample of rows df.shape # number of rows/columns in a tuple df.describe() # calculates measures of central tendency df.info() # memory footprint and datatypes Here’s the head of the pizza DataFrame…\n   no order_number date size topping price discount coupon     0 PZZA0001 08/21/16 Small Anchovies 12.99 3.5 Yes   1 PZZA0000 09/26/16 Large Pepperoni 14.5 0.0 No   2 PZZA0001 09/27/16 Extra Large Bell Pepper 19.99 0.0 No   3 PZZA0002 09/28/16 Extra Large Olives 20.99 5.0 Yes   4 PZZA0003 09/29/16 Extra Large Pepperoni 21.99 0.0 No    3. Adding a New Column to a DataFrame The quick and easy way is to just define a new column on the dataframe. This will give us column with the number 23 on every row. Usually, you will be setting the new column with an array or Series that matches the number of rows in the data.\ndf[\u0026#39;new_column\u0026#39;] = 23 Need to build a new column based on values from other columns?\nfull_price = (df.price + df.discount) df[\u0026#39;original_price\u0026#39;] = full_price Need the column in a certain order? The first argument is the position of the column. This will put the column at the begining of the DataFrame.\ndf.insert(0, \u0026#39;original_price\u0026#39;, full_price) 4. Select a Specific “Cell” Value By cell I mean a single row/column intersection, like those in an Excel spreadsheet. You would expect this to be simple, but the syntax is not very obvious. There are three methods in Pandas that almost do the same thing, .loc, iloc, .ix – adding to the confusion for newcomers.\nTypically, I use .ix because it allows a mix of integers and strings. Enter the index of the row first, then the column.\ndf.ix[2, \u0026#39;topping\u0026#39;] You can also select the column first with dot notation, then the row index, which looks a little cleaner.\ndf.topping.ix[2] Either method will return the value of the cell.\n\u0026gt;\u0026gt;\u0026gt; 'Bell Pepper'\n5.Filtering DataFrames with Conditional Logic Let’s the we need to analyze orders that have pineapple in the topping column.\nfiltered_data = df[df.topping == \u0026#39;pineapple\u0026#39;] Or that meet a certain price threshold\nfiltered_data = df[df.price \u0026gt; 11.99 ] How about both at the same time? Just add the conditions to tuples and connect them with a bitwise operator.\nfiltered_data = df[(df.price \u0026gt; 11.99) \u0026amp; (df.topping == \u0026#39;Pineapple\u0026#39;)] Now we have all the pizzas with a Pineapple topping priced over 11.99.\norder_number date size topping price discount coupon 6 PZZA0006 10/01/16 Medium Pineapple 17.50 0.0 No 9 PZZA0009 10/04/16 Medium Pineapple 12.99 2.0 Yes 6. Sorting a DataFrame by a Certain Column Pretty self-explanatory, but very useful.\ndf.sort_values(\u0026#39;price\u0026#39;, axis=0, ascending=False) 7. Apply a Function to Every Row in a Column Anonymous lambda functions in Python are useful for these tasks. Let’s say we need to calculate taxes for every row in the DataFrame with a custom function. The pandas apply method allows us to pass a function that will run on every value in a column. In this example, we extract a new taxes feature by running a custom function on the price data.\ndef calculate_taxes(price): taxes = price * 0.12 return taxes df[\u0026#39;taxes\u0026#39;] = df.price.apply(calculate_taxes) order_number price taxes 0 PZZA0000 12.99 1.5588 1 PZZA0001 14.50 1.7400 2 PZZA0002 19.99 2.3988 3 PZZA0003 20.99 2.5188 4 PZZA0004 21.99 2.6388 8. Add a New Column with Conditional Logic The where function in numpy is useful when extracting features with conditional logic. Let’s imagine the pizza parlor is only profitable on sales above $15.00. We create a new column based on this insight like so:\ndf[\u0026#39;profitable\u0026#39;] = np.where(df[\u0026#39;price\u0026#39;]\u0026gt;=15.00, True, False) 9. Finding the Mean or Standard Deviation of Multiple Columns or Rows If you have a DataFrame with the same type of data in every column, possibly a time series with financial data, you may need to find he mean horizontally.\ndf[\u0026#39;mean\u0026#39;] = df.mean(axis=1) or to find the standard deviation vertically\ndf.std(axis=0) 10. Converting a DataFrame to a Numpy Array Converting the the values in a DataFrame to an array is simple\ndf.values If you want to preserve the table presentation\ndf.as_matrix 11. Combining DataFrames with Concatenation You can concatenate rows or columns together, the only requirement is that the shape is the same on corresponding axis. To concat rows vertically:\npd.concat([df_1, df_2], axis=0) Or to concat columns horizontally:\npd.concat([df_1, df_2], axis=1) 12. Combining DataFrames based on an Index Key Merging in Pandas works just like SQL. If you you have two DataFrames that share a key, perhaps a pizza ‘order_id’, you can perform inner, outer, left, right joins just like you would in SQL.\nmerged_df = df_1.merge(df_2, how=\u0026#39;left\u0026#39;, on=\u0026#39;order_id\u0026#39;) 13. Converting Dates to their own Day, Week, Month, Year Columns First, make sure the data is in datetime format. Then use dt method to extract the data you need.\ndate = pd.to_datetime(df.date) df[\u0026#39;weekday\u0026#39;] = date.dt.weekday df[\u0026#39;year\u0026#39;] = date.dt.year 14. Finding NaNs in a DataFrame Count the total number of NaNs present:\ndf.isnull().sum().sum() List the NaN count for each column:\ndf.isnull().sum() 15. Filling NaNs or Missing Data Most machine learning algorithms do not like NaN values, so you’ll probably need to convert them. If the topping column is missing some values, we can fill them a default value.\ndf.topping = df.topping.fillna(\u0026#39;Cheese\u0026#39;) or we can drop any row missing data across the entire DataFrame:\ndf = df.dropna(axis=0) 16. Extracting Features by Grouping Columns Grouping columns is a great way to extract features from data. This is especially useful when you have data that can be counted or quantified in some way. For example, you might have group pizzas by topping, then calculate the mean for price in each group.\ndf.groupby(\u0026#39;topping\u0026#39;)[\u0026#39;discount\u0026#39;].apply(lambda x: np.mean(x)) or maybe you want to see the count of a certain value\ndf.groupby(\u0026#39;topping\u0026#39;)[\u0026#39;discount\u0026#39;].apply(lambda x: x.count()) topping Anchovies 3 Bell Pepper 1 Cheese 2 Olives 1 Pepperoni 3 Pineapple 2 Veggie 1 Name: discount, dtype: int64 17.Creating Bins Let’s say we want to create 3 separate bins for different price ranges. This is especially useful for simplifying noisy data.\nbins = [0, 5, 15, 30] names = [\u0026#39;Cheap\u0026#39;, \u0026#39;Normal\u0026#39;, \u0026#39;Expensive\u0026#39;] df[\u0026#39;price_point\u0026#39;] = pd.cut(df.price, bins, labels=names)    order_number price price_point      0 PZZA0000 12.99 Normal   1 PZZA0001 14.50 Normal   2 PZZA0002 19.99 Expensive   3 PZZA0003 20.99 Expensive   4 PZZA0004 21.99 Expensive    18. Creating a new Column by Looping Let’s say we want to categorize toppings by ‘vegetable’ or ‘meat’. Dealing with nominal values like these can be handled with a for loop. (Note: you can also use the apply function described earlier to perform this task. )\ntopping_type = [] for row in df.topping: if row in [\u0026#39;pepperoni\u0026#39;, \u0026#39;chicken\u0026#39;, \u0026#39;anchovies\u0026#39;]: topping_type.append(\u0026#39;meat\u0026#39;) else: topping_type.append(\u0026#39;vegetable\u0026#39;) df[\u0026#39;topping_type\u0026#39;] = topping_type 19. Loading Massive Datasets in Smaller Chunks Sometimes you might have a massive file that will max out your RAM and crash your system. In that case, you might need to analyze the file in smaller chunks.\nchunksize = 500 chunks = [] for chunk in pd.read_csv(\u0026#39;pizza.csv\u0026#39;, chunksize=chunksize): # Do stuff... chunks.append(chunk) df = pd.concat(chunks, axis=0)  Written with StackEdit.\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/quick_guide/a-81-python-code-snippet/",
	"title": "81 Python Code Snippets",
	"tags": [],
	"description": "",
	"content": "81 Python Code Snippets for Everyday Problems\n POSTED ON DECEMBER 27, 2019 BY JEREMY GRIFSKI\n If you’ve been following me for any amount of time, you know that I regularly publish Python code snippets for everyday problems. Well, I figured I’d finally aggregate all those responses in one massive article with links to all those resources.\nAs a heads up, I’m looking to start porting all of the code snippets in this article to Jupyter Notebooks. If you’re interested in that kind of project, head on over to the GitHub repo. I’d appreciate the help!\nTable of Contents  Table of Contents Everyday Problems  Inverting a Dictionary Summing Elements of Two Lists Checking if a File Exists Converting Two Lists Into a Dictionary Checking if a List Is Empty Cloning a List Retrieving the Last Item of a List Making a Python Script Shortcut Sorting a List of Strings Parsing a Spreadsheet Sorting a List of Dictionaries Writing a List Comprehension Merging Two Dictionaries Formatting a String Printing on the Same Line Testing Performance Performing a Reverse Dictionary Lookup Checking if a String Contains a Substring   Share Your Own Problems  Everyday Problems In this section, we’ll take a look at various common scenarios that arise and how to solve them with Python code. Specifically, I’ll share a brief explanation of the problem with a list of Python code solutions. Then, I’ll link all the resources I have.\nInverting a Dictionary Sometimes when we have a dictionary, we want to be able to flip its keys and values. Of course, there are concerns like “how do we deal with duplicate values?” and “what if the values aren’t hashable?” That said, in the simple case, there are a few solutions:\n1. # Use to invert dictionaries that have unique values 2. my_inverted_dict = dict(map(reversed, my_dict.items())) 4. # Use to invert dictionaries that have unique values 5. my_inverted_dict = {value: key for key, value in my_dict.items()} 7. # Use to invert dictionaries that have non-unique values 8. from collections import defaultdict 9. my_inverted_dict = defaultdict(list) 10. {my_inverted_dict[v].append(k) for k, v in my_dict.items()} 12. # Use to invert dictionaries that have non-unique values 13. my_inverted_dict = dict() 14. for key, value in my_dict.items(): 15. my_inverted_dict.setdefault(value, list()).append(key) 17. # Use to invert dictionaries that have lists of values 18. my_dict = {value: key for key in my_inverted_dict for value in my_map[key]} For more explanation, check out my article titled “How to Invert a Dictionary in Python.” It includes a breakdown of each solution, their performance metrics, and when they’re applicable. Likewise, I have a YouTube video which covers the same topic.\nSumming Elements of Two Lists Let’s say you have two lists, and you want to merge them together into a single list by element. In other words, you want to add the first element of the first list to the first element of the second list and store the result in a new list. Well, there are several ways to do that:\n1. ethernet_devices = [1, [7], [2], [8374163], [84302738]] 2. usb_devices = [1, [7], [1], [2314567], [0]] 4. # The long way 5. all_devices = [ 6. ethernet_devices[0] + usb_devices[0], 7. ethernet_devices[1] + usb_devices[1], 8. ethernet_devices[2] + usb_devices[2], 9. ethernet_devices[3] + usb_devices[3], 10. ethernet_devices[4] + usb_devices[4] 11. ] 13. # Some comprehension magic 14. all_devices = [x + y for x, y in zip(ethernet_devices, usb_devices)] 16. # Let\u0026#39;s use maps 17. import operator 18. all_devices = list(map(operator.add, ethernet_devices, usb_devices)) 20. # We can\u0026#39;t forget our favorite computation library 21. import numpy as np 22. all_devices = np.add(ethernet_devices, usb_devices) If you’d like a deeper explanation, check out my article titled “How to Sum Elements of Two Lists in Python” which even includes a fun challenge. Likewise, you might get some value out of my YouTube video on the same topic.\nChecking if a File Exists One of the amazing perks of Python is how easy it is to manage files. Unlike Java, Python has a built-in syntax for file reading and writing. As a result, checking if a file exists is a rather brief task:\n1. # Brute force with a try-except block (Python 3+) 2. try: 3. with open(\u0026#39;/path/to/file\u0026#39;, \u0026#39;r\u0026#39;) as fh: 4. pass 5. except FileNotFoundError: 6. pass 8. # Leverage the OS package (possible race condition) 9. import os 10. exists = os.path.isfile(\u0026#39;/path/to/file\u0026#39;) 12. # Wrap the path in an object for enhanced functionality 13. from pathlib import Path 14. config = Path(\u0026#39;/path/to/file\u0026#39;) 15. if config.is_file(): 16. pass As always, you can learn more about these solutions in my article titled “How to Check if a File Exists in Python” which features three solutions and performances metrics.\nConverting Two Lists Into a Dictionary Previously, we talked about summing two lists in Python. As it turns out, there’s a lot we can do with two lists. For example, we could try mapping one onto the other to create a dictionary.\nAs with many of these problems, there are a few concerns. For instance, what if the two lists aren’t the same size? Likewise, what if the keys aren’t unique or hashable? That said, in the simple case, there are some straightforward solutions:\n1. column_names = [\u0026#39;id\u0026#39;, \u0026#39;color\u0026#39;, \u0026#39;style\u0026#39;] 2. column_values = [1, \u0026#39;red\u0026#39;, \u0026#39;bold\u0026#39;] 4. # Convert two lists into a dictionary with zip and the dict constructor 5. name_to_value_dict = dict(zip(column_names, column_values)) 7. # Convert two lists into a dictionary with a dictionary comprehension 8. name_to_value_dict = {key:value for key, value in zip(column_names, column_values)} 10. # Convert two lists into a dictionary with a loop 11. name_value_tuples = zip(column_names, column_values) 12. name_to_value_dict = {} 13. for key, value in name_value_tuples: 14. if key in name_to_value_dict: 15. pass # Insert logic for handling duplicate keys 16. else: 17. name_to_value_dict[key] = value Once again, you can find an explanation for each of these solutions and more in my article titled “How to Convert Two Lists Into a Dictionary in Python.” If you are a visual person, you might prefer my YouTube video which covers mapping lists to dictionaries as well.\nChecking if a List Is Empty If you come from a statically typed language like Java or C, you might be bothered by the lack of static types in Python. Sure, not knowing the type of a variable can sometimes be frustrating, but there are perks as well. For instance, we can check if a list is empty by its type flexibility—among other methods:\n1. my_list = list() 3. # Check if a list is empty by its length 4. if len(my_list) == 0: 5. pass # the list is empty 7. # Check if a list is empty by direct comparison (only works for lists) 8. if my_list == []: 9. pass # the list is empty 11. # Check if a list is empty by its type flexibility **preferred method** 12. if not my_list: 13. pass # the list is empty If you’d like to learn more about these three solutions, check out my article titled “How to Check if a List in Empty in Python.” If you’re in a pinch, check out my YouTube video which covers the same topic.\nCloning a List One of my favorite subjects in programming is copying data types. After all, it’s never easy in this reference-based world we live, and that’s true for Python as well. Luckily, if we want to copy a list, there are a few ways to do it:\n1. my_list = [27, 13, -11, 60, 39, 15] 3. # Clone a list by brute force 4. my_duplicate_list = [item for item in my_list] 6. # Clone a list with a slice 7. my_duplicate_list = my_list[:] 9. # Clone a list with the list constructor 10. my_duplicate_list = list(my_list) 12. # Clone a list with the copy function (Python 3.3+) 13. my_duplicate_list = my_list.copy() # preferred method 15. # Clone a list with the copy package 16. import copy 17. my_duplicate_list = copy.copy(my_list) 18. my_deep_duplicate_list = copy.deepcopy(my_list) 20. # Clone a list with multiplication? 21. my_duplicate_list = my_list * 1 # do not do this When it comes to cloning, it’s important to be aware of the difference between shallow and deep copies. Luckily, I have an article covering that topic.\nFinally, you can find out more about the solutions listed above in my article titled “How to Clone a List in Python.” In addition, you might find value in my related YouTube video titled “7 Ways to Copy a List in Python Featuring The Pittsburgh Penguins.”\nRetrieving the Last Item of a List Since we’re on the topic of lists, lets talk about getting the last item of a list. In most languages, this involves some convoluted mathematical expression involving the length of the list. What if I told you there is are several more interesting solutions in Python?\n1. my_list = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;] 3. # Get the last item with brute force using len 4. last_item = my_list[len(my_list) - 1] 6. # Remove the last item from the list using pop 7. last_item = my_list.pop() 9. # Get the last item using negative indices *preferred \u0026amp; quickest method* 10. last_item = my_list[-1] 12. # Get the last item using iterable unpacking 13. *_, last_item = my_list As always, you can learn more about these solutions from my article titled “How to Get the Last Item of a List in Python” which features a challenge, performance metrics, and a YouTube video.\nMaking a Python Script Shortcut Sometimes when you create a script, you want to be able to run it conveniently at the click of a button. Fortunately, there are several ways to do that.\nFirst, we can create a Windows shortcut with the following settings:\n1. \\path\\to\\trc-image-titler.py -o \\path\\to\\output Likewise, we can also create a batch file with the following code:\n1. @echo off 2. \\path\\to\\trc-image-titler.py -o \\path\\to\\output Finally, we can create a bash script with the following code:\n1. #!/bin/sh 2. python /path/to/trc-image-titler.py -o /path/to/output If you’re looking for more explanation, check out the article titled “How to Make a Python Script Shortcut with Arguments.”\nSorting a List of Strings Sorting is a common task that you’re expected to know how to implement in Computer Science. Despite the intense focus on sorting algorithms in most curriculum, no one really tells you how complicated sorting can actually get. For instance, sorting numbers is straightforward, but what about sorting strings? How do we decide a proper ordering? Fortunately, there are a lot of options in Python:\n1. my_list = [\u0026#34;leaf\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;fish\u0026#34;] 3. # Brute force method using bubble sort 4. my_list = [\u0026#34;leaf\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;fish\u0026#34;] 5. size = len(my_list) 6. for i in range(size): 7. for j in range(size): 8. if my_list[i] \u0026lt; my_list[j]: 9. temp = my_list[i] 10. my_list[i] = my_list[j] 11. my_list[j] = temp 13. # Generic list sort *fastest* 14. my_list.sort() 16. # Casefold list sort 17. my_list.sort(key=str.casefold) 19. # Generic list sorted 20. my_list = sorted(my_list) 22. # Custom list sort using casefold (\u0026gt;= Python 3.3) 23. my_list = sorted(my_list, key=str.casefold) 25. # Custom list sort using current locale 26. import locale 27. from functools import cmp_to_key 28. my_list = sorted(my_list, key=cmp_to_key(locale.strcoll)) 30. # Custom reverse list sort using casefold (\u0026gt;= Python 3.3) 31. my_list = sorted(my_list, key=str.casefold, reverse=True) If you’re curious about how some of these solutions work, or you just want to know what some of the potential risks are, check out my article titled “How to Sort a List of Strings in Python.”\nParsing a Spreadsheet One of the more interesting use cases for Python is data science. Unfortunately, however, that means handling a lot of raw data in various formats like text files and spreadsheets. Luckily, Python has plenty of built-in utilities for reading different file formats. For example, we can parse a spreadsheet with ease:\n1. # Brute force solution 2. csv_mapping_list = [] 3. with open(\u0026#34;/path/to/data.csv\u0026#34;) as my_data: 4. line_count = 0 5. for line in my_data: 6. row_list = [val.strip() for val in line.split(\u0026#34;,\u0026#34;)] 7. if line_count == 0: 8. header = row_list 9. else: 10. row_dict = {key: value for key, value in zip(header, row_list)} 11. csv_mapping_list.append(row_dict) 12. line_count += 1 14. # CSV reader solution 15. import csv 16. csv_mapping_list = [] 17. with open(\u0026#34;/path/to/data.csv\u0026#34;) as my_data: 18. csv_reader = csv.reader(my_data, delimiter=\u0026#34;,\u0026#34;) 19. line_count = 0 20. for line in csv_reader: 21. if line_count == 0: 22. header = line 23. else: 24. row_dict = {key: value for key, value in zip(header, line)} 25. csv_mapping_list.append(row_dict) 26. line_count += 1 28. # CSV DictReader solution 29. import csv 30. with open(\u0026#34;/path/to/dict.csv\u0026#34;) as my_data: 31. csv_mapping_list = list(csv.DictReader(my_data)) In this case, we try to get our output in a list of dictionaries. If you want to know more about how this works, check out the complete article titled “How to Parse a Spreadsheet in Python.”\nSorting a List of Dictionaries Once you have a list of dictionaries, you might want to organize them in some specific order. For example, if the dictionaries have a key for date, we can try sorting them in chronological order. Luckily, sorting is another relatively painless task:\n1. csv_mapping_list = [ 2. { 3. \u0026#34;Name\u0026#34;: \u0026#34;Jeremy\u0026#34;, 4. \u0026#34;Age\u0026#34;: 25, 5. \u0026#34;Favorite Color\u0026#34;: \u0026#34;Blue\u0026#34; 6. }, 7. { 8. \u0026#34;Name\u0026#34;: \u0026#34;Ally\u0026#34;, 9. \u0026#34;Age\u0026#34;: 41, 10. \u0026#34;Favorite Color\u0026#34;: \u0026#34;Magenta\u0026#34; 11. }, 12. { 13. \u0026#34;Name\u0026#34;: \u0026#34;Jasmine\u0026#34;, 14. \u0026#34;Age\u0026#34;: 29, 15. \u0026#34;Favorite Color\u0026#34;: \u0026#34;Aqua\u0026#34; 16. } 17. ] 19. # Custom sorting 20. size = len(csv_mapping_list) 21. for i in range(size): 22. min_index = i 23. for j in range(i + 1, size): 24. if csv_mapping_list[min_index][\u0026#34;Age\u0026#34;] \u0026gt; csv_mapping_list[j][\u0026#34;Age\u0026#34;]: 25. min_index = j 26. csv_mapping_list[i], csv_mapping_list[min_index] = csv_mapping_list[min_index], csv_mapping_list[i] 28. # List sorting function 29. csv_mapping_list.sort(key=lambda item: item.get(\u0026#34;Age\u0026#34;)) 31. # List sorting using itemgetter 32. from operator import itemgetter 33. f = itemgetter(\u0026#39;Name\u0026#39;) 34. csv_mapping_list.sort(key=f) 36. # Iterable sorted function 37. csv_mapping_list = sorted(csv_mapping_list, key=lambda item: item.get(\u0026#34;Age\u0026#34;)) All these solutions and more outlined in my article titled “How to Sort a List of Dictionaries in Python.”\nWriting a List Comprehension One of my favorite Python topics to chat about is list comprehensions. As someone who grew up on languages like Java, C/C++, and C#, I had never seen anything quite like a list comprehension until I played with Python. Now, I’m positively obsessed with them. As a result, I put together an entire list of examples:\n1. # Define a generic 1D list of constants 2. my_list = [2, 5, -4, 6] 4. # Duplicate a 1D list of constants 5. [item for item in my_list] 7. # Duplicate and scale a 1D list of constants 8. [2 * item for item in my_list] 10. # Duplicate and filter out non-negatives from 1D list of constants 11. [item for item in my_list if item \u0026lt; 0] 13. # Duplicate, filter, and scale a 1D list of constants 14. [2 * item for item in my_list if item \u0026lt; 0] 16. # Generate all possible pairs from two lists 17. [(a, b) for a in (1, 3, 5) for b in (2, 4, 6)] 19. # Redefine list of contents to be 2D 20. my_list = [[1, 2], [3, 4]] 22. # Duplicate a 2D list 23. [[item for item in sub_list] for sub_list in my_list] 25. # Duplicate an n-dimensional list 26. def deep_copy(to_copy): 27. if type(to_copy) is list: 28. return [deep_copy(item) for item in to_copy] 29. else: 30. return to_copy As always, you can find a more formal explanation of all this code in my article titled “How to Write a List Comprehension in Python.” As an added bonus, I have a YouTube video which shares several examples of list comprehensions.\nMerging Two Dictionaries In this collection, we talk a lot about handling data structures like lists and dictionaries. Well, this one is no different. In particular, we’re looking at merging two dictionaries. Of course, combining two dictionaries comes with risks. For example, what if there are duplicate keys? Luckily, we have solutions for that:\n1. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;} 2. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;} 3. powers = dict() 5. # Brute force 6. for dictionary in (yusuke_power, hiei_power): 7. for key, value in dictionary.items(): 8. powers[key] = value 10. # Dictionary Comprehension 11. powers = {key: value for d in (yusuke_power, hiei_power) for key, value in d.items()} 13. # Copy and update 14. powers = yusuke_power.copy() 15. powers.update(hiei_power) 17. # Dictionary unpacking (Python 3.5+) 18. powers = {**yusuke_power, **hiei_power} 20. # Backwards compatible function for any number of dicts 21. def merge_dicts(*dicts: dict): 22. merged_dict = dict() 23. for dictionary in dicts: 24. merge_dict.update(dictionary) 25. return merged_dict If you’re interested, I have an article which covers this exact topic called “How to Merge Two Dictionaries in Python” which features four solutions as well performance metrics.\nFormatting a String Whether we like to admit it or not, we often find ourselves burying print statements throughout our code for quick debugging purposes. After all, a well placed print statement can save you a lot of time. Unfortunately, it’s not always easy or convenient to actually display what we want. Luckily, Python has a lot of formatting options:\n1. name = \u0026#34;Jeremy\u0026#34; 2. age = 25 4. # String formatting using concatenation 5. print(\u0026#34;My name is \u0026#34; + name + \u0026#34;, and I am \u0026#34; + str(age) + \u0026#34; years old.\u0026#34;) 7. # String formatting using multiple prints 8. print(\u0026#34;My name is \u0026#34;, end=\u0026#34;\u0026#34;) 9. print(name, end=\u0026#34;\u0026#34;) 10. print(\u0026#34;, and I am \u0026#34;, end=\u0026#34;\u0026#34;) 11. print(age, end=\u0026#34;\u0026#34;) 12. print(\u0026#34; years old.\u0026#34;) 14. # String formatting using join 15. print(\u0026#39;\u0026#39;.join([\u0026#34;My name is \u0026#34;, name, \u0026#34;, and I am \u0026#34;, str(age), \u0026#34; years old\u0026#34;])) 17. # String formatting using modulus operator 18. print(\u0026#34;My name is %s, and I am %dyears old.\u0026#34; % (name, age)) 20. # String formatting using format function with ordered parameters 21. print(\u0026#34;My name is {}, and I am {} years old\u0026#34;.format(name, age)) 23. # String formatting using format function with named parameters 24. print(\u0026#34;My name is {n}, and I am {a} years old\u0026#34;.format(a=age, n=name)) 26. # String formatting using f-Strings (Python 3.6+) 27. print(f\u0026#34;My name is {name}, and I am {age} years old\u0026#34;) Keep in mind that these solutions don’t have to be used with print statements. In other words, feel free to use solutions like f-strings wherever you need them.\nAs always, you can find an explanation of all these solutions and more in my article titled “How to Format a String in Python.” If you’d rather see these snippets in action, check out my YouTube video titled “6 Ways to Format a String in Python Featuring My Cat.”\nPrinting on the Same Line Along a similar line as formatting strings, sometimes you just need to print on the same line in Python. As the print command is currently designed, it automatically applies a newline to the end of your string. Luckily, there are a few ways around that:\n1. # Python 2 only 2. print \u0026#34;Live PD\u0026#34;, 4. # Backwards compatible (also fastest) 5. import sys 6. sys.stdout.write(\u0026#34;Breaking Bad\u0026#34;) 8. # Python 3 only 9. print(\u0026#34;Mob Psycho 100\u0026#34;, end=\u0026#34;\u0026#34;) As always, if you plan to use any of these solutions, check out the article titled “How to Print on the Same Line in Python” for additional use cases and caveats.\nTesting Performance Finally, sometimes you just want to compare a couple chunks of code. Luckily, Python has a few straightforward options:\n1. # Brute force solution 2. import datetime 3. start_time = datetime.datetime.now() 4. [(a, b) for a in (1, 3, 5) for b in (2, 4, 6)] # example snippet 5. end_time = datetime.datetime.now() 6. print end_time - start_time 8. # timeit solution 9. import timeit 10. min(timeit.repeat(\u0026#34;[(a, b) for a in (1, 3, 5) for b in (2, 4, 6)]\u0026#34;)) 12. # cProfile solution 13. import cProfile 14. cProfile.run(\u0026#34;[(a, b) for a in (1, 3, 5) for b in (2, 4, 6)]\u0026#34;) Again, if you want more details, check the article titled “How to Performance Test Python Code.”\nPerforming a Reverse Dictionary Lookup Earlier we talked about reversing a dictionary which is fine in some circumstances. Of course, if our dictionary is enormous, it might not make sense to outright flip the dict. Instead, we can lookup a key based on a value:\n1. my_dict = {\u0026#34;color\u0026#34;: \u0026#34;red\u0026#34;, \u0026#34;width\u0026#34;: 17, \u0026#34;height\u0026#34;: 19} 2. value_to_find = \u0026#34;red\u0026#34; 4. # Brute force solution (fastest) -- single key 5. for key, value in my_dict.items(): 6. if value == value_to_find: 7. print(f\u0026#39;{key}: {value}\u0026#39;) 8. break 10. # Brute force solution -- multiple keys 11. for key, value in my_dict.items(): 12. if value == value_to_find: 13. print(f\u0026#39;{key}: {value}\u0026#39;) 15. # Generator expression -- single key 16. key = next(key for key, value in my_dict.items() if value == value_to_find) 17. print(f\u0026#39;{key}: {value_to_find}\u0026#39;) 19. # Generator expression -- multiple keys 20. exp = (key for key, value in my_dict.items() if value == value_to_find) 21. for key in exp: 22. print(f\u0026#39;{key}: {value}\u0026#39;) 24. # Inverse dictionary solution -- single key 25. my_inverted_dict = {value: key for key, value in my_dict.items()} 26. print(f\u0026#39;{my_inverted_dict[value_to_find]}: {value_to_find}\u0026#39;) 28. # Inverse dictionary solution (slowest) -- multiple keys 29. my_inverted_dict = dict() 30. for key, value in my_dict.items(): 31. my_inverted_dict.setdefault(value, list()).append(key) 32. print(f\u0026#39;{my_inverted_dict[value_to_find]}: {value_to_find}\u0026#39;) If this seems helpful, you can check out the source article titled “How to Perform a Reverse Dictionary Lookup in Python“. One of the things I loved about writing this article was learning about generator expressions. If you’re seeing them for the first time, you might want to check it out.\nChecking if a String Contains a Substring One thing I find myself searching more often than I should is the way to check if a string contains a substring in Python. Unlike most programming languages, Python leverages a nice keyword for this problem. Of course, there are also method-based solutions as well:\n1. addresses = [ 2. \u0026#34;123 Elm Street\u0026#34;, 3. \u0026#34;531 Oak Street\u0026#34;, 4. \u0026#34;678 Maple Street\u0026#34; 5. ] 6. street = \u0026#34;Elm Street\u0026#34; 8. # Brute force (don\u0026#39;t do this) 9. for address in addresses: 10. address_length = len(address) 11. street_length = len(street) 12. for index in range(address_length - street_length + 1): 13. substring = address[index:street_length + index] 14. if substring == street: 15. print(address) 17. # The index method 18. for address in addresses: 19. try: 20. address.index(street) 21. print(address) 22. except ValueError: 23. pass 25. # The find method 26. for address in addresses: 27. if address.find(street) \u0026gt; 0: 28. print(address) 30. # The in keyword (fastest/preferred) 31. for address in addresses: 32. if street in address: 33. print(address) If you’re like me and forget about the in keyword, you might want to bookmark the “How to Check if a String Contains a Substring” article.\nShare Your Own Problems As you can see, this article and its associated series is already quite large. That said, I’d love to continue growing them. As a result, you should consider sharing some of your own problems. After all, there has be something you Google regularly. Why not share it with us?\nIn the meantime, help grow this collection by hopping on my newsletter, visiting the shop, subscribing to my YouTube channel, and/or becoming a patron. In addition, you’re welcome to browse the following related articles:\n The Controversy Behind the Walrus Operator in Python Rock Paper Scissors Using Modular Arithmetic  Otherwise, thanks for stopping by! I appreciate the support.\n Reference : https://therenegadecoder.com.\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/basic_syntax/",
	"title": "Basic Syntax",
	"tags": [],
	"description": "",
	"content": "รวม syntax พื้นฐานของภาษา Python ฉบับรวบรัด  21 Feb 2018\n ในตอนนี้ Python ถือว่าเป็นหนึ่งในภาษายอดนิยมเพราะสามารถเอาไปใช้งานในด้าน Data Sci. ได้เป็นอย่างดี (เอาไปทำอย่างอื่นเช่นเขียนเว็บก็ได้นะ) เลยมีคนสนใจเยอะมาก\nในบทความนี้จะพูดถึง syntax พื้นฐานการเขียน Python ซึ่งจะเน้นที่เวอร์ชั่น 3 เป็นหลัก\nRunning Mode สำหรับภาษา Python นั้นเป็นภาษาแบบ interpreter ซึ่งทำให้เรารันโปรแกรมได้ 2 รูปแบบคือ\nterminal เป็นการรัน Python ใน terminal หรือ command-line ซึ่งจะเป็นการพิมพ์คำสั่งทีละคำสั่ง โดยไม่ต้องสร้างไฟล์ .py ขึ้นมา\nวิธีการใช้คือรันคำสั่ง python หลังจากนั้นก็จะเป็น terminal ของ Python เด้งขึ้นต่อมาให้พิมพ์โค้ดได้เลย\nส่วนใหญ่จะเอาไว้เทสโค้ดหรือทดสอบอะไรเล็กๆ น้อยๆ เน้นความเร็วซะมากกว่าเขียนโปรแกรมจริงจัง\n\nfile วิธีที่ 2 ส่วนใหญ่จะใช้กับการเขียนโปรแกรมแบบปกติ จะต้องเขียนโค้ดในไฟล์นามสกุล .py ของ Python ส่วนวิธีการรันโปรแกรมจะใช้คำสั่งเหมือนกับโหมด terminal แต่ต้องเพิ่มชื่อไฟล์ตามหลังด้วย เช่น python main.py เป็นต้น\nหรืออีกวิธีคือใช้ IDE สำหรับเขียน Python โดยเฉพาะเช่น PyCharm, Anaconda, หรือ Canopy ซึ่งโปรแกรมพวกนี้สามารถรันได้ในตัวเองอยู่แล้ว\n[Input/Output การรับค่าในภาษา Python จะใช้คำสั่ง input() ส่วนการปริ๊นค่าออกมาจะใช้คำสั่ง print() ซึ่งในจุดนี้สำหรับ python2 และ python3 จะเขียนต่างกันพอสมควรเลย\n#python2 num = input(\u0026#34;input the number: \u0026#34;) name = raw_input(\u0026#34;input your name: \u0026#34;) #python3 x = input() #always get String สำหรับ python2 การรับค่าที่เป็นตัวเลขจะใช้ input() ธรรมดาส่วนถ้าอยากได้ค่าเป็น string จะใช้ต้อง raw_input() แทน\nส่วน python3 จะเหลือแค่ input() ตัวเดียวซึ่งให้ค่าเป็น string เสมอ แต่ถ้าอยากได้เป็นตัวเลข ก็สามารถ cast string ให้เป็น int หรือตัวแปรชนิดอื่นๆ ได้ด้วยคำสั่งพวก int() และ float()\n#python3 num = int(input(\u0026#34;input the number: \u0026#34;)) name = input(\u0026#34;input your name: \u0026#34;) ส่วนการ print ก็ต่างกันเช่นกัน แบบนี้\n#python2 print \u0026#34;hello world!\u0026#34; #python3 print(\u0026#34;hello world!\u0026#34;) นั่นคือใน python2 นั้น print จะถือว่าเป็นคำสั่งประเภทนึง แต่ใน python3 นั้นจะถือว่า print() นั้นเป็นฟังก์ชัน ดังนั้นต้องใส่ ( ) ทุกรอบ\nComment มีสองแบบคือ\n inline block  #ตรงนี้เป็นคอมเมนท์นะ print(\u0026#34;hello\u0026#34;) #ตรงนี้ก็เป็นคอมเมนท์นะ \u0026#34;\u0026#34;\u0026#34; อันนี้เป็นคอมเมนท์ แบบblock ละนะ \u0026#34;\u0026#34;\u0026#34; Variable ตัวแปรในภาษา Python เป็นแบบ dynamic-type คือสามารถเป็น value ได้ทุกชนิดโดยไม่ต้องกำหนดประเภทของชนิดข้อมูล (ไม่เหมือนพวกภาษา C, Java ที่ต้องกำหนดตัวแปรเช่น int x สำหรับเก็บจำนวนเต็มโดยเฉพาะ)\nData Type หลักๆ ของ Python มี\n int - จำนวนเต็ม เช่น 1, 200, 1024 float - ทศนิยม เช่น 12.34, 3.1416 str - ตัวอักษรและอักขระ ในภาษานี้ไม่ได้แยกเป็น char เป็นนับรวมๆ เป็นตัวอักษรทั้งหมดเลย เช่น \u0026ldquo;Tamemo.com\u0026rdquo; หรือ \u0026ldquo;This is a book\u0026rdquo; (ใช้ได้ทั้งแบบ \u0026ldquo;\u0026hellip;\u0026rdquo; double-quote และแบบ \u0026lsquo;\u0026hellip;\u0026rsquo; single-quote) bool - ค่าความจริงซึ่งมีแค่ 2 ค่าเท่านั้นคือ True / False None - มีค่าคล้ายๆ กับค่า null หรือ nil ในภาษาอื่น คือค่าที่ไม่มีค่าใดๆ (แต่จะทำให้ตัวแปรเกิดขึ้นได้ ใช้กับกรณีที่ต้องการให้ตัวแปร ซึ่งฐานนะของตัวแปรตัวนั้นจะต่างจากตัวแปรที่ยังไม่ได้กำหนดค่ามาก่อนที่เป็น undefined)  เนื่องจากภาษา Python เป็นภาษาแบบ interpreter เลยไม่มีปัญหากับการจองขนาดหน่วยความจำ (เพราะยังไงก็ต้องคำนวนตำแหน่งหน่วยความจำแบบ pointer อยู่แล้ว) ตัวแปรประเภทตัวเลขเลยสามารถเก็บกี่หลักก็ได้ไม่มีปัญหาแบบภาษาตระกูล C ที่ต้องกำหนดขนาดของตัวเลขให้ชัดเจนว่าใช้กี่ byte ในภาษานี้เลยแบ่งเป็นแค่ int กับ float ก็เพียงพอแล้ว\nเราสามารถกำหนดค่าให้ตัวแปรและทำ operation ทางคณิตศาสตร์ได้แบบนี้\nx = 10 #กำหนดค่า x = 1 + 1 #บวก x = 2 - 3 #ลบ x = 4 * 5 #คูณ x = 8 / 4 #หาร x = 7 % 3 #หารเอาเศษ x = 2 ** 5 #ยกกำลัง x += 1 #มีค่าเท่ากับการเขียนว่า x = x + 1 10 == 10 #ได้ค่าเป็น True เป็นการเช็กว่าค่าทั้งสองเท่ากันหรือไม่ (ในกรณี 1 กัย \u0026#34;1\u0026#34; จะถือว่าไม่เท่ากันนะ) 1 != 2 #จะได้ค่าเป็น False เอาไว้เช็กว่าไม่เท่ากับกัน แล้วก็ภาษานี้ไม่มีการใส่ ; หลังจบประโยคนะ\nการทำ Type Casting หรือการแปลชนิดของตัวแปรจะใช้คำสั่งตามชนิดของตัวแปรชนิดนั้น เช่น\nx = 1 y = float(x) #แปลง int เป็น float x = 1.5 y = int(x) #แปลง float เป็น int x = \u0026#34;2385\u0026#34; y = int(x) #แปลง str เป็น int สำหรับการเช็กว่า variable หรือ value ต่างๆ เป็น data type ชนิดไหนจะใช้คำสั่ง `type()` ในการเช็ก x = 10 type(x) #int y = 3.1416 type(y) #float name = \u0026#34;tamemo.com\u0026#34; type(name) #str b = True type(b) #bool n = None type(n) #NoneType การแสดงค่าใน Python จะใช้คำสั่ง `print()` แบบนี้ print(\u0026#34;hello world!\u0026#34;) x = 10 print(x) แต่การใช้ print ในภาษานี้จะต่างจากภาษาอื่นๆ นิดหน่อยคือมันจะ auto new-line หรือปริ๊นค่าเสร็จแล้วขึ้่นบรรทัดใหม่ให้ทันทีเลย\nข้อแตกต่างระหว่าง python2: ใน Python3 คำสั่ง print นั้นถือว่าเป็น function ดังนั้นต้องเขียน ( ) ด้วยทุกครั้ง ต่างจาก python2 ที่เขียนแค่ print \u0026quot;hello world!\u0026quot; ได้\nสำหรับการลบตัวแปรทิ้งจะใช้คำสั่ง del เช่น del x\nData Structure เป็นชนิดตัวแปรแบบ data struct ในภาษา Python ประกอบด้วย\nlist เป็นตัวแปรที่เก็บได้หลายค่าในตัวเดียว เทียบเท่ากับ array ในภาษาอื่น แต่ไม่จำกัดความยาว สามารถเพิ่มสมาชิกหรือลบทิ้งออกไปได้เรื่อยๆ index ของ list ใช้แบบ zero-base หรือเริ่มต้นค่าแรกใน list จะเริ่มต้นที่ตำแหน่ง 0 แบบภาษา C\nnum = [10, 20, 30, 40] manga = [\u0026#34;One Piece\u0026#34;, \u0026#34;Bleach\u0026#34;, \u0026#34;Naruto\u0026#34;] print(num[0]) #10 num[0] = 100 #ตอนนี้ num จะมีค่าเป็น [100, 20, 30, 40] คำสั่งเริ่มสำหรับการจัดการข้อมูลใน list อื่นๆ เช่น len(), .append(), .insert(), .pop() แบบนี้\ndata = [1, 2, 3, 4] #ถามขนาดของ list len(data) #4 #เพิ่มค่าเข้า list ในตำแหน่งท้ายสุด data.append(5) #[1, 2, 3, 4, 5] #เพิ่มข้อมูลใส่ list ในตำแหน่งที่ระบุ data.insert(0, 100) #[100, 1, 2, 3, 4, 5] data.insert(2, 200) #[100, 1, 200, 2, 3, 4, 5] #ขึ้นข้อมูลออกจาก list (ดึงออกมาจากข้อมูลจะถูกลบทิ้งออกไปจาก list เลยนะ) x = data.pop(0) #x จะมีค่าเป็น 100 ส่วน data จะเหลือแค่ [1, 200, 2, 3, 4, 5] y = data.pop() #ถ้าไม่ระบบตำแหน่ง จะหมายถึงตำแหน่งท้ายสุด #y จะมีค่าเป็น 5 สวน data จะเหลือแค่ [1, 200, 2, 3, 4] list ใน Python มีฟีเจอร์น่าสนใจอีกตัวคือ \u0026ldquo;sub-list\u0026rdquo; หรือการตัด list ออกมาเป็นช่วง จะใช้เครื่องหมาย [x:y] โดย x แทนตำแหน่งเริ่มตัด และ y แทนตำแหน่งหยุดตัด\ndata = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;] data[1:3] #[\u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] data[2:5] #[\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;] data[:3] #[\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] data[2:] #[\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;] data[:] #[\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;] ถ้าไม่กำหนด x จะหมายถึงเริ่มตั้งแต่ต้น list ส่วนถ้าไม่ได้กำหนด y หมายถึงเอาจนถึงตำแหน่งสุดท้ายของ list เลย\nในการใช้ list ต้องระวังไว้อย่างนึงคือ list เป็นตัวแปรแบบ reference-type หรือเป็น pointer นั่นเอง การสั่ง = อาจจะมีปัญหาในบางครั้งได้ เช่น\na = [1, 2, 3] b = a b[0] = 100 #b จะมีค่าเป็น [100, 2, 3] #แต่เนื่องจากส่งค่ากับเป็นแบบ ref ดังนั้นค่าของ a เลยโดยด้วยเป็น [100, 2, 3] เช่นกัน #ส่วนวิธีแก้จะใช้การ casting หรือการ sub-list ได้ทั้ง 2 วิธีแบบนี้ b = a[:] #หรือ b = list(a) tuple มันคือ list ที่ไม่สามารถแก้ไขข้อมูลได้ (รวมถึงไม่สามารถ เพิ่ม/ลด data ได้ด้วย) พูดง่ายๆ มันคือ const list หรือ final list นั่นเอง วิธีการสร้างจะคล้ายๆ กับ list แต่เปลี่ยนเครื่องหมาย [ ] เป็น ( ) เท่านั้นเอง\ndata = (10, 20, 30, 40) print(data[0]) #10 dictionary หรือชนิดตัวแปรประเภท dict เป็นการเป็นข้อมูลแบบ key-value เทียบได้กับ HashMap ในภาษา Java หรือ โครงสร้างข้อมูลยอดฮิตแบบ JSON\nสำหรับคนที่ไม่รู้จัก dict จะคล้ายๆ กับ list ที่ต้องกำหนดชื่อของ index ด้วยตัวเอง เป็นชื่ออะไรก็ได้ (ปกติแล้วการอ้างอิงข้อมูลใน list เราจะใช้ตัวเลข index เริ่มจาก 0,1,2,\u0026hellip; ไปเรื่อยๆ) โดยสัญลักษณ์ของ dict จะใช้ {key:val}\ndata = { \u0026#34;name\u0026#34;: \u0026#34;Momo\u0026#34;, \u0026#34;score\u0026#34;: 100, \u0026#34;pass\u0026#34;: true } set ตัวนี้จะใช้หลักการตามวิชาคณิตศาสตร์เลย คือสมาชิกของ set จะมีแค่ 1 ตัวต่อ 1 ค่า หรือพูดง่ายๆ คือจะมี value ไม่ซ้ำกันเลย (unique list นั่นเอง) สัญลักษณ์ของ set จะใช้คล้ายๆ กับ dict คือ { } ดังนั้นระวังใช้สับสน\ndata = {10, 20, 30, 10, 20, 40} #data จะเหลือแค่ {10, 20, 30, 40} เพราะ 10 กับ 20 ซ้ำนั่นเอง contains ในการเช็กว่ามี value ตัวนี้ใน data structure นั้นๆ หรือไม่เราจะใช้คำสั่ง in ในการเช็กนะ แบบนี้\ndata = [10, 20, 30, 40] 10 in data #True data = (10, 20, 30, 40) 10 in data #True data = {\u0026#34;A\u0026#34;: 10, \u0026#34;B\u0026#34;: 20, \u0026#34;C\u0026#34;: 30} 10 in data #False \u0026#34;A\u0026#34; in data #True สังเกตอย่างนึงคือการเช็ก dict นั้นจะเช็กด้วย key ไม่ใช่ value แบบตัวอื่นๆ\nString ประโยคใน Python จะใช้ได้ทั้ง \u0026quot; (double quote) และ ' (single quote) ซึ่งใช้ตัวไหนก็ได้ มีค่าเท่ากันเลย \u0026hellip; แต่มีตัวพิเศษเรียกว่า triple quote เขียนแบบนี้ \u0026quot;\u0026quot;\u0026quot; (มันคือการเขียน double quote ต่อกัน 3 ตัว) ซึ่งวิธีการใช้ \u0026quot;\u0026rdquo;\u0026rdquo; จะต่างกับ \u0026quot; และ ' คือเราสามารถเขียน newline (ขึ้นบรรทัดใหม่) ได้ด้วย\nname = \u0026#34;Momo\u0026#34; website = \u0026#39;TAMEMO.com\u0026#39; content = \u0026#34;\u0026#34;\u0026#34; this is a book. not a pen \u0026#34;\u0026#34;\u0026#34; สำหรับการต่อ string หรือ concat จะใช้ + แบบปกติ แต่สิ่งที่ต้องระวังคือ string ในภาษา Python ไม่สามารถ + กับข้อมูลชนิดอื่นได้ เช่น str + int (พูดง่ายๆ คือมันไม่มี auto toString นั่นเอง) จะต้องแปลงข้อมูลชนิดอื่นให้เป็น str ซะก่อน\nname = \u0026#34;Momo\u0026#34; print(\u0026#34;hello \u0026#34; + name) x = 10 print(\u0026#34;answer is \u0026#34; + str(x)) และใน Python นั้น string สามารถเอามา * ได้ด้วยนะ แบบนี้\n\u0026#34;A\u0026#34; * 10 #AAAAAAAAAA และคุณสมบัติอีกอย่างคือ string นั้นจะทำตัวเหมือนกับ list ของ character ดังนั้น list ทำอะไรได้ string ก็ทำแบบนั้นได้แหละ\nsentence = \u0026#34;www.TAMEMO.com\u0026#34; \u0026#34;\u0026#34;\u0026#34; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 w w w . T A M E M O . c o m \u0026#34;\u0026#34;\u0026#34; sentence[0] #w sentence[4] #T sentence[-1] #m ถ้าใช้ค่า - จะหมายถึง index จากฝั่งท้ายแถว sentence[4:10] #TAMEMO len(sentence) #14 \u0026#34;TA\u0026#34; in sentence #True string format คล้ายๆ กับ printf ในภาษา C คือเราสามารถ string format ใน Python ได้เช่นกันโดนใช้ % ในการระบุตัวแปรตามหลัง\n %d: แสดงค่าจำนวนเต็ม %f: แสดงค่าจุดทศนิยม %s: แสดงผล string  x = 123 \u0026#34;x value is %d\u0026#34; % x #x value is 123 x = 1 y = 2 \u0026#34;%d+ %d= %d\u0026#34; % (x, y, x+y) #1 + 2 = 3 name = \u0026#34;Momo\u0026#34; \u0026#34;welcome, %s\u0026#34; % name pi = 3.1416 \u0026#34;PI is %.2f\u0026#34; % pi #PI is 3.14 ในกรณีที่มีตัวแปรหลายตัวจะต้องครอบตัวแปรทั้งหมดด้วย ( ) หรือ tuple\nหรืออีกวิธีนึงคือใช้ .format() แทน\nx = 10 y = 20 \u0026#34;{0} and {1} and {0}\u0026#34;.format(x, y) #10 and 20 and 10 x = 12.345 y = 6.7890 \u0026#34;{0:.2} {1:.1}\u0026#34;.format(x, y) #12.34 6.7 และใช้ upper() กับ lower() ในการทำให้ตัวอักษรเป็นตัวใหญ่ทั้งหมด และตัวเล็กทั้งหมด\n\u0026#34;TAmemo\u0026#34;.upper() #TAMEMO \u0026#34;TAmemo\u0026#34;.lower() #tamemo Control Flow ตัวควบคุมการทำงานของโปรแกรม ส่วนนี้จะคล้ายๆ กับภาษาอื่นๆ คือมี if-else while for ให้ใช้ (แต่ไม่มี do..while นะ)\nแต่สิ่งที่แตกต่างจากภาษาอื่นๆ แบบชัดๆ คือ \u0026ldquo;code block\u0026rdquo; ของ Python นั้นจะไม่ใช่การเขียนด้วย { } หรือ BEGIN-END แบบภาษาอื่นแต่ใช้ indent ในการแบ่ง code block แทน\nสำหรับ indent คืออะไร มาดูกันในตัวอย่างแรกกับ if\nif เอาไว้เช็กว่าถ้า condition เป็นจริง จะทำงาน statement ในคำสั่ง if แบบนี้\nif x \u0026gt; 10: print(\u0026#34;x more than ten\u0026#34;) สังเกตว่าในภาษา Python จะไม่มีการกำหนด { } ครอบส่วนที่เป็น block ของ if แต่จะใช้การ \u0026ldquo;space เว้นวรรค (มาตราฐานคือ 4 space)\u0026rdquo; หรือการใช้ \u0026ldquo;tab แท็บ 1 ครั้ง\u0026rdquo; แทน\nstatement ของ if ทั้งหมดจะถูกบังคับให้ indent ออกไป 1 ครั้งจนกว่า indent จะกลับมาอยู่ในระดับเดิม ถึงจะถือว่าจบ if แล้ว\nif x \u0026gt; 10: print(\u0026#34;x more than ten\u0026#34;) print(\u0026#34;นี่ก็ยังถือว่าอยู่ใน if อยู่ล่ะ\u0026#34;) print(\u0026#34;ถ้าอันนี้คือออกจาก if แล้ว\u0026#34;) ส่วนถ้าจะเขียน nested-if (if ซ้อน if) ใน if ชั้นที่ 2 ก็จะต้อง indent เข้าไปอีกครั้งนึงแบบนี้\nif x \u0026gt; 10: print(\u0026#34;x more than ten\u0026#34;) if x % 2 == 0: print(\u0026#34;and also is even\u0026#34;) ถ้าเทียบกับภาษาตระกูล C ก็คือ\nif(x \u0026gt; 10){ print(\u0026#34;x more than ten\u0026#34;) if( x % 2 == 0){ print(\u0026#34;and also is even\u0026#34;) } } สำหรับ logical operator \u0026hellip; เวลาเรามีหลาย condition เราสามารถเชื่อมประโยคได้ด้วยการใช้ and or และ not ซึ่งในภาษา Python จะใช้ตรงๆ เลยคือใช้ and or not (ซึ่งเทียบได้กับ \u0026amp;\u0026amp; || ! ในภาษาตระกูล C)\nelse เป็นส่วนเสริมของ if เอาไว้เช็กในกรณี condition เป็น False จะลงไปทำ statement ใน else แทน \u0026hellip; แน่นอนว่าใช้การแบ่ง block ด้วย indent เหมือนเดิมแบบนี้\nif x \u0026gt; 10: print(\u0026#34;x more than ten\u0026#34;) else: print(\u0026#34;not more than ten\u0026#34;) และเนื่องจาก Python แบ่ง block ด้วย indent ดังนั้นถ้าเราเขียน nested if-else หลายๆ ชั้นมันจะออกมาเป็นแบบนี้\nif x \u0026gt; 10: print(\u0026#34;...\u0026#34;) else: if y == 5: print(\u0026#34;...\u0026#34;) else: if not z: print(\u0026#34;...\u0026#34;) else: print(\u0026#34;...\u0026#34;) แน่นอนว่ามันใช้ได้นะ แต่มันก็ดูเขียนยาก แถมอ่านยากอีกตั้งหาด เขาก็เลยมีคำสั่ง elif มาให้ใช้\nif x \u0026gt; 10: print(\u0026#34;...\u0026#34;) elif y == 5: print(\u0026#34;...\u0026#34;) elif not z: print(\u0026#34;...\u0026#34;) else: print(\u0026#34;...\u0026#34;) while อันนี้เป็น loop แบบเบสิกมากๆ เลย วิธีการใช้จะคล้ายๆ if เป็นจะวนทำซ้ำไปจนกว่า condition จะเป็น False\ni = 1 while i \u0026lt; 5: print(i) i += 1 #1 2 3 4 การแบ่ง block ของ while ก็เหมือนกับ if ละนะ คือต้องใช้ indent ในการบอกว่าส่วนใหญ่ยังเป็น statement ของ while อยู่\nfor ปกติแล้วถ้าใครเคยเขียนโปรแกรมในภาษาอื่นๆ มาก่อน การเขียน loop ประเภท for จะออกมาหน้าตาประมาณนี้\nvar data = [10, 20, 30, 40]; for(i = 0; i\u0026lt;data.length; i++){ print( data[i] ); } //10 20 30 40 นั่นคือ for ถูกสร้างขึ้นมาเพื่อจัดรูปแบบการเขียนลูปให้เป็นระเบียบขึ้นจากการใช้ while นั่นเอง แต่สำหรับ Python แล้วเราจะไม่สามารถเขียน for แบบนี้ได้อีกต่อไป แต่จะเป็นแบบนี้\ndata = [10, 20, 30, 40] for x in data: print( x ) # 10 20 30 40 for ใน Python นั้นจะใช้สำหรับการวนข้อมูลประเภท list, tuple, dict เป็นหลัก โดยจะทำการวนลูปตั้งแต่ตัวแรกจนถึงข้อมูลตัวสุดท้ายให้ ซึ่งเราไม่ต้องสร้าง counter หรือตัวแปรเอามานับรอบ (เช่นในตัวอย่างนี้คือตัวแปร i) แต่ให้สร้างตัวแปรมาหนึ่งตัว เป็นตัวแทนของ data[i] มาแทน (ในตัวอย่างคือตัวแปร x \u0026hellip;แต่ก็สร้างเป็นชื่ออะไรก็ได้นะ) ที่เหลือ Python จะจัดการให้ทั้งหมด\nดูๆ ไปแล้วมันก็เหมือนกับ foreach สินะ? \u0026hellip; ใช่แล้ว! for ใน Python ก็คือ foreach ในภาษาอื่นๆ นั่นเอง (หรือก็คือ for-in for-of นั่นแหละ แล้วแต่ภาษาไหนจะเรียกอะไร)\nแต่ถ้าเราต้องการจะใช้ for ในการวนลูปนับเลขเหมือนเดิมก็สามารถทำได้โดยการใช้ range() เข้ามาช่วย ซึ่งเจ้าฟังก์ชัน range ตัวนี้จะเป็นฟังก์ชันสำหรับสร้าง list ของตัวเลขขนาดตามที่กำหนดลงไปขึ้นมา แบบนี้\nrange(10) #0 1 2 3 4 5 6 7 8 9 (ใน python2 จะให้ค่าออกมาเป็น list เลย) list(range(10)) #0 1 2 3 4 5 6 7 8 9 แต่ถ้าเป็น python3 จะให้ค่าออกมาเป็น generator ถ้าอยากให้มันเป็น list จะต้อง cast มันอีกทีนึง #ซึ่งคำสั่ง range ใน python3 จะเทียบได้กับ xrange ใน python2 นั่นเอง range(5,10) #5 6 7 8 9 หรือกำหนดค่าเริ่มต้นให้มันก็ได้ พอมันให้ค่าออกมาเป็น list ของตัวเลข ทำให้เราเอาไปวนลูปได้ แบบนี้ for i in range(10): print(i) #0 1 2 3 4 5 6 7 8 9 for i in list(range(10)): print(i) #0 1 2 3 4 5 6 7 8 9 ให้ค่าออกมาแบบเดียวกันเลย แต่ใช้วิธีแรกอีกกว่านะ data = [10, 20, 30, 40] for i in range(len(data)): print( data[i] ) #10 20 30 40 หรือจะใช้คำสั่ง enumerate ในการวนลูปเพื่อให้แต่ละรอบในการวน จะได้ทั้ง item และ index\ndata = [10, 20, 30, 40] for i,item in enumerate(data): print(i, item) #(0, 10) #(1, 20) #(2, 30) #(3, 40) ส่วนคำสั่ง break และ continue ที่เอาไว้ควบคุมการหยุด/ข้ามรอบของลูปก็ยังใช้ได้ปกติไม่มีปัญหาอะไรนะ\nส่วนการวนลูป dict นั้น iterator ที่ได้มาจะเป็นส่วนของ key นะ ไม่ใช่ value\ndata = { \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2, \u0026#34;C\u0026#34;: 3 } for k in data: print(k) #A B C for k in data: print(data[k]) #1 2 3 pass ในภาษาอื่นๆ เราสร้าง block ได้ด้วยการใช้พวก { } แต่พอ Python ใช้ indent แทน บางครั้งมันก็จะมีปัญหา เช่น\nif( x \u0026gt; 10){ //do nothing~ } else{ print(\u0026#34;not more than ten\u0026#34;) } คือเกิดกรณีที่ภายใน block ไม่มี statement อะไรเลย ถ้าเอาไปเขียนเป็น Python ก็จะออกมาแบบนี้\nif x \u0026gt; 10: else: print(\u0026#34;not more than ten\u0026#34;) ซึ่งการเขียนแบบนี้จะผิดทันที! เพราะภายใน if ไม่มี statement อะไรอยู่เลย (Python ไม่ให้ล่ะ อย่างน้อยต้องมี 1 indent)\nวิธีแก้คือเติมคำสั่ง pass ลงไปแทน\nif x \u0026gt; 10: pass else: print(\u0026#34;not more than ten\u0026#34;) Function การประกาศใช้ฟังก์ชันใน Python จะทำผ่านคีย์เวิร์ด def และส่วน body ของฟังก์ชันจะต้องแบ่งด้วย code block แบบ indent เช่นกัน\ndef hi(): print(\u0026#34;hello, yo yo!\u0026#34;) ซึ่งการใช้ function นั้นไม่จำเป็นต้องระบุ return-type ลงไป คือถ้าอยากจะ return อะไรก็รีเทิร์นได้เลย นอกจากนี้ยังสามารถรับ parameter แบบภาษาทั่วไปได้เช่นกัน\ndef say_hello(name): print(\u0026#34;hello, \u0026#34; + name) say_hello(\u0026#34;Momo\u0026#34;) #hello, Momo def plus(a, b): return a + b print(plus(10, 20)) #30 และก็เหมือนกับภาษาระดับสูงใหม่ๆ ทั่วไปคือเราสามารถใส่ default parameter ได้\ndef f(x = 1): print(x) f() #1 f(2) #2 จริงๆ ภาษา Python ยังมีอะไรที่น่ารู้อีกเยอะ เช่นเรื่องของ list, dict และ การสร้าง class หรือการทำ module แต่เนื่องจากถ้าเขียนต่อไปเนื้อหาจะยาวเกินไป ไว้ต่อในบล๊อกหน้าละกันนะ\n Source : .\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/short_introduction/basic-to-beyond/",
	"title": "Basics to Beyond",
	"tags": [],
	"description": "",
	"content": " A tutorial walkthrough of Python Pandas Library\n For those of you who are getting started with Machine learning, just like me, would have come across Pandas, the data analytics library. In the rush to understand the gimmicks of ML, we often fail to notice the importance of this library. But soon you will hit a roadblock where you would need to play with your data, clean and perform data transformations before feeding it into your ML model.\nWhy do we need this blog when there are already a lot of documentation and tutorials? Pandas, unlike most python libraries, has a steep learning curve. The reason is that you need to understand your data well in order to apply the functions appropriately. Learning Pandas syntactically is not going to get you anywhere. Another problem with Pandas is that there is that there is more than one way to do things. Also, when I started with Pandas it’s extensive and elaborate documentation was overwhelming. I checked out the cheatsheets and that scared me even more.\nIn this blog, I am going to take you through Pandas functionalities by cracking specific use cases that you would need to achieve with a given data.\nSetup and Installation Before we move on with the code for understanding the features of Pandas, let’s get Pandas installed in your system. I advise you to create a virtual environment and install Pandas inside the virtualenv.\nCreate virtualenv virtualenv -p python3 venv source venv/bin/activate Install Pandas pip install pandas Jupyter Notebook If you are learning Pandas, I would advise you to dive in and use a jupyter notebook for the same. The visualization of data in jupyter notebooks makes it easier to understand what is going on at each step.\npip install jupyter jupyter notebook Jupyter by default runs in your system-wide installation of python. In order to run it in your virtualenv follow the link and create a user level kernel https://anbasile.github.io/programming/2017/06/25/jupyter-venv/\nSample Data I created a simple purchase order data. It comprises of sales data of each salesperson of a company over countries and their branches at different regions in each country. Here is a link to the spreadsheet for you to download.\nLoad data into Pandas With Pandas, we can load data from different sources. Few of them are loading from CSV or a remote URL or from a database. The loaded data is stored in a Pandas data structure called DataFrame. DataFrame’s are usually refered by the variable name df . So, anytime you see df from here on you should be associating it with Dataframe.\nFrom CSV File import pandas df = pandas.read_csv(\u0026#34;path_to_csv\u0026#34;) From Remote URL You can pass a remote URL to the CSV file in read_csv.\nimport pandas df = pandas.read_csv(\u0026#34;remote/url/path/pointing/to/csv\u0026#34;) From DB In order to read from Database, read the data from DB into a python list and use DataFrame() to create one\ndb = # Create DB connection object  cur = db.cursor() cur.execute(\u0026#34;SELECT * FROM \u0026lt;TABLE\u0026gt;\u0026#34;) df = pd.DataFrame(cur.fetchall()) Each of the above snippets reads data from a source and loads it into Pandas’ internal data structure called DataFrame\nUnderstanding Data Now that we have the Dataframe ready let’s go through it and understand what’s inside it\n# 1. shows you a gist of the data df.head() # 2. Some statistical information about your data df.describe() # 3. List of columns headers df.columns.values Pick \u0026amp; Choose your Data Now that we have loaded our data into a DataFrame and understood its structure, let’s pick and choose and perform visualizations on the data. When it comes to selecting your data, you can do it with both Indexesor based on certain conditions. In this section, let’s go through each one of these methods.\nIndexes Indexes are labels used to refer to your data. These labels are usually your column headers. For eg., Country, Region, Quantity Etc.,\nSelecting Columns # 1. Create a list of columns to be selected columns_to_be_selected = [\u0026#34;Total\u0026#34;, \u0026#34;Quantity\u0026#34;, \u0026#34;Country\u0026#34;] # 2. Use it as an index to the DataFrame df[columns_to_be_selected] # 3. Using loc method df.loc[columns_to_be_selected] Selecting Rows Unlike the columns, our current DataFrame does not have a label which we can use to refer the row data. But like arrays, DataFrame provides numerical indexing(0, 1, 2…) by default.\n# 1. using numerical indexes - iloc df.iloc[0:3, :] # 2. using labels as index - loc row_index_to_select = [0, 1, 4, 5] df.loc[row_index_to_select] Filtering Rows Now, in a real-time scenario, you would most probably not want to select rows based on an index. An actual real-life requirement would be to filter out the rows that satisfy a certain condition. With respect to our dataset, we can filter by any of the following conditions\n1. Total sales \u0026gt; 200000 df[df[\u0026#34;Total\u0026#34;] \u0026gt; 200000] 2. Total sales \u0026gt; 200000 and in UK df[(df[\u0026#34;Total\u0026#34;] \u0026gt; 200000) \u0026amp; (df[\u0026#34;Country\u0026#34;] == \u0026#34;UK\u0026#34;)] Playing With Dates Most of the times when dealing with date fields we don’t use them as it is. Pandas make it really easy for you to project Date/Month/Year from it and perform operations on top of it\nIn our sample dataset, the Date_of_purchase is of type string, hence the first step would be to convert them to the DateTime type.\n\u0026gt;\u0026gt;\u0026gt; type(df[\u0026#39;Date of Purchase\u0026#39;].iloc[0]) str Converting Column to DateTime Object \u0026gt;\u0026gt;\u0026gt; df[\u0026#39;Date of Purchase\u0026#39;] = pd.to_datetime(df[\u0026#39;Date of Purchase\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; type(df[\u0026#39;Date of Purchase\u0026#39;].iloc[0]) pandas._libs.tslibs.timestamps.Timestamp Extracting Date, Month \u0026amp; Year\ndf[\u0026#39;Date of Purchase\u0026#39;].dt.date # 11-09-2018 df[\u0026#39;Date of Purchase\u0026#39;].dt.day # 11 df[\u0026#39;Date of Purchase\u0026#39;].dt.month # 09 df[\u0026#39;Date of Purchase\u0026#39;].dt.year # 2018 Grouping Statistical operations You can perform statistical operations such as min, max, mean etc., over one or more columns of a Dataframe.\ndf[\u0026#34;Total\u0026#34;].sum() df[[\u0026#34;Total\u0026#34;, \u0026#34;Quantity\u0026#34;]].mean() df[[\u0026#34;Total\u0026#34;, \u0026#34;Quantity\u0026#34;]].min() df[[\u0026#34;Total\u0026#34;, \u0026#34;Quantity\u0026#34;]].max() df[[\u0026#34;Total\u0026#34;, \u0026#34;Quantity\u0026#34;]].median() df[[\u0026#34;Total\u0026#34;, \u0026#34;Quantity\u0026#34;]].mode() Now in a real-world application, the raw use of these statistical functions are rare, often you might want to group data based on specific parameters and derive a gist of the data.\nLet’s look at an example where we look at the country-wise, country \u0026amp; Region-wise sales.\n# 1. Country wise sales and Quantity df.groupby(\u0026#34;Country\u0026#34;).sum() # 2. Quantity of sales over each country \u0026amp; Region df.groupby([\u0026#34;Country\u0026#34;, \u0026#34;Region\u0026#34;])[\u0026#34;Quantity\u0026#34;].sum() # 3. More than one aggregation df.groupby([\u0026#34;Country\u0026#34;, \u0026#34;Region\u0026#34;]).agg( {\u0026#39;Total\u0026#39;:[\u0026#39;sum\u0026#39;, \u0026#39;max\u0026#39;], \u0026#39;Quantity\u0026#39;:\u0026#39;mean\u0026#39;}) Pivot Table Pivot Table is an advanced version of groupby, where you can stack dimensions over both rows and columns. i.e., as the data grows the groupby above is going to grow in length and will become hard to derive insights, hence a well-defined way to look at it would be Pivot tables\nimport numpy as np df.pivot_table(index=[\u0026#34;Country\u0026#34;], columns=[\u0026#34;Region\u0026#34;], values=[\u0026#34;Quantity\u0026#34;], aggfunc=[np.sum]) Another advantage of the Pivot Table is that you can add as many dimensions and functions you want. It also calculates a grand total value for you\nimport numpy as np df.pivot_table(index=[\u0026#34;Country\u0026#34;], columns=[\u0026#34;Region\u0026#34;,\u0026#34;Requester\u0026#34;], values=[\u0026#34;Quantity\u0026#34;], aggfunc=[np.sum], margins=True, margins_name=\u0026#34;Grand Total\u0026#34;) Okay, that was a lot of information in 5 minutes. Take some time in trying out the above exercises. In the next blog, I will walk you through some more deeper concepts and magical visualizations that you can create with Pandas.\nEvery time you start learning Pandas, there is a good chance that you may get lost in the Pandas jargons like index, functions, numpy etc., But don’t let that get to you. What you really have to understand is that Pandas is a tool to visualize and get a deeper understanding of your data.\nWith that mindset take a sample dataset from your spreadsheet and try deriving some insights out of it. Share what you learn. Here is the link to my jupyter notebook for you to get started.\nDid the blog nudge a bit to give Pandas another chance?\nHold the “claps” icon and give a shout out to me on twitter. Follow to stay tuned on future blogs\n Reference : https://hackernoon.com\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/dictionary/dict_beginner/",
	"title": "Beginners Tutorial",
	"tags": [],
	"description": "Python Dictionary(Dict) Beginners Tutorial",
	"content": "Python Dictionary(Dict): Update, Cmp, Len, Sort, Copy, Items, str Example Dictionaries are another example of a data structure. A dictionary is used to map or associate things you want to store the keys you need to get them. A dictionary in Python is just like a dictionary in the real world. Python Dictionary are defined into two elements Keys and Values.\n Keys will be a single element Values can be a list or list within a list, numbers, etc.  In this tutorial, we are going to learn,\n Python Dictionary Methods Copying dictionary Updating Dictionary Delete Keys from the dictionary Dictionary items() Method Sorting the Dictionary Python Dictionary in-built Functions Dictionary len() Method Variable Types Python List cmp() Method Dictionary Str(dict)  Syntax for Python Dictionary:\nDict = { \u0026#39; Tim\u0026#39;: 18, xyz,.. } Dictionary is listed in curly brackets, inside these curly brackets, keys and values are declared. Each key is separated from its value by a colon (:) while each element is separated by commas.\nProperties of Dictionary Keys\nThere are two important points while using dictionary keys\n More than one entry per key is not allowed ( no duplicate key is allowed) The values in the dictionary can be of any type while the keys must be immutable like numbers, tuples or strings. Dictionary keys are case sensitive- Same key name but with the different case are treated as different keys in Python dictionaries.  Python 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint (Dict[\u0026#39;Tiffany\u0026#39;]) Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint((Dict[\u0026#39;Tiffany\u0026#39;]))  In code, we have dictionary name \u0026ldquo;Dict\u0026rdquo; We declared the name and age of the person in the dictionary, where name is \u0026ldquo;Keys\u0026rdquo; and age is the\u0026quot;value\u0026rdquo; Now run the code It retrieves the age of tiffany from the dictionary.  Python Dictionary Methods Copying dictionary You can also copy the entire dictionary to new dictionary. For example, here we have copied our original dictionary to new dictionary name \u0026ldquo;Boys\u0026rdquo; and \u0026ldquo;Girls\u0026rdquo;.\nPython 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tBoys = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Robert\u0026#39;:25} Girls = {\u0026#39;Tiffany\u0026#39;:22}\tstudentX=Boys.copy() studentY=Girls.copy() print studentX print studentY Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tBoys = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Robert\u0026#39;:25} Girls = {\u0026#39;Tiffany\u0026#39;:22}\tstudentX=Boys.copy() studentY=Girls.copy() print(studentX) print(studentY)  We have the original dictionary (Dict) with the name and age of the boys and girls together But we want boys list separate from girls list, so we defined the element of boys and girls in a separate dictionary name \u0026ldquo;Boys\u0026rdquo; and \u0026ldquo;Girls.\u0026rdquo; Now again we have created new dictionary name \u0026ldquo;studentX\u0026rdquo; and \u0026ldquo;studentY\u0026rdquo;, where all the keys and values of boy dictionary are copied into studentX, and the girls will be copied in studentY So now you don\u0026rsquo;t have to look into the whole list in main dictionary( Dict) to check who is boy and who is girl, you just have to print studentX if you want boys list and StudentY if you want girls list So, when you run the studentX and studentY dictionary, it will give all the element present in the dictionary of \u0026ldquo;boys\u0026rdquo; and \u0026ldquo;girls\u0026rdquo; separately  Updating Dictionary You can also update a dictionary by adding a new entry or a key-value pair to an existing entry or by deleting an existing entry. Here in the example we will add another name \u0026ldquo;Sarah\u0026rdquo; to our existing dictionary.\nPython 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tDict.update({\u0026#34;Sarah\u0026#34;:9}) print Dict Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tDict.update({\u0026#34;Sarah\u0026#34;:9}) print(Dict)  Our existing dictionary \u0026ldquo;Dict\u0026rdquo; does not have the name \u0026ldquo;Sarah.\u0026rdquo; We use the method Dict.update to add Sarah to our existing dictionary Now run the code, it adds Sarah to our existing dictionary  Delete Keys from the dictionary Python dictionary gives you the liberty to delete any element from the dictionary list. Suppose you don\u0026rsquo;t want the name Charlie in the list, so you can delete the key element by following code.\nPython 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tdel Dict [\u0026#39;Charlie\u0026#39;] print Dict Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tdel Dict [\u0026#39;Charlie\u0026#39;] print(Dict) When you run this code, it should print the dictionary list without Charlie.\n We used the code del Dict When code executed, it has deleted the Charlie from the main dictionary  Dictionary items() Method The items() method returns a list of tuple pairs (Keys, Value) in the dictionary.\nPython 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint \u0026#34;Students Name: %s\u0026#34; % Dict.items() Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint(\u0026#34;Students Name: %s\u0026#34; % list(Dict.items()))  We use the code items() method for our Dict. When code was executed, it returns a list of items ( keys and values) from the dictionary  Check if a given key already exists in a dictionary\nFor a given list, you can also check whether our child dictionary exists in a main dictionary or not. Here we have two sub-dictionaries \u0026ldquo;Boys\u0026rdquo; and \u0026ldquo;Girls\u0026rdquo;, now we want to check whether our dictionary Boys exist in our main \u0026ldquo;Dict\u0026rdquo; or not. For that, we use the forloop method with else if method.\nPython 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25} Boys = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Robert\u0026#39;:25} Girls = {\u0026#39;Tiffany\u0026#39;:22} for key in Dict.keys(): if key in Boys.keys(): print True else: print False Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25} Boys = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Robert\u0026#39;:25} Girls = {\u0026#39;Tiffany\u0026#39;:22} for key in list(Dict.keys()): if key in list(Boys.keys()): print(True) else: print(False)  The forloop in code checks each key in the main dictionary for Boys keys If it exists in the main dictionary, it should print true or else it should print false When you execute the code, it will print \u0026ldquo;True\u0026rdquo; for three times, as we got three elements in our \u0026ldquo;Boys\u0026rdquo; dictionary So it indicates that the \u0026ldquo;Boys\u0026rdquo; exist in our main dictionary (Dict)  Sorting the Dictionary In the dictionary, you can also sort the elements. For example, if we want to print the name of the elements of our dictionary alphabetically we have to use the forloop. It will sort each element of dictionary accordingly.\nPython 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25} Boys = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Robert\u0026#39;:25} Girls = {\u0026#39;Tiffany\u0026#39;:22} Students = Dict.keys() Students.sort() for S in Students: print\u0026#34;:\u0026#34;.join((S,str(Dict[S]))) Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25} Boys = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Robert\u0026#39;:25} Girls = {\u0026#39;Tiffany\u0026#39;:22} Students = list(Dict.keys()) Students.sort() for S in Students: print(\u0026#34;:\u0026#34;.join((S,str(Dict[S]))))  We declared the variable students for our dictionary \u0026ldquo;Dict.\u0026rdquo; Then we use the code Students.sort, which will sort the element inside our dictionary But to sort each element in dictionary, we run the forloop by declaring variable S Now, when we execute the code the forloop will call each element from the dictionary, and it will print the string and value in an order  Python Dictionary in-built Functions Dictionary len() Method The len() function gives the number of pairs in the dictionary.\nFor example,\nPython 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint \u0026#34;Length : %d\u0026#34; % len (Dict) Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint(\u0026#34;Length : %d\u0026#34; % len (Dict)) When len (Dict) function is executed it gives the output at \u0026ldquo;4\u0026rdquo; as there are four elements in our dictionary\nVariable Types Python does not require to explicitly declare the reserve memory space; it happens automatically. The assign values to variable \u0026ldquo;=\u0026rdquo; equal sign are used. The code to determine the variable type is \u0026quot; %type (Dict).\u0026rdquo;\nPython 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint \u0026#34;variable Type: %s\u0026#34; %type (Dict) Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint(\u0026#34;variable Type: %s\u0026#34; %type (Dict))  Use the code %type to know the variable type When code was executed, it tells a variable type is a dictionary  Python List cmp() Method The compare method cmp() is used in Python to compare values and keys of two dictionaries. If method returns 0 if both dictionaries are equal, 1 if dic1 \u0026gt; dict2 and -1 if dict1 \u0026lt; dict2.\nPython 2 Example\nBoys = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Robert\u0026#39;:25} Girls = {\u0026#39;Tiffany\u0026#39;:22}\tprint cmp(Girls, Boys) Python 3 Example\ncmp is not supported in Python 3\n We have two dictionary name \u0026ldquo;Boys\u0026rdquo; and \u0026ldquo;Girls.\u0026rdquo; Which ever you declare first in code \u0026ldquo;cmp(Girls, Boys)\u0026rdquo; will be considered as dictionary 1. In our case, we declared \u0026ldquo;Girls\u0026rdquo; first, so it will be considered as dictionary 1 and boys as dictionary 2 When code is executed it prints out -1, It indicates that our dictionary 1 is less than dictionary 2.  Dictionary Str(dict) With Str() method, you can make a dictionary into a printable string format.\nPython 2 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint \u0026#34;printable string:%s\u0026#34; % str (Dict) Python 3 Example\nDict = {\u0026#39;Tim\u0026#39;: 18,\u0026#39;Charlie\u0026#39;:12,\u0026#39;Tiffany\u0026#39;:22,\u0026#39;Robert\u0026#39;:25}\tprint(\u0026#34;printable string:%s\u0026#34; % str (Dict))  Use the code % str (Dict) It will return the dictionary elements into a printable string format  Here is the list of all Dictionary Methods\n   Method Description Syntax     copy() Copy the entire dictionary to new dictionary dict.copy()   update() Update a dictionary by adding a new entry or a key-value pair to an existing entry or by deleting an existing entry. Dict.update([other])   items() Returns a list of tuple pairs (Keys, Value) in the dictionary. dictionary.items()   sort() You can sort the elements dictionary.sort()   len() Gives the number of pairs in the dictionary. len(dict)   cmp() Compare values and keys of two dictionaries cmp(dict1, dict2)   Str() Make a dictionary into a printable string format Str(dict)    Summary: Dictionaries in a programming language is a type of data-structure used to store information connected in someway. Python Dictionary are defined into two elements Keys and Values. Dictionaries do not store their information in any particular order, so you may not get your information back in the same order you entered it.\n Keys will be a single element Values can be a list or list within a list, numbers, etc. More than one entry per key is not allowed ( no duplicate key is allowed) The values in the dictionary can be of any type while the keys must be immutable like numbers, tuples or strings. Dictionary keys are case sensitive- Same key name but with the different case are treated as different keys in Python dictionaries.   Source : .\n   "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/short_introduction/cheatsheet-pandas/",
	"title": "Cheatsheet Pandas",
	"tags": [],
	"description": "",
	"content": "Cheatsheet วิธีใช้ และเทคนิคใน Pandas (Python) ฉบับสมบูรณ์\nPandas ถือเป็นเครื่องมือหลักในการทำ Data Wrangling บน Python และสามารถนำไปใช้ประโยชน์คู่กับ Package อื่น เช่น เอาไปเตรียมข้อมูลก่อนทำ Model ใน SKLearn ได้ด้วย\nวันนี้แอดมินเลยเอาคำสั่ง Pandas ที่ใช้บ่อย ๆ มารวบรวมให้ rename หาง่าย ๆ ตั้งแต่อ่านไฟล์ข้อมูล เลือกข้อมูล แก้ไขข้อมูล ไปจนถึงเซฟไฟล์ข้อมูลเพื่อนำไปใช้ต่อเลยทีเดียว หวังว่าจะเป็นประโยชน์กับทุกท่าน\nPandas คืออะไร? Pandas เป็น Library ใน Python ที่ทำให้เราเล่นกับข้อมูลได้ง่ายขึ้น เหมาะมากสำหรับทำ Data Cleaning / Wrangling ครับผม\nวิธีการใช้งาน Pandas คือ โหลดไฟล์ข้อมูล เช่น CSV เข้าไป แล้วเราจะได้ข้อมูลในรูปแบบตาราง (DataFrame) ที่แบ่งข้อมูลตามแถวและคอลัมน์ หรือเหมือน Excel ที่เราใช้กันนั่นเอง\n\nตัวอย่าง DataFrame ของ Pandas เป็นตารางเหมือน Excel เลยครับ\nป.ล. Pandas ไม่เกี่ยวกับหมีแพนด้านะฮะ จริง ๆ แล้วมาจากคำว่า PANel DAta ซึ่งหมายถึงข้อมูลที่มีหลายมิตินั่นเอง\nเทคนิคการใช้ Pandas อย่างที่แอดมินเคยเล่า ว่าการทำ Data Wrangling เป็นงานที่ค่อนข้างถึกครับ วันนี้เลยรวบรวมโค้ดต่าง ๆ ในการใช้ Pandas มาให้ ซึ่งน่าจะครอบคลุมการใช้งานประมาณ 80 – 90% แล้วครับผม\nโค้ดบางส่วนมาจากคลาส Data Wrangling ที่แอดมินเรียน และจากเว็บไซต์ MyCheatSheet ครับ\nConfiguring Pandas กำหนดค่าให้ Pandas สำหรับทำงานบน Jupyter Notebook\n# import numpy and pandas import numpy as np import pandas as pd # used for dates import datetime from datetime import datetime, date # Set some pandas options controlling output format pd.set_option(\u0026#39;display.notebook_repr_html\u0026#39;, False) pd.set_option(\u0026#39;display.max_columns\u0026#39;, 20) pd.set_option(\u0026#39;display.max_rows\u0026#39;, 15) pd.set_option(\u0026#39;display.width\u0026#39;, 90) # bring in matplotlib for graphics import matplotlib.pyplot as plt %matplotlib inline วิธีเช็ค Version Pandas โค้ดนี้เหมือนไม่สำคัญ แต่จริง ๆ แล้วสำคัญมากเวลาเราอ่าน Documentation ครับ เพราะถ้าเกิดมีอะไรพัง เราจะเทียบได้ว่า Pandas ของเราเป็นเวอร์ชั่นตามใน Documentation มั้ย\nprint (\u0026#34;Pandas version\u0026#34;,pandas.__version__) output\nPandas version 0.24.1 วิธีการโหลดไฟล์ CSV (Import) จุดเริ่มต้นของการทำ Data Exploration \u0026amp; Analysis ใน Pandas ก็คือการโหลดไฟล์ข้อมูลแบบ CSV มาใช้งานนั่นเองครับ\nเราสามารถใช้คำสั่ง .head หรือ .tail เพื่อดูข้อมูลแถวบนสุด หรือแถวล่างสุดได้\n# Read DF csvdf = pd.read_csv(\u0026#39;data.csv\u0026#39;) # Sometimes reading CSV for Excel need encoding csvdf = pd.read_csv(\u0026#39;data.csv\u0026#39;,encoding = \u0026#34;ISO-8859-1\u0026#34;) # Print head and tail csvdf.head() csvdf.tail() วิธีสุ่มข้อมูลสำหรับเช็ค (Sample) ปกติเราเช็คข้อมูลว่าถูกต้องมั้ยด้วย head กับ tail ซึ่งเป็นการเช็คจากด้านบนหรือด้านล่าง อีกวิธีที่น่าสนใจ คือ เช็คแบบสุ่มข้อมูลขึ้นมานั่นเองครับ ทำได้ง่าย ๆ โดยใช้\ncsvdf.sample() วิธีเช็คข้อมูลหาความผิดปกติใน DataFrame เบื้องต้น หลังจากโหลดข้อมูลมาแล้ว เราอยากรู้ว่าข้อมูลมีกี่แถว, Missing value เท่าไหร่, แต่ละคอลัมน์เป็น Data Type อะไรบ้าง ก็รันคำสั่งนี้ได้เลย มีประโยชน์มากครับ\ndf.info() df.info() จะแสดงสรุปข้อมูลมาให้\nนอกจากนั้นยังมีคำสั่ง df.dtypes (ไม่มีวงเล็บ) สำหรับดู Data Type แต่ละคอลัมน์อย่างเดียว\nวิธีแปลงประเภทข้อมูล (Data Type) ใน Data Frame บางครั้งประเภทข้อมูลของคอลัมน์เป็น String แต่เราต้องการ Integer หรือเราต้องการ Date เราสามารถแปลงข้อมูลได้ง่าย ๆ ดังนี้เลยครับ\ndf[\u0026#39;hour\u0026#39;] = pd.to_numeric(df[\u0026#39;hour\u0026#39;]) # แปลงเป็น Numeric df[\u0026#39;hour\u0026#39;] = df[\u0026#39;hour\u0026#39;].astype(\u0026#39;int\u0026#39;) # อีกวิธีในการแปลงค่า สามารถใช้วิธีนี้แปลงเป็น float ได้ วิธีเช็ค Summary ของแต่ละคอลัมน์ (count, min, max, mean) ถ้าเราอยากรู้ Distribution คร่าว ๆ ของแต่ละคอลัมน์ว่าเป็นอย่างไร สามารถใช้คำสั่ง describe() ได้\ndf.describe() วิธีเช็ค Summary (count, min, max, mean) แบบแยกกลุ่ม บางครั้งเราไม่ได้ต้องการรู้ Summary ของทั้งคอลัมน์ แต่อยากให้แยกตามแต่ละค่าในคอลัมน์นั้น ๆ ครับ ซึ่งมีประโยชน์มากเวลาเราทำ Data Analysis แล้วอยากรู้ว่าบางกลุ่มมีอะไรผิดปกติหรือเปล่า\ntest = df.groupby([\u0026#39;Gender\u0026#39;]) test.describe() วิธีสร้าง DataFrame ใหม่ วิธีสร้างแบบง่ายที่สุด ถ้าต้องการข้อมูลหลายรูปแบบ เราสามารถใช้ Dictionary แบบนี้เลยครับ\ndataframe = pandas.DataFrame({ \u0026#39;C1\u0026#39;: pandas.date_range(\u0026#39;20170101\u0026#39;, periods=4), \u0026#39;C2\u0026#39; : [10,20,30,40], \u0026#39;C3\u0026#39;: pandas.Categorical([\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;]), \u0026#39;C4\u0026#39;: 1}) แต่ถ้าเราต้องการแค่เป็นแบบตัวเลขทั่วไป ใช้ Numpy แบบนี้ได้เลย\narray = numpy.array([(1,2,3), (4,5,6),(7,8,9)]) dataframe = pandas.DataFrame(array,columns=[\u0026#39;C1\u0026#39;,\u0026#39;C2\u0026#39;,\u0026#39;C3\u0026#39;]) วิธีเลือกหลายคอลัมน์จาก DataFrame ปกติถ้าเราต้องการเลือกแค่ 1 Column ก็เขียนแบบนี้ได้เลย\ndf[\u0026#39;C1\u0026#39;] แต่ถ้าต้องการเลือกหลายคอลัมน์ ให้ทำแบบนี้\ndf[[\u0026#39;C1\u0026#39;,\u0026#39;C2\u0026#39;]] วิธีเลือกคอลัมน์ตามเงื่อนไขที่ต้องการ บางทีเราอยาก Filter เฉพาะคอลัมน์ที่มีค่าตามที่เราต้องการโดยใช้ .loc ได้ โดยสามารถเลือก Filter แบบ .all() (ทุกค่าในคอลัมน์ต้องตรงตามเงื่อนไข) หรือ .any() (บางค่าในคอลัมน์ต้องตรงตามเงื่อนไข)\ndataframe2 = dataframe.loc[:,(dataframe\u0026gt;50).any()] dataframe3 = dataframe.loc[:,(dataframe\u0026gt;50).all()] เราสามารถใช้หาคอลัมน์ที่มี Missing Values หรือหาคอลัมน์ที่ไม่มี Missing Values เลยก็ได้\ndataframe2 = dataframe.loc[:,dataframe.isnull().any()] dataframe3 = dataframe.loc[:,dataframe.notnull().all()] วิธีเลือกแถวตามเงื่อนไขที่ต้องการ dataframe[dataframe[\u0026#39;C1\u0026#39;]\u0026gt;50] # เงื่อนไขแบบง่าย ๆ dataframe2 = dataframe.loc[dataframe.C1.isin([1,2,3])] # เงื่อนไขแบบซับซ้อน ถ้ามีหลายเงื่อนไขเราสามารถใช้ \u0026amp; (and) หรือ | (or) ได้\ndataframe[(dataframe[\u0026#39;C1\u0026#39;]\u0026gt;50) \u0026amp; ((dataframe[\u0026#39;C2\u0026#39;]\u0026lt;25) | (dataframe[\u0026#39;C2\u0026#39;]\u0026gt;75))] หรือใช้ Query เป็นเงื่อนไขได้ด้วย มีประโยชน์มากเวลาเรามีเงื่อนไขแปลก ๆ ไม่ต้องเขียนลูปขึ้นมาเองเลยครับ\ndataframe2 = dataframe.query(\u0026#39;C1 \u0026gt; C2\u0026#39;) วิธีเพิ่มคอลัมน์ใหม่ สามารถเพิ่มคอลัมน์ใหม่ได้ 2 แบบ คือ\n  เพิ่มโดยอิงจากคอลัมน์เดิม (เช่น เอาคอลัมน์เดิม + 10 หรือ เอาคอลัมน์ A – คอลัมน์ B มีประโยชน์มากตอนทำ Feature Engineering)\n  เพิ่มคอลัมน์โดยตั้งค่า Fix ไปเลยสำหรับทุกแถว ส่วนใหญ่จะใช้วิธีนี้เวลาเราอยากได้ค่าอะไรแปลก ๆ ที่ต้องเขียนลูปเพื่อใส่ค่า ก็สร้างคอลัมน์แบบ Fix ค่าก่อน แล้วต่อด้วยลูป\ndf[\u0026#39;new\u0026#39;] = dataframe[\u0026#39;old\u0026#39;] + 10 # use old values df[\u0026#39;new2\u0026#39;] = 5 # apply the same value การสลับ Row \u0026lt;-\u0026gt; Column (Transpose)\n  ถ้าเราต้องการ Transpose (อารมณ์เหมือน Vector) เราสามารถใช้คำสั่งนี้ได้เลย\ndataframe.T การต่อ DataFrame การต่อ Data Frame คือการเอา Data Set 2 ชุดมาต่อกันในแถวตั้งหรือแนวนอน สำหรับการต่อแบบปะติดไปเลย\nมี 2 คำสั่งที่เหมือนกัน คือ concat กับ append แต่ให้ใช้ concat ไปเลย เพราะ append เป็นคำสั่งที่ไม่ Memory Efficient\npd.concat([df1,df2], axis=1) # รวมกัน 2 คอลัมน์ (axis = 0 คือแถว, axis = 1 คือคอลัมน์) pd.concat([df1,df2,df3)] # รวมมากกว่า 2 คอลัมน์ก็ได้ pd.concat(…, ignore_index=True) # รวมเสร็จแล้ว reset index ให้ด้วย ควรใช้ ไม่งั้นจะเจอ row ID ซ้ำกันตอนรวมร่าง pd.concat(…, join=\u0026#39;inner\u0026#39;) # รวมร่างเฉพาะคอลัมน์ที่ df1 กับ df2 มีทั้งคู่ pd.concat(…, keys=[\u0026#39;source1\u0026#39;, \u0026#39;source2\u0026#39;]) # เพิ่มคอลัมน์เข้าไปด้วยเพื่อระบุว่า Row แต่ละอันมาจาก Data Frame อันไหน pd.concat(…, join_axes=[df2.index]) # เลือกรวมร่างเฉพาะ row index ที่เรากำหนดได้ การต่อ DataFrame แบบ Join ถ้าต้องการต่อ DataFrame แบบ Advance หน่อย เราก็สามารถ Join DataFrame ได้เหมือน Join Table ใครเขียน SQL มาก่อนน่าจะถนัดเลย\npd.merge(df1, df2, left_on=\u0026#34;col1\u0026#34;, right_on=\u0026#34;col2\u0026#34;, how=\u0026#34;inner\u0026#34;) เราสามารถเปลี่ยนตรง how=”inner” เป็น “outer”, “left”, “right” เพื่อเปลี่ยนเป็น Outer Join, Left Join, Right Join ได้อีกด้วย\nการหาค่า Mean, Sum, Max (Aggregate) แบบทั้ง DataFrame Pandas สามารถสั่ง Aggregate เพื่อหาค่า Mean, Sum, และ Max ได้เลย เหมาะมากเวลาเราต้องการรวบข้อมูลก่อนเอาไป Visualize หรือต้องการทำ Feature Engineering ก็ได้\nnewdf = df.agg([\u0026#39;sum\u0026#39;, \u0026#39;max\u0026#39;,\u0026#39;mean\u0026#39;]) การ Aggregate แบบตามกลุ่มที่ต้องการ บางทีเราอยาก Aggregate ข้อมูลตามการจัดกลุ่มในคอลัมน์อื่น เช่น เราอยากได้รายจ่ายทั้งหมดของแต่ละคน (ต้อง aggregate sum ของคอลัมน์รายจ่าย โดยแบ่งกลุ่มตามคอลัมน์ User ID) ใช้แบบนี้\naggregate = dataframe.groupby(\u0026#39;C1\u0026#39;).sum() การรัน Function เดียวกันทุกแถว หรือทุกคอลัมน์ เวลาเราอยากรันคำสั่งอะไรสักอย่างสำหรับทุกแถว หรือทุกคอลัมน์ เราสามารถเขียนได้แบบนี้\n# sum for columns sum_columns = dataframe[[\u0026#39;C1\u0026#39;,\u0026#39;C2\u0026#39;]].apply(sum,axis=0) # sum for rows sum_rows = dataframe[[\u0026#39;C1\u0026#39;,\u0026#39;C2\u0026#39;]].apply(sum,axis=1) เหมือนกับฟังก์ชั่น apply() ใน R นั่นเอง\nรันคำสั่งที่เขียนเองกับทุกแถวใน 1 คอลัมน์ ถ้าต้องการรันคำสั่ง (Function) ที่เขียนเอง สำหรับทุกแถวในคอลัมน์อันใดอันหนึ่ง ใช้แบบนี้ได้\ndataframe[\u0026#39;C1\u0026#39;] = dataframe[\u0026#39;C1\u0026#39;].map(lambda x: x-100) รันคำสั่งที่เขียนเองกับทุกค่า ถ้าต้องการรันคำสั่งที่เขียนเองกับทุกค่าใน DataFrame ใช้โค้ดนี้\nfunction_result = dataframe.applymap(lambda x: x*10) หรือใช้ transform ก็ได้\nnew_dataframe = dataframe.transform(lambda x: x*100) คำนวณ Correlation \u0026amp; Covariance เวลาเราอยากรู้ว่าค่าต่าง ๆ ใน Data Set เรา Correlate กันมั้ย\ndataframe.corr() # Correlation dataframe.cov() # Covariance แต่ค่าที่ออกมาเป็นตัวเลขอาจจะดูยากนิดนึง เราสามารถพลอตสวย ๆ ด้วย Seaborn ได้ครับ สามารถใช้โค้ดด้านล่างนี้ได้เลย\nimport seaborn as sns corr = modeldf.corr() # Set up the matplotlib figure f, ax = plt.subplots(figsize=(15, 8)) # Generate a custom diverging colormap cmap = sns.diverging_palette(10, 10, as_cmap=True) # Draw the heatmap with the mask and correct aspect ratio sns.heatmap(corr, annot=True) Correlation Plot สวย ๆ ด้วย Seaborn\nคำนวณ Cross Tabulation Cross Tabulation มีประโยชน์มากเวลาเราอยากรู้ว่ามี Data ที่ตรงกับกรุ๊ป A ของคอลัมน์ 1 และกรุ๊ป B ของคอลัมน์ 2 เท่าไหร่ เช่น มีนักเรียนผู้ชาย (คอลัมน์ gender) กี่คนในมัธยมปลาย (คอลัมน์ education) แบบนี้เป็นต้น\nหรือถ้าใครใช้ PivotTable ใน Excel มาก่อน ก็เหมือนกันเลยครับ\naggregate = pandas.crosstab(dataframe.C1, dataframe.C2) วิธีหาค่า Unique ในแต่ละคอลัมน์ คำสั่งนี้มีประโยชน์มาก เอาไว้ใช้เช็คว่าแต่ละคอลัมน์มีค่าแปลก ๆ มั้ย\nตัวอย่างการใช้งานก็คือ เราอยากรู้ว่า มีบ้านไหนที่มีจำนวนห้องนอนแปลก ๆ มั้ย (เช่น 50 ห้องนอน หรือ -5 ห้องนอน) ก็หาค่า unique จากคอลัมน์ “bedrooms”\ndataframe[\u0026#39;C1\u0026#39;].unique() วิธีเช็คว่ามีแถวไหนข้อมูลซ้ำมั้ย (Duplicated) อันนี้มีประโยชน์มาก เอาไว้ใช้เช็คว่ามีข้อมูลแปลก ๆ มั้ย เช่น ทุกคอลัมน์ซ้ำกันหมด (อันนี้มีโอกาสว่าเป็นข้อมูลซ้ำ อาจจะต้องลบออก) หรือซ้ำกันบางคอลัมน์ (อันนี้ต้องเช็คอีกทีว่าคืออะไร)\ndataframe.duplicated() # หาอันที่เหมือนกันทุกคอลัมน์ dataframe.duplicated(\u0026#39;C1\u0026#39;) # หาอันที่ซ้ำกันเฉพาะคอลัมน์ C1 dataframe.duplicated([\u0026#39;C1\u0026#39;, \u0026#39;C2\u0026#39;]) # หาอันที่ซ้ำกันเฉพาะคอลัมน์ C1 และ C2 ปกติแล้วถ้ามีไอเทมซ้ำ คำสั่งนี้จะไม่แสดงไอเทมแรกในกลุ่มที่ซ้ำ (เช่น ถ้า C1=5 มี 2 แถว มันจะแสดงเฉพาะแถวที่ 2) เราสามารถใส่ Argument keep=False เข้าไปเพื่อบังคับให้มันแสดงทุกแถวได้\nนอกจากนั้นเรายังสามารถนับจำนวนแถวที่ Duplicate และลบทิ้งได้ด้วย\nวิธีการนับจำนวน Duplicate len(df[ df.duplicated([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;], keep = False) ]) วิธีการลบ Duplicate เอาไว้ใช้ตอนเราเจอว่าทุกคอลัมน์ซ้ำกันหมดเลย ซึ่งเป็นเคสที่บอกว่าข้อมูลน่าจะซ้ำ ลบออกได้ (ขึ้นอยู่กับข้อมูลด้วยนะครับ บางข้อมูลอาจจะไม่ได้แปลว่าซ้ำแล้วลบได้):\nRemove the duplicates df.drop_duplicates([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;], inplace=True) Reset dataframe index after drop_duplicates. df.reset_index(drop=True, inplace=True) len(df) สำหรับโค้ดข้างบน จะเห็นว่าเราต้อง reset index หลังลบ duplicate ด้วยนะครับ\nวิธีการลบแถว และลบคอลัมน์ ลบคอลัมน์สามารถทำได้แบบนี้\ndataframe = dataframe.drop(\u0026#39;C1\u0026#39;, axis=1) df.drop([\u0026#39;C1\u0026#39;], axis=1, inplace=True) # แบบนี้ก็ได้ df.drop([\u0026#39;C1\u0026#39;, \u0026#39;C2\u0026#39;, \u0026#39;C3\u0026#39;], 1, inplace=True) # ลบทีละหลายคอลัมน์ก็ได้ ส่วนการลบแถวจะลำบากหน่อย เพราะต้องใส่ Row Index (เลขที่อยู่ซ้ายสุดเวลาเราปรินท์ DataFrame)\ndataframe = dataframe.drop(5, axis=0) dataframe.reset_index(drop=True) # Reset index ลบแถวแล้วอย่าลืมเช็คด้วยว่าที่ลบไปถูกต้องมั้ย และหลังจากลบแถวต้อง Reset Index ด้วย\nวิธีการลบแถวที่มี Missing Value ข้อควรระวัง: การที่อยู่ ๆ เราลบแถวที่มี Missing Value ทิ้งไปเลยอาจจะไม่ใช่วิธีที่ดีที่สุดในการทำ Data Analysis เสมอไปนะครับ บางเคสการ Impute (คำนวณหาค่าไปใส่) จะดีกว่าครับ\ndataframe2 = dataframe.dropna(axis=0) วิธีแทนค่า Missing Value ด้วยค่าเฉลี่ย (Mean Imputation) วิธีหนึ่งในการแทนค่าที่หายไป คือการทำสิ่งที่เรียกว่า Mean Imputation หรือหาค่าเฉลี่ยของคอลัมน์นั้น แล้วเอามาแทนค่าที่หายไปนั่นเองครับ\nข้อดีของการทำ Mean Imputation คือ สามารถทำได้ง่าย แต่ก็ต้องระวังเรื่องข้อเสีย เช่น ทำแบบนี้จะเป็นการไม่สนใจความสัมพันธ์ระหว่างตัวแปร ทำให้เกิด Bias สูง ควรใช้เฉพาะเวลา Missing Value ไม่เยอะเท่านั้นครับ\nสามารถรันโค้ดด้านล่างเพื่อทำ Mean Imputation ได้ง่าย ๆ เลย\nimport numpy as np meanAge = np.mean(df.Age) # Get mean value df.Age = df.Age.fillna(meanAge) # Fill missing values with mean การลูปข้อมูลแต่ละคอลัมน์ และแต่ละแถว การลูปมีประโยชน์มากถ้าเราต้องการเขียนฟังก์ชั่นแปลก ๆ ใช้เองที่ Pandas ไม่รองรับ (หรืออาจจะรองรับแต่เราหาไม่เจอ เขียนเองง่ายกว่า) สามารถลูปได้ทั้งแต่ละคอลัมน์ และแต่ละแถว\nfor col_idx,data in dataframe.iteritems(): print (\u0026#34;column:\u0026#34;,col_idx) print (\u0026#34;column data:\u0026#34;) print (data,\u0026#34;\\n\u0026#34;) การลูปข้อมูลแต่ละแถว\nfor col_idx,data in dataframe.iterrows(): print (\u0026#34;row:\u0026#34;,col_idx) print (\u0026#34;row data:\u0026#34;) print (data,\u0026#34;\\n\u0026#34;) วิธีเปลี่ยน DataFrame จากแบบ Wide เป็น Long (Melt) การ Melt Data มีประโยชน์มากเวลาเราต้องการเอาข้อมูลไปพลอต Data Visualization หรือเราต้องการ Aggregate ครับ\ndataframe2 = dataframe.melt() วิธีการเปลี่ยนชื่อคอลัมน์ (Rename) บางทีเราต้องการเปลี่ยนชื่อเพื่อให้สั้นลง ให้พิมพ์สะดวกขึ้น สามารถทำได้ดังนี้\ndataframe.rename(columns={\u0026#39;old\u0026#39;:\u0026#39;new\u0026#39;},inplace=True) วิธีการใส่คำนำหน้าคอลัมน์ (Prefix) อันนี้มีประโยชน์มากตอนเรามีข้อมูลหลาย ๆ ชุด และต้องการ Merge โดยอยากให้ชื่อคอลัมน์ไม่ซ้ำกัน\nthisdata = thisdata.add_prefix(\u0026#39;data_\u0026#39;) วิธีการแทนค่าใน DataFrame เหมาะมากเวลาต้องการแก้ Typo Error เช่น เราอยากได้ค่า Bangkok แต่เรารู้ว่ามีคนเขียนเป็น BKK อะไรแบบนี้ (รันคำสั่ง .unique เพื่อดูก่อน)\nเราสามารถ Replace ทั้ง DataFrame ได้เลยแบบนี้\ndataframe2 = dataframe.replace(1, -100) เราสามารถ Replace หลายค่าพร้อมกันได้ด้วยครับ และสามารถกำหนด Column ที่ต้องการให้แทนค่าได้ด้วย\ndf[\u0026#39;city\u0026#39;].replace({ \u0026#39;BKK\u0026#39;:\u0026#39;Bangkok\u0026#39;, \u0026#39;BNK\u0026#39;:\u0026#39;Bangkok\u0026#39; }, inplace=True) วิธีการ Export DataFrame เป็นไฟล์ CSV หลังจากที่เราจัดการ Data เรียบร้อยแล้ว ก็สามารถ Export เป็น CSV เอาไปใช้ต่อกับโปรแกรมอื่น หรืองานส่วนอื่น ๆ ได้ (แอดทำบ่อยเพราะบางทีต้องสลับ Python \u0026lt;-\u0026gt; R รัว ๆ)\ndataframe.to_csv(\u0026#39;dataframe.csv\u0026#39;) สรุปการใช้งาน Pandas จากเทคนิคต่าง ๆ ด้านบน จะเห็นว่า Pandas มีฟังก์ชั่นให้เราทำงานได้ง่ายขึ้นมาก ๆ ครับ หวังว่าบทความนี้จะมีประโยชน์กับท่านที่กำลังหัดใช้งาน Pandas กันอยู่นะครับ\n ที่มาบทความ blog.datath.com.\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/date-time/",
	"title": "Date &amp; Time",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/datetime/datetime_module/",
	"title": "datetime() Module",
	"tags": [],
	"description": "",
	"content": "In this article, you will learn to manipulate date and time in Python with the help of examples.\nPython has a module named datetime to work with dates and times. Let\u0026rsquo;s create a few simple programs related to date and time before we dig deeper.\n Example 1: Get Current Date and Time import datetime datetime_object = datetime.datetime.now() print(datetime_object) When you run the program, the output will be something like:\n2018-12-19 09:26:03.478039 Here, we have imported datetime module using import datetime statement.\nOne of the classes defined in the datetime module is datetime class. We then used now() method to create a datetime object containing the current local date and time.\n Example 2: Get Current Date import datetime date_object = datetime.date.today() print(date_object) When you run the program, the output will be something like:\n2018-12-19 In this program, we have used today() method defined in the date class to get a date object containing the current local date.\n What\u0026rsquo;s inside datetime?\nWe can use dir() function to get a list containing all attributes of a module.\nimport datetime print(dir(datetime)) When you run the program, the output will be:\n[\u0026#39;MAXYEAR\u0026#39;, \u0026#39;MINYEAR\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;__cached__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__file__\u0026#39;, \u0026#39;__loader__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__package__\u0026#39;, \u0026#39;__spec__\u0026#39;, \u0026#39;_divide_and_round\u0026#39;, \u0026#39;date\u0026#39;, \u0026#39;datetime\u0026#39;, \u0026#39;datetime_CAPI\u0026#39;, \u0026#39;time\u0026#39;, \u0026#39;timedelta\u0026#39;, \u0026#39;timezone\u0026#39;, \u0026#39;tzinfo\u0026#39;]  Commonly used classes in the datetime module are:\n date Class time Class datetime Class timedelta Class   datetime.date Class You can instantiate date objects from the date class. A date object represents a date (year, month and day).\n Example 3: Date object to represent a date import datetime d = datetime.date(2019, 4, 13) print(d) When you run the program, the output will be:\n2019-04-13 If you are wondering, date() in the above example is a constructor of the date class. The constructor takes three arguments: year, month and day.\nThe variable a is a date object.\n We can only import date class from the datetime module. Here\u0026rsquo;s how:\nfrom datetime import date a = date(2019, 4, 13) print(a)  Example 4: Get current date You can create a date object containing the current date by using a classmethod named today(). Here\u0026rsquo;s how:\nfrom datetime import date today = date.today() print(\u0026#34;Current date =\u0026#34;, today)  Example 5: Get date from a timestamp We can also create date objects from a timestamp. A Unix timestamp is the number of seconds between a particular date and January 1, 1970 at UTC. You can convert a timestamp to date using fromtimestamp() method.\nfrom datetime import date timestamp = date.fromtimestamp(1326244364) print(\u0026#34;Date =\u0026#34;, timestamp) When you run the program, the output will be:\nDate = 2012-01-11  Example 6: Print today\u0026rsquo;s year, month and day We can get year, month, day, day of the week etc. from the date object easily. Here\u0026rsquo;s how:\nfrom datetime import date # date object of today\u0026#39;s date today = date.today() print(\u0026#34;Current year:\u0026#34;, today.year) print(\u0026#34;Current month:\u0026#34;, today.month) print(\u0026#34;Current day:\u0026#34;, today.day)  datetime.time A time object instantiated from the time class represents the local time.\n Example 7: Time object to represent time from datetime import time # time(hour = 0, minute = 0, second = 0) a = time() print(\u0026#34;a =\u0026#34;, a) # time(hour, minute and second) b = time(11, 34, 56) print(\u0026#34;b =\u0026#34;, b) # time(hour, minute and second) c = time(hour = 11, minute = 34, second = 56) print(\u0026#34;c =\u0026#34;, c) # time(hour, minute, second, microsecond) d = time(11, 34, 56, 234566) print(\u0026#34;d =\u0026#34;, d) When you run the program, the output will be:\na = 00:00:00 b = 11:34:56 c = 11:34:56 d = 11:34:56.234566  Example 8: Print hour, minute, second and microsecond Once you create a time object, you can easily print its attributes such as hour, minute etc.\nfrom datetime import time a = time(11, 34, 56) print(\u0026#34;hour =\u0026#34;, a.hour) print(\u0026#34;minute =\u0026#34;, a.minute) print(\u0026#34;second =\u0026#34;, a.second) print(\u0026#34;microsecond =\u0026#34;, a.microsecond) When you run the example, the output will be:\nhour = 11 minute = 34 second = 56 microsecond = 0 Notice that we haven\u0026rsquo;t passed microsecond argument. Hence, its default value 0 is printed.\n datetime.datetime The datetime module has a class named dateclass that can contain information from both date and time objects.\n Example 9: Python datetime object from datetime import datetime #datetime(year, month, day) a = datetime(2018, 11, 28) print(a) # datetime(year, month, day, hour, minute, second, microsecond) b = datetime(2017, 11, 28, 23, 55, 59, 342380) print(b) When you run the program, the output will be:\n2018-11-28 00:00:00 2017-11-28 23:55:59.342380 The first three arguments year, month and day in the datetime() constructor are mandatory.\n Example 10: Print year, month, hour, minute and timestamp from datetime import datetime a = datetime(2017, 11, 28, 23, 55, 59, 342380) print(\u0026#34;year =\u0026#34;, a.year) print(\u0026#34;month =\u0026#34;, a.month) print(\u0026#34;hour =\u0026#34;, a.hour) print(\u0026#34;minute =\u0026#34;, a.minute) print(\u0026#34;timestamp =\u0026#34;, a.timestamp()) When you run the program, the output will be:\nyear = 2017 month = 11 day = 28 hour = 23 minute = 55 timestamp = 1511913359.34238  datetime.timedelta A timedelta object represents the difference between two dates or times.\n Example 11: Difference between two dates and times from datetime import datetime, date t1 = date(year = 2018, month = 7, day = 12) t2 = date(year = 2017, month = 12, day = 23) t3 = t1 - t2 print(\u0026#34;t3 =\u0026#34;, t3) t4 = datetime(year = 2018, month = 7, day = 12, hour = 7, minute = 9, second = 33) t5 = datetime(year = 2019, month = 6, day = 10, hour = 5, minute = 55, second = 13) t6 = t4 - t5 print(\u0026#34;t6 =\u0026#34;, t6) print(\u0026#34;type of t3 =\u0026#34;, type(t3)) print(\u0026#34;type of t6 =\u0026#34;, type(t6)) When you run the program, the output will be:\nt3 = 201 days, 0:00:00 t6 = -333 days, 1:14:20 type of t3 = \u0026lt;class \u0026#39;datetime.timedelta\u0026#39;\u0026gt; type of t6 = \u0026lt;class \u0026#39;datetime.timedelta\u0026#39;\u0026gt; Notice, both t3 and t6 are of \u0026lt;class 'datetime.timedelta'\u0026gt; type.\n Example 12: Difference between two timedelta objects from datetime import timedelta t1 = timedelta(weeks = 2, days = 5, hours = 1, seconds = 33) t2 = timedelta(days = 4, hours = 11, minutes = 4, seconds = 54) t3 = t1 - t2 print(\u0026#34;t3 =\u0026#34;, t3) When you run the program, the output will be:\nt3 = 14 days, 13:55:39 Here, we have created two timedelta objects t1 and t2, and their difference is printed on the screen.\n Example 13: Printing negative timedelta object from datetime import timedelta t1 = timedelta(seconds = 33) t2 = timedelta(seconds = 54) t3 = t1 - t2 print(\u0026#34;t3 =\u0026#34;, t3) print(\u0026#34;t3 =\u0026#34;, abs(t3)) When you run the program, the output will be:\nt3 = -1 day, 23:59:39 t3 = 0:00:21  Example 14: Time duration in seconds You can get the total number of seconds in a timedelta object using total_seconds() method.\nfrom datetime import timedelta t = timedelta(days = 5, hours = 1, seconds = 33, microseconds = 233423) print(\u0026#34;total seconds =\u0026#34;, t.total_seconds()) When you run the program, the output will be:\ntotal seconds = 435633.233423  You can also find sum of two dates and times using + operator. Also, you can multiply and divide a timedelta object by integers and floats.\n Python format datetime The way date and time is represented may be different in different places, organizations etc. It\u0026rsquo;s more common to use mm/dd/yyyy in the US, whereas dd/mm/yyyy is more common in the UK.\nPython has strftime() and strptime() methods to handle this.\n Python strftime() - datetime object to string The strftime() method is defined under classes date, datetime and time. The method creates a formatted string from a given date, datetime or time object.\n Example 15: Format date using strftime() from datetime import datetime # current date and time now = datetime.now() t = now.strftime(\u0026#34;%H:%M:%S\u0026#34;) print(\u0026#34;time:\u0026#34;, t) s1 = now.strftime(\u0026#34;%m/%d/%Y, %H:%M:%S\u0026#34;) # mm/dd/YY H:M:S format print(\u0026#34;s1:\u0026#34;, s1) s2 = now.strftime(\u0026#34;%d/%m/%Y, %H:%M:%S\u0026#34;) # dd/mm/YY H:M:S format print(\u0026#34;s2:\u0026#34;, s2) When you run the program, the output will be something like:\ntime: 04:34:52 s1: 12/26/2018, 04:34:52 s2: 26/12/2018, 04:34:52 Here, %Y, %m, %d, %H etc. are format codes. The strftime() method takes one or more format codes and returns a formatted string based on it.\nIn the above program, t, s1 and s2 are strings.\n %Y - year [0001,\u0026hellip;, 2018, 2019,\u0026hellip;, 9999] %m - month [01, 02, \u0026hellip;, 11, 12] %d - day [01, 02, \u0026hellip;, 30, 31] %H - hour [00, 01, \u0026hellip;, 22, 23 %M - minute [00, 01, \u0026hellip;, 58, 59] %S - second [00, 01, \u0026hellip;, 58, 59]  To learn more about strftime() and format codes, visit: Python strftime().\n Python strptime() - string to datetime The strptime() method creates a datetime object from a given string (representing date and time).\n Example 16: strptime() from datetime import datetime date_string = \u0026#34;21 June, 2018\u0026#34; print(\u0026#34;date_string =\u0026#34;, date_string) date_object = datetime.strptime(date_string, \u0026#34;%d%B, %Y\u0026#34;) print(\u0026#34;date_object =\u0026#34;, date_object) When you run the program, the output will be:\ndate_string = 21 June, 2018 date_object = 2018-06-21 00:00:00 The strptime() method takes two arguments:\n a string representing date and time format code equivalent to the first argument  By the way, %d, %B and %Y format codes are used for day, month(full name) and year respectively.\nVisit Python strptime() to learn more.\n Handling timezone in Python Suppose, you are working on a project and need to display date and time based on their timezone. Rather than trying to handle timezone yourself, we suggest you to use a third-party pytZ module.\nfrom datetime import datetime import pytz local = datetime.now() print(\u0026#34;Local:\u0026#34;, local.strftime(\u0026#34;%m/%d/%Y, %H:%M:%S\u0026#34;)) tz_NY = pytz.timezone(\u0026#39;America/New_York\u0026#39;) datetime_NY = datetime.now(tz_NY) print(\u0026#34;NY:\u0026#34;, datetime_NY.strftime(\u0026#34;%m/%d/%Y, %H:%M:%S\u0026#34;)) tz_London = pytz.timezone(\u0026#39;Europe/London\u0026#39;) datetime_London = datetime.now(tz_London) print(\u0026#34;London:\u0026#34;, datetime_London.strftime(\u0026#34;%m/%d/%Y, %H:%M:%S\u0026#34;)) When you run the program, the output will be something like:\nLocal time: 2018-12-20 13:10:44.260462 America/New_York time: 2018-12-20 13:10:44.260462 Europe/London time: 2018-12-20 13:10:44.260462 Here, datetime_NY and datetime_London are datetime objects containing the current date and time of their respective timezone.\n\n Reference : https://www.programiz.com/python-programming/datetime\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/tutorial-geeksforgeeks/selection/dealing-with-rows-and-columns/",
	"title": "Dealing with Rows and Columns",
	"tags": [],
	"description": "",
	"content": "Dealing with Rows and Columns in Pandas DataFrame\nA Data frame is a two-dimensional data structure, i.e., data is aligned in a tabular fashion in rows and columns. We can perform basic operations on rows/columns like selecting, deleting, adding, and renaming. In this article, we are using nba.csv file.\nDealing with Columns In order to deal with columns, we perform basic operations on columns like selecting, deleting, adding and renaming.\nColumn Selection:\nIn Order to select a column in Pandas DataFrame, we can either access the columns by calling them by their columns name.\n# Import pandas package  import pandas as pd # Define a dictionary containing employee data  data = {\u0026#39;Name\u0026#39;:[\u0026#39;Jai\u0026#39;, \u0026#39;Princi\u0026#39;, \u0026#39;Gaurav\u0026#39;, \u0026#39;Anuj\u0026#39;], \u0026#39;Age\u0026#39;:[27, 24, 22, 32], \u0026#39;Address\u0026#39;:[\u0026#39;Delhi\u0026#39;, \u0026#39;Kanpur\u0026#39;, \u0026#39;Allahabad\u0026#39;, \u0026#39;Kannauj\u0026#39;], \u0026#39;Qualification\u0026#39;:[\u0026#39;Msc\u0026#39;, \u0026#39;MA\u0026#39;, \u0026#39;MCA\u0026#39;, \u0026#39;Phd\u0026#39;]} # Convert the dictionary into DataFrame  df = pd.DataFrame(data) # select two columns  print(df[[\u0026#39;Name\u0026#39;, \u0026#39;Qualification\u0026#39;]]) Output:\nFor more examples refer to How to select multiple columns in a pandas dataframe\nColumn Addition:\nIn Order to add a column in Pandas DataFrame, we can declare a new list as a column and add to a existing Dataframe.\n# Import pandas package  import pandas as pd # Define a dictionary containing Students data  data = {\u0026#39;Name\u0026#39;: [\u0026#39;Jai\u0026#39;, \u0026#39;Princi\u0026#39;, \u0026#39;Gaurav\u0026#39;, \u0026#39;Anuj\u0026#39;], \u0026#39;Height\u0026#39;: [5.1, 6.2, 5.1, 5.2], \u0026#39;Qualification\u0026#39;: [\u0026#39;Msc\u0026#39;, \u0026#39;MA\u0026#39;, \u0026#39;Msc\u0026#39;, \u0026#39;Msc\u0026#39;]} # Convert the dictionary into DataFrame  df = pd.DataFrame(data) # Declare a list that is to be converted into a column  address = [\u0026#39;Delhi\u0026#39;, \u0026#39;Bangalore\u0026#39;, \u0026#39;Chennai\u0026#39;, \u0026#39;Patna\u0026#39;] # Using \u0026#39;Address\u0026#39; as the column name  # and equating it to the list  df[\u0026#39;Address\u0026#39;] = address # Observe the result  print(df) Output:\nFor more examples refer to Adding new column to existing DataFrame in Pandas\nColumn Deletion:\nIn Order to delete a column in Pandas DataFrame, we can use the drop() method. Columns is deleted by dropping columns with column names.\n# importing pandas module  import pandas as pd # making data frame from csv file  data = pd.read_csv(\u0026#34;nba.csv\u0026#34;, index_col =\u0026#34;Name\u0026#34; ) # dropping passed columns  data.drop([\u0026#34;Team\u0026#34;, \u0026#34;Weight\u0026#34;], axis = 1, inplace = True) # display  print(data) Output:\nAs shown in the output images, the new output doesn’t have the passed columns. Those values were dropped since axis was set equal to 1 and the changes were made in the original data frame since inplace was True.\nData Frame before Dropping Columns-\nData Frame after Dropping Columns-\nFor more examples refer to Delete columns from DataFrame using Pandas.drop()\nDealing with Rows: In order to deal with rows, we can perform basic operations on rows like selecting, deleting, adding and renmaing.\nRow Selection:\nPandas provide a unique method to retrieve rows from a Data frame.[DataFrame.loc[]](https://www.geeksforgeeks.org/python-pandas-extracting-rows-using-loc/) method is used to retrieve rows from Pandas DataFrame. Rows can also be selected by passing integer location to an iloc[] function.\n# importing pandas package  import pandas as pd # making data frame from csv file  data = pd.read_csv(\u0026#34;nba.csv\u0026#34;, index_col =\u0026#34;Name\u0026#34;) # retrieving row by loc method  first = data.loc[\u0026#34;Avery Bradley\u0026#34;] second = data.loc[\u0026#34;R.J. Hunter\u0026#34;] print(first, \u0026#34;\\n\\n\\n\u0026#34;, second) Output:\nAs shown in the output image, two series were returned since there was only one parameter both of the times.\nFor more examples refer to Pandas Extracting rows using .loc[]\nRow Addition:\nIn Order to add a Row in Pandas DataFrame, we can concat the old dataframe with new one.\n# importing pandas module  import pandas as pd # making data frame  df = pd.read_csv(\u0026#34;nba.csv\u0026#34;, index_col =\u0026#34;Name\u0026#34;) df.head(10) new_row = pd.DataFrame({\u0026#39;Name\u0026#39;:\u0026#39;Geeks\u0026#39;, \u0026#39;Team\u0026#39;:\u0026#39;Boston\u0026#39;, \u0026#39;Number\u0026#39;:3, \u0026#39;Position\u0026#39;:\u0026#39;PG\u0026#39;, \u0026#39;Age\u0026#39;:33, \u0026#39;Height\u0026#39;:\u0026#39;6-2\u0026#39;, \u0026#39;Weight\u0026#39;:189, \u0026#39;College\u0026#39;:\u0026#39;MIT\u0026#39;, \u0026#39;Salary\u0026#39;:99999}, index =[0]) # simply concatenate both dataframes  df = pd.concat([new_row, df]).reset_index(drop = True) df.head(5) Output:\nData Frame before Adding Row-\nData Frame after Adding Row-\nFor more examples refer to Add a row at top in pandas DataFrame\nRow Deletion:\nIn Order to delete a row in Pandas DataFrame, we can use the drop() method. Rows is deleted by dropping Rows by index label.\n# importing pandas module  import pandas as pd # making data frame from csv file  data = pd.read_csv(\u0026#34;nba.csv\u0026#34;, index_col =\u0026#34;Name\u0026#34; ) # dropping passed values  data.drop([\u0026#34;Avery Bradley\u0026#34;, \u0026#34;John Holland\u0026#34;, \u0026#34;R.J. Hunter\u0026#34;, \u0026#34;R.J. Hunter\u0026#34;], inplace = True) # display  data Output:\nAs shown in the output images, the new output doesn’t have the passed values. Those values were dropped and the changes were made in the original data frame since inplace was True.\nData Frame before Dropping values-\nData Frame after Dropping values-\nFor more examples refer to Delete rows from DataFrame using Pandas.drop()\nProblem related to Columns:\n How to get column names in Pandas dataframe How to rename columns in Pandas DataFrame How to drop one or multiple columns in Pandas Dataframe Get unique values from a column in Pandas DataFrame How to lowercase column names in Pandas dataframe Apply uppercase to a column in Pandas dataframe Capitalize first letter of a column in Pandas dataframe Get n-largest values from a particular column in Pandas DataFrame Get n-smallest values from a particular column in Pandas DataFrame Convert a column to row name/index in Pandas  Problem related to Rows:\n Apply function to every row in a Pandas DataFrame How to get rows names in Pandas dataframe   Reference : https://www.geeksforgeeks.org/dealing-with-rows-and-columns-in-pandas-dataframe/\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/function/function_arguments/",
	"title": "Function Arguments",
	"tags": [],
	"description": "",
	"content": "In Python, you can define a function that takes variable number of arguments. In this article, you will learn to define such functions using default, keyword and arbitrary arguments.\nArguments In the user-defined function topic, we learned about defining a function and calling it. Otherwise, the function call will result in an error. Here is an example.\ndef greet(name, msg): \u0026#34;\u0026#34;\u0026#34;This function greets to the person with the provided message\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Hello\u0026#34;, name + \u0026#39;, \u0026#39; + msg) greet(\u0026#34;Monica\u0026#34;, \u0026#34;Good morning!\u0026#34;) Output\nHello Monica, Good morning! Here, the function greet() has two parameters.\nSince we have called this function with two arguments, it runs smoothly and we do not get any error.\nIf we call it with a different number of arguments, the interpreter will show an error message. Below is a call to this function with one and no arguments along with their respective error messages.\n\u0026gt;\u0026gt;\u0026gt; greet(\u0026#34;Monica\u0026#34;) # only one argument TypeError: greet() missing 1 required positional argument: \u0026#39;msg\u0026#39; \u0026gt;\u0026gt;\u0026gt; greet() # no arguments TypeError: greet() missing 2 required positional arguments: \u0026#39;name\u0026#39; and \u0026#39;msg\u0026#39;  Variable Function Arguments Up until now, functions had a fixed number of arguments. In Python, there are other ways to define a function that can take variable number of arguments.\nThree different forms of this type are described below.\nPython Default Arguments Function arguments can have default values in Python.\nWe can provide a default value to an argument by using the assignment operator (=). Here is an example.\ndef greet(name, msg=\u0026#34;Good morning!\u0026#34;): \u0026#34;\u0026#34;\u0026#34; This function greets to the person with the provided message. If the message is not provided, it defaults to \u0026#34;Good morning!\u0026#34; \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Hello\u0026#34;, name + \u0026#39;, \u0026#39; + msg) greet(\u0026#34;Kate\u0026#34;) greet(\u0026#34;Bruce\u0026#34;, \u0026#34;How do you do?\u0026#34;) Output\nHello Kate, Good morning! Hello Bruce, How do you do? In this function, the parameter name does not have a default value and is required (mandatory) during a call.\nOn the other hand, the parameter msg has a default value of \u0026quot;Good morning!\u0026quot;. So, it is optional during a call. If a value is provided, it will overwrite the default value.\nAny number of arguments in a function can have a default value. But once we have a default argument, all the arguments to its right must also have default values.\nThis means to say, non-default arguments cannot follow default arguments. For example, if we had defined the function header above as:\ndef greet(msg = \u0026#34;Good morning!\u0026#34;, name): We would get an error as:\nSyntaxError: non-default argument follows default argument  Python Keyword Arguments When we call a function with some values, these values get assigned to the arguments according to their position.\nFor example, in the above function greet(), when we called it as greet(\u0026quot;Bruce\u0026quot;, \u0026quot;How do you do?\u0026quot;), the value \u0026quot;Bruce\u0026quot; gets assigned to the argument name and similarly \u0026quot;How do you do?\u0026quot; to msg.\nPython allows functions to be called using keyword arguments. When we call functions in this way, the order (position) of the arguments can be changed. Following calls to the above function are all valid and produce the same result.\n# 2 keyword arguments greet(name = \u0026#34;Bruce\u0026#34;,msg = \u0026#34;How do you do?\u0026#34;) # 2 keyword arguments (out of order) greet(msg = \u0026#34;How do you do?\u0026#34;,name = \u0026#34;Bruce\u0026#34;) 1 positional, 1 keyword argument greet(\u0026#34;Bruce\u0026#34;, msg = \u0026#34;How do you do?\u0026#34;) As we can see, we can mix positional arguments with keyword arguments during a function call. But we must keep in mind that keyword arguments must follow positional arguments.\nHaving a positional argument after keyword arguments will result in errors. For example, the function call as follows:\ngreet(name=\u0026#34;Bruce\u0026#34;,\u0026#34;How do you do?\u0026#34;) Will result in an error:\nSyntaxError: non-keyword arg after keyword arg  Python Arbitrary Arguments Sometimes, we do not know in advance the number of arguments that will be passed into a function. Python allows us to handle this kind of situation through function calls with an arbitrary number of arguments.\nIn the function definition, we use an asterisk (*) before the parameter name to denote this kind of argument. Here is an example.\ndef greet(*names): \u0026#34;\u0026#34;\u0026#34;This function greets all the person in the names tuple.\u0026#34;\u0026#34;\u0026#34; # names is a tuple with arguments for name in names: print(\u0026#34;Hello\u0026#34;, name) greet(\u0026#34;Monica\u0026#34;, \u0026#34;Luke\u0026#34;, \u0026#34;Steve\u0026#34;, \u0026#34;John\u0026#34;) Output\nHello Monica Hello Luke Hello Steve Hello John Here, we have called the function with multiple arguments. These arguments get wrapped up into a tuple before being passed into the function. Inside the function, we use a for loop to retrieve all the arguments back.\n Reference : https://www.programiz.com/python-programming/function-argument\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/advance_topic/iterators/",
	"title": "Iterators",
	"tags": [],
	"description": "",
	"content": " Source : https://www.programiz.com/python-programming/iterator\n Iterators are objects that can be iterated upon. In this tutorial, you will learn how iterator works and how you can build your own iterator using iter and next methods.\nIterators in Python Iterators are everywhere in Python. They are elegantly implemented within for loops, comprehensions, generators etc. but are hidden in plain sight.\nIterator in Python is simply an object that can be iterated upon. An object which will return data, one element at a time.\nTechnically speaking, a Python iterator object must implement two special methods, __iter__() and __next__(), collectively called the iterator protocol.\nAn object is called iterable if we can get an iterator from it. Most built-in containers in Python like: list, tuple, string etc. are iterables.\nThe iter() function (which in turn calls the __iter__() method) returns an iterator from them.\n Iterating Through an Iterator We use the next() function to manually iterate through all the items of an iterator. When we reach the end and there is no more data to be returned, it will raise the StopIteration Exception. Following is an example.\n# define a list my_list = [4, 7, 0, 3] # get an iterator using iter() my_iter = iter(my_list) # iterate through it using next() # Output: 4 print(next(my_iter)) # Output: 7 print(next(my_iter)) # next(obj) is same as obj.__next__() # Output: 0 print(my_iter.__next__()) # Output: 3 print(my_iter.__next__()) # This will raise error, no items left next(my_iter) Output\n4 7 0 3 Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 24, in \u0026lt;module\u0026gt; next(my_iter) StopIteration A more elegant way of automatically iterating is by using the for loop. Using this, we can iterate over any object that can return an iterator, for example list, string, file etc.\n\u0026gt;\u0026gt;\u0026gt; for element in my_list: ... print(element) ... 4 7 0 3  Working of for loop for Iterators As we see in the above example, the for loop was able to iterate automatically through the list.\nIn fact the for loop can iterate over any iterable. Let\u0026rsquo;s take a closer look at how the for loop is actually implemented in Python.\nfor element in iterable: # do something with element Is actually implemented as.\n# create an iterator object from that iterable iter_obj = iter(iterable) # infinite loop while True: try: # get the next item element = next(iter_obj) # do something with element except StopIteration: # if StopIteration is raised, break from loop break So internally, the for loop creates an iterator object, iter_obj by calling iter() on the iterable.\nIronically, this for loop is actually an infinite while loop.\nInside the loop, it calls next() to get the next element and executes the body of the for loop with this value. After all the items exhaust, StopIteration is raised which is internally caught and the loop ends. Note that any other kind of exception will pass through.\n Building Custom Iterators Building an iterator from scratch is easy in Python. We just have to implement the __iter__() and the __next__() methods.\nThe __iter__() method returns the iterator object itself. If required, some initialization can be performed.\nThe __next__() method must return the next item in the sequence. On reaching the end, and in subsequent calls, it must raise StopIteration.\nHere, we show an example that will give us the next power of 2 in each iteration. Power exponent starts from zero up to a user set number.\nclass PowTwo: \u0026#34;\u0026#34;\u0026#34;Class to implement an iterator of powers of two\u0026#34;\u0026#34;\u0026#34; def __init__(self, max=0): self.max = max def __iter__(self): self.n = 0 return self def __next__(self): if self.n \u0026lt;= self.max: result = 2 ** self.n self.n += 1 return result else: raise StopIteration # create an object numbers = PowTwo(3) # create an iterable from the object i = iter(numbers) # Using next to get to the next iterator element print(next(i)) print(next(i)) print(next(i)) print(next(i)) print(next(i)) Output\n1 2 4 8 Traceback (most recent call last): File \u0026#34;/home/bsoyuj/Desktop/Untitled-1.py\u0026#34;, line 32, in \u0026lt;module\u0026gt; print(next(i)) File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 18, in __next__ raise StopIteration StopIteration We can also use a for loop to iterate over our iterator class.\n\u0026gt;\u0026gt;\u0026gt; for i in PowTwo(5): ... print(i) ... 1 2 4 8 16 32  Python Infinite Iterators It is not necessary that the item in an iterator object has to be exhausted. There can be infinite iterators (which never ends). We must be careful when handling such iterators.\nHere is a simple example to demonstrate infinite iterators.\nThe built-in function iter() function can be called with two arguments where the first argument must be a callable object (function) and second is the sentinel. The iterator calls this function until the returned value is equal to the sentinel.\n\u0026gt;\u0026gt;\u0026gt; int() 0 \u0026gt;\u0026gt;\u0026gt; inf = iter(int,1) \u0026gt;\u0026gt;\u0026gt; next(inf) 0 \u0026gt;\u0026gt;\u0026gt; next(inf) 0 We can see that the int() function always returns 0. So passing it as iter(int,1) will return an iterator that calls int() until the returned value equals 1. This never happens and we get an infinite iterator.\nWe can also build our own infinite iterators. The following iterator will, theoretically, return all the odd numbers.\nclass InfIter: \u0026#34;\u0026#34;\u0026#34;Infinite iterator to return all odd numbers\u0026#34;\u0026#34;\u0026#34; def __iter__(self): self.num = 1 return self def __next__(self): num = self.num self.num += 2 return num A sample run would be as follows.\n\u0026gt;\u0026gt;\u0026gt; a = iter(InfIter()) \u0026gt;\u0026gt;\u0026gt; next(a) 1 \u0026gt;\u0026gt;\u0026gt; next(a) 3 \u0026gt;\u0026gt;\u0026gt; next(a) 5 \u0026gt;\u0026gt;\u0026gt; next(a) 7 And so on\u0026hellip;\nBe careful to include a terminating condition, when iterating over these types of infinite iterators.\nThe advantage of using iterators is that they save resources. Like shown above, we could get all the odd numbers without storing the entire number system in memory. We can have infinite items (theoretically) in finite memory.\nThere\u0026rsquo;s an easier way to create iterators in Python. To learn more visit: Python generators using yield.\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/",
	"title": "Learn Python",
	"tags": [],
	"description": "",
	"content": "Python is a powerful general-purpose programming language. It is used in web development, data science, creating software prototypes, and so on. Fortunately for beginners, Python has simple easy-to-use syntax. This makes Python an excellent language to learn to program for beginners.\nOur Python tutorial will guide you to learn Python one step at a time.\n Reference : https://www.programiz.com/python-programming\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/objects_class/oop/",
	"title": "Object Oriented Programming (OOP)",
	"tags": [],
	"description": "",
	"content": "In this tutorial, you’ll learn about Object-Oriented Programming (OOP) in Python and its fundamental concept with the help of examples.\nObject Oriented Programming Python is a multi-paradigm programming language. It supports different programming approaches.\nOne of the popular approaches to solve a programming problem is by creating objects. This is known as Object-Oriented Programming (OOP).\nAn object has two characteristics:\n attributes behavior  Let\u0026rsquo;s take an example:\nA parrot is can be an object,as it has the following properties:\n name, age, color as attributes singing, dancing as behavior  The concept of OOP in Python focuses on creating reusable code. This concept is also known as DRY (Don\u0026rsquo;t Repeat Yourself).\nIn Python, the concept of OOP follows some basic principles:\n Class A class is a blueprint for the object.\nWe can think of class as a sketch of a parrot with labels. It contains all the details about the name, colors, size etc. Based on these descriptions, we can study about the parrot. Here, a parrot is an object.\nThe example for class of parrot can be :\nclass Parrot: pass Here, we use the class keyword to define an empty class Parrot. From class, we construct instances. An instance is a specific object created from a particular class.\n Object An object (instance) is an instantiation of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.\nThe example for object of parrot class can be:\nobj = Parrot() Here, obj is an object of class Parrot.\nSuppose we have details of parrots. Now, we are going to show how to build the class and objects of parrots.\nExample 1: Creating Class and Object in Python class Parrot: # class attribute species = \u0026#34;bird\u0026#34; # instance attribute def __init__(self, name, age): self.name = name self.age = age # instantiate the Parrot class blu = Parrot(\u0026#34;Blu\u0026#34;, 10) woo = Parrot(\u0026#34;Woo\u0026#34;, 15) # access the class attributes print(\u0026#34;Blu is a {}\u0026#34;.format(blu.__class__.species)) print(\u0026#34;Woo is also a {}\u0026#34;.format(woo.__class__.species)) # access the instance attributes print(\u0026#34;{} is {} years old\u0026#34;.format( blu.name, blu.age)) print(\u0026#34;{} is {} years old\u0026#34;.format( woo.name, woo.age)) Output\nBlu is a bird Woo is also a bird Blu is 10 years old Woo is 15 years old In the above program, we created a class with the name Parrot. Then, we define attributes. The attributes are a characteristic of an object.\nThese attributes are defined inside the __init__ method of the class. It is the initializer method that is first run as soon as the object is created.\nThen, we create instances of the Parrot class. Here, blu and woo are references (value) to our new objects.\nWe can access the class attribute using __class__.species. Class attributes are the same for all instances of a class. Similarly, we access the instance attributes using blu.name and blu.age. However, instance attributes are different for every instance of a class.\nTo learn more about classes and objects, go to Python Classes and Objects\n Methods Methods are functions defined inside the body of a class. They are used to define the behaviors of an object.\nExample 2 : Creating Methods in Python class Parrot: # instance attributes def __init__(self, name, age): self.name = name self.age = age # instance method def sing(self, song): return \u0026#34;{} sings {}\u0026#34;.format(self.name, song) def dance(self): return \u0026#34;{} is now dancing\u0026#34;.format(self.name) # instantiate the object blu = Parrot(\u0026#34;Blu\u0026#34;, 10) # call our instance methods print(blu.sing(\u0026#34;\u0026#39;Happy\u0026#39;\u0026#34;)) print(blu.dance()) Output\nBlu sings \u0026#39;Happy\u0026#39; Blu is now dancing In the above program, we define two methods i.e sing() and dance(). These are called instance methods because they are called on an instance object i.e blu.\n Inheritance Inheritance is a way of creating a new class for using details of an existing class without modifying it. The newly formed class is a derived class (or child class). Similarly, the existing class is a base class (or parent class).\nExample 3: Use of Inheritance in Python # parent class class Bird: def __init__(self): print(\u0026#34;Bird is ready\u0026#34;) def whoisThis(self): print(\u0026#34;Bird\u0026#34;) def swim(self): print(\u0026#34;Swim faster\u0026#34;) # child class class Penguin(Bird): def __init__(self): # call super() function super().__init__() print(\u0026#34;Penguin is ready\u0026#34;) def whoisThis(self): print(\u0026#34;Penguin\u0026#34;) def run(self): print(\u0026#34;Run faster\u0026#34;) peggy = Penguin() peggy.whoisThis() peggy.swim() peggy.run() Output\nBird is ready Penguin is ready Penguin Swim faster Run faster In the above program, we created two classes i.e. Bird (parent class) and Penguin (child class). The child class inherits the functions of parent class. We can see this from the swim() method.\nAgain, the child class modified the behavior of the parent class. We can see this from the whoisThis() method. Furthermore, we extend the functions of the parent class, by creating a new run() method.\nAdditionally, we use the super() function inside the __init__() method. This allows us to run the __init__() method of the parent class inside the child class.\n Encapsulation Using OOP in Python, we can restrict access to methods and variables. This prevents data from direct modification which is called encapsulation. In Python, we denote private attributes using underscore as the prefix i.e single _ or double __.\nExample 4: Data Encapsulation in Python class Computer: def __init__(self): self.__maxprice = 900 def sell(self): print(\u0026#34;Selling Price: {}\u0026#34;.format(self.__maxprice)) def setMaxPrice(self, price): self.__maxprice = price c = Computer() c.sell() # change the price c.__maxprice = 1000 c.sell() # using setter function c.setMaxPrice(1000) c.sell() Output\nSelling Price: 900 Selling Price: 900 Selling Price: 1000 In the above program, we defined a Computer class.\nWe used __init__() method to store the maximum selling price of Computer. We tried to modify the price. However, we can\u0026rsquo;t change it because Python treats the __maxprice as private attributes.\nAs shown, to change the value, we have to use a setter function i.e setMaxPrice() which takes price as a parameter.\n Polymorphism Polymorphism is an ability (in OOP) to use a common interface for multiple forms (data types).\nSuppose, we need to color a shape, there are multiple shape options (rectangle, square, circle). However we could use the same method to color any shape. This concept is called Polymorphism.\nExample 5: Using Polymorphism in Python class Parrot: def fly(self): print(\u0026#34;Parrot can fly\u0026#34;) def swim(self): print(\u0026#34;Parrot can\u0026#39;t swim\u0026#34;) class Penguin: def fly(self): print(\u0026#34;Penguin can\u0026#39;t fly\u0026#34;) def swim(self): print(\u0026#34;Penguin can swim\u0026#34;) # common interface def flying_test(bird): bird.fly() #instantiate objects blu = Parrot() peggy = Penguin() # passing the object flying_test(blu) flying_test(peggy) Output\nParrot can fly Penguin can\u0026#39;t fly In the above program, we defined two classes Parrot and Penguin. Each of them have a common fly() method. However, their functions are different.\nTo use polymorphism, we created a common interface i.e flying_test() function that takes any object and calls the object\u0026rsquo;s fly() method. Thus, when we passed the blu and peggy objects in the flying_test() function, it ran effectively.\n Key Points to Remember:  Object-Oriented Programming makes the program easy to understand as well as efficient. Since the class is sharable, the code can be reused. Data is safe and secure with data abstraction. Polymorphism allows the same interface for different objects, so programmers can write efficient code.   Source : https://www.programiz.com/python-programming/object-oriented-programming\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/files/intro/",
	"title": "Page Index",
	"tags": [],
	"description": "",
	"content": "Page Index  Introduction Flow Control Function Data Types File Handling Object \u0026amp; Class Advanced Tutorials Date and Time About Python Programming Why learn Python ? How to learn Python? Python Resources   Reference : https://www.programiz.com/python-programming\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/cookbook/",
	"title": "Pandas Cookbook",
	"tags": [],
	"description": "",
	"content": " Reference : https://pandas.pydata.org\n This is a repository for short and sweet examples and links for useful pandas recipes. We encourage users to add to this documentation.\nAdding interesting links and/or inline examples to this section is a great First Pull Request.\nSimplified, condensed, new-user friendly, in-line examples have been inserted where possible to augment the Stack-Overflow and GitHub links. Many of the links contain expanded information, above what the in-line examples offer.\nPandas (pd) and Numpy (np) are the only two abbreviated imported modules. The rest are kept explicitly imported for newer users.\nThese examples are written for Python 3. Minor tweaks might be necessary for earlier python versions.\nIdioms These are some neat pandas idioms\nif-then/if-then-else on one column, and assignment to another one or more columns:\nIn [1]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ...: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ...: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]}) ...: In [2]: df Out[2]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 if-then… An if-then on one column Customarily, we import as follows:\nIn [3]: df.loc[df.AAA \u0026gt;= 5, \u0026#39;BBB\u0026#39;] = -1 In [4]: df Out[4]: AAA BBB CCC 0 4 10 100 1 5 -1 50 2 6 -1 -30 3 7 -1 -50 An if-then with assignment to 2 columns:\nIn [5]: df.loc[df.AAA \u0026gt;= 5, [\u0026#39;BBB\u0026#39;, \u0026#39;CCC\u0026#39;]] = 555 In [6]: df Out[6]: AAA BBB CCC 0 4 10 100 1 5 555 555 2 6 555 555 3 7 555 555 Add another line with different logic, to do the -else\nIn [7]: df.loc[df.AAA \u0026lt; 5, [\u0026#39;BBB\u0026#39;, \u0026#39;CCC\u0026#39;]] = 2000 In [8]: df Out[8]: AAA BBB CCC 0 4 2000 2000 1 5 555 555 2 6 555 555 3 7 555 555 Or use pandas where after you’ve set up a mask\nIn [9]: df_mask = pd.DataFrame({\u0026#39;AAA\u0026#39;: [True] * 4, ...: \u0026#39;BBB\u0026#39;: [False] * 4, ...: \u0026#39;CCC\u0026#39;: [True, False] * 2}) ...: In [10]: df.where(df_mask, -1000) Out[10]: AAA BBB CCC 0 4 -1000 2000 1 5 -1000 -1000 2 6 -1000 555 3 7 -1000 -1000 if-then-else using numpy’s where()\nIn [11]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ....: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ....: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]}) ....: In [12]: df Out[12]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 In [13]: df[\u0026#39;logic\u0026#39;] = np.where(df[\u0026#39;AAA\u0026#39;] \u0026gt; 5, \u0026#39;high\u0026#39;, \u0026#39;low\u0026#39;) In [14]: df Out[14]: AAA BBB CCC logic 0 4 10 100 low 1 5 20 50 low 2 6 30 -30 high 3 7 40 -50 high Splitting Split a frame with a boolean criterion\nIn [15]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ....: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ....: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]}) ....: In [16]: df Out[16]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 In [17]: df[df.AAA \u0026lt;= 5] Out[17]: AAA BBB CCC 0 4 10 100 1 5 20 50 In [18]: df[df.AAA \u0026gt; 5] Out[18]: AAA BBB CCC 2 6 30 -30 3 7 40 -50 Building criteria Select with multi-column criteria\nIn [19]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ....: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ....: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]}) ....: In [20]: df Out[20]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 …and (without assignment returns a Series)\nIn [21]: df.loc[(df[\u0026#39;BBB\u0026#39;] \u0026lt; 25) \u0026amp; (df[\u0026#39;CCC\u0026#39;] \u0026gt;= -40), \u0026#39;AAA\u0026#39;] Out[21]: 0 4 1 5 Name: AAA, dtype: int64 …or (without assignment returns a Series)\nIn [22]: df.loc[(df[\u0026#39;BBB\u0026#39;] \u0026gt; 25) | (df[\u0026#39;CCC\u0026#39;] \u0026gt;= -40), \u0026#39;AAA\u0026#39;] Out[22]: 0 4 1 5 2 6 3 7 Name: AAA, dtype: int64 …or (with assignment modifies the DataFrame.)\nIn [23]: df.loc[(df[\u0026#39;BBB\u0026#39;] \u0026gt; 25) | (df[\u0026#39;CCC\u0026#39;] \u0026gt;= 75), \u0026#39;AAA\u0026#39;] = 0.1 In [24]: df Out[24]: AAA BBB CCC 0 0.1 10 100 1 5.0 20 50 2 0.1 30 -30 3 0.1 40 -50 Select rows with data closest to certain value using argsort\nIn [25]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ....: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ....: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]}) ....: In [26]: df Out[26]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 In [27]: aValue = 43.0 In [28]: df.loc[(df.CCC - aValue).abs().argsort()] Out[28]: AAA BBB CCC 1 5 20 50 0 4 10 100 2 6 30 -30 3 7 40 -50 Dynamically reduce a list of criteria using a binary operators\nIn [29]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ....: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ....: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]}) ....: In [30]: df Out[30]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 In [31]: Crit1 = df.AAA \u0026lt;= 5.5 In [32]: Crit2 = df.BBB == 10.0 In [33]: Crit3 = df.CCC \u0026gt; -40.0 One could hard code:\nIn [34]: AllCrit = Crit1 \u0026amp; Crit2 \u0026amp; Crit3 …Or it can be done with a list of dynamically built criteria\nIn [35]: import functools In [36]: CritList = [Crit1, Crit2, Crit3] In [37]: AllCrit = functools.reduce(lambda x, y: x \u0026amp; y, CritList) In [38]: df[AllCrit] Out[38]: AAA BBB CCC 0 4 10 100 Selection Dataframes The indexing docs.\nUsing both row labels and value conditionals\nIn [39]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ....: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ....: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]}) ....: In [40]: df Out[40]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 In [41]: df[(df.AAA \u0026lt;= 6) \u0026amp; (df.index.isin([0, 2, 4]))] Out[41]: AAA BBB CCC 0 4 10 100 2 6 30 -30 Use loc for label-oriented slicing and iloc positional slicing\nIn [42]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ....: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ....: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]}, ....: index=[\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;boo\u0026#39;, \u0026#39;kar\u0026#39;]) ....: There are 2 explicit slicing methods, with a third general case\n  Positional-oriented (Python slicing style : exclusive of end)\n  Label-oriented (Non-Python slicing style : inclusive of end)\n  General (Either slicing style : depends on if the slice contains labels or positions)\n  In [43]: df.loc[\u0026#39;bar\u0026#39;:\u0026#39;kar\u0026#39;] # Label Out[43]: AAA BBB CCC bar 5 20 50 boo 6 30 -30 kar 7 40 -50 # Generic In [44]: df[0:3] Out[44]: AAA BBB CCC foo 4 10 100 bar 5 20 50 boo 6 30 -30 In [45]: df[\u0026#39;bar\u0026#39;:\u0026#39;kar\u0026#39;] Out[45]: AAA BBB CCC bar 5 20 50 boo 6 30 -30 kar 7 40 -50 Ambiguity arises when an index consists of integers with a non-zero start or non-unit increment.\nIn [46]: data = {\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ....: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ....: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]} ....: In [47]: df2 = pd.DataFrame(data=data, index=[1, 2, 3, 4]) # Note index starts at 1. In [48]: df2.iloc[1:3] # Position-oriented Out[48]: AAA BBB CCC 2 5 20 50 3 6 30 -30 In [49]: df2.loc[1:3] # Label-oriented Out[49]: AAA BBB CCC 1 4 10 100 2 5 20 50 3 6 30 -30 Using inverse operator (~) to take the complement of a mask\nIn [50]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [4, 5, 6, 7], ....: \u0026#39;BBB\u0026#39;: [10, 20, 30, 40], ....: \u0026#39;CCC\u0026#39;: [100, 50, -30, -50]}) ....: In [51]: df Out[51]: AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 In [52]: df[~((df.AAA \u0026lt;= 6) \u0026amp; (df.index.isin([0, 2, 4])))] Out[52]: AAA BBB CCC 1 5 20 50 3 7 40 -50 New columns Efficiently and dynamically creating new columns using applymap\nIn [53]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [1, 2, 1, 3], ....: \u0026#39;BBB\u0026#39;: [1, 1, 2, 2], ....: \u0026#39;CCC\u0026#39;: [2, 1, 3, 1]}) ....: In [54]: df Out[54]: AAA BBB CCC 0 1 1 2 1 2 1 1 2 1 2 3 3 3 2 1 In [55]: source_cols = df.columns # Or some subset would work too In [56]: new_cols = [str(x) + \u0026#34;_cat\u0026#34; for x in source_cols] In [57]: categories = {1: \u0026#39;Alpha\u0026#39;, 2: \u0026#39;Beta\u0026#39;, 3: \u0026#39;Charlie\u0026#39;} In [58]: df[new_cols] = df[source_cols].applymap(categories.get) In [59]: df Out[59]: AAA BBB CCC AAA_cat BBB_cat CCC_cat 0 1 1 2 Alpha Alpha Beta 1 2 1 1 Beta Alpha Alpha 2 1 2 3 Alpha Beta Charlie 3 3 2 1 Charlie Beta Alpha Keep other columns when using min() with groupby\nIn [60]: df = pd.DataFrame({\u0026#39;AAA\u0026#39;: [1, 1, 1, 2, 2, 2, 3, 3], ....: \u0026#39;BBB\u0026#39;: [2, 1, 3, 4, 5, 1, 2, 3]}) ....: In [61]: df Out[61]: AAA BBB 0 1 2 1 1 1 2 1 3 3 2 4 4 2 5 5 2 1 6 3 2 7 3 3 Method 1 : idxmin() to get the index of the minimums\nIn [62]: df.loc[df.groupby(\u0026#34;AAA\u0026#34;)[\u0026#34;BBB\u0026#34;].idxmin()] Out[62]: AAA BBB 1 1 1 5 2 1 6 3 2 Method 2 : sort then take first of each\nIn [63]: df.sort_values(by=\u0026#34;BBB\u0026#34;).groupby(\u0026#34;AAA\u0026#34;, as_index=False).first() Out[63]: AAA BBB 0 1 1 1 2 1 2 3 2 Notice the same results, with the exception of the index.\nMultiindexing The multindexing docs.\nCreating a MultiIndex from a labeled frame\nIn [64]: df = pd.DataFrame({\u0026#39;row\u0026#39;: [0, 1, 2], ....: \u0026#39;One_X\u0026#39;: [1.1, 1.1, 1.1], ....: \u0026#39;One_Y\u0026#39;: [1.2, 1.2, 1.2], ....: \u0026#39;Two_X\u0026#39;: [1.11, 1.11, 1.11], ....: \u0026#39;Two_Y\u0026#39;: [1.22, 1.22, 1.22]}) ....: In [65]: df Out[65]: row One_X One_Y Two_X Two_Y 0 0 1.1 1.2 1.11 1.22 1 1 1.1 1.2 1.11 1.22 2 2 1.1 1.2 1.11 1.22 # As Labelled Index In [66]: df = df.set_index(\u0026#39;row\u0026#39;) In [67]: df Out[67]: One_X One_Y Two_X Two_Y row 0 1.1 1.2 1.11 1.22 1 1.1 1.2 1.11 1.22 2 1.1 1.2 1.11 1.22 # With Hierarchical Columns In [68]: df.columns = pd.MultiIndex.from_tuples([tuple(c.split(\u0026#39;_\u0026#39;)) ....: for c in df.columns]) ....: In [69]: df Out[69]: One Two X Y X Y row 0 1.1 1.2 1.11 1.22 1 1.1 1.2 1.11 1.22 2 1.1 1.2 1.11 1.22 # Now stack \u0026amp; Reset In [70]: df = df.stack(0).reset_index(1) In [71]: df Out[71]: level_1 X Y row 0 One 1.10 1.20 0 Two 1.11 1.22 1 One 1.10 1.20 1 Two 1.11 1.22 2 One 1.10 1.20 2 Two 1.11 1.22 # And fix the labels (Notice the label \u0026#39;level_1\u0026#39; got added automatically) In [72]: df.columns = [\u0026#39;Sample\u0026#39;, \u0026#39;All_X\u0026#39;, \u0026#39;All_Y\u0026#39;] In [73]: df Out[73]: Sample All_X All_Y row 0 One 1.10 1.20 0 Two 1.11 1.22 1 One 1.10 1.20 1 Two 1.11 1.22 2 One 1.10 1.20 2 Two 1.11 1.22 Arithmetic Performing arithmetic with a MultiIndex that needs broadcasting\nIn [74]: cols = pd.MultiIndex.from_tuples([(x, y) for x in [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] ....: for y in [\u0026#39;O\u0026#39;, \u0026#39;I\u0026#39;]]) ....: In [75]: df = pd.DataFrame(np.random.randn(2, 6), index=[\u0026#39;n\u0026#39;, \u0026#39;m\u0026#39;], columns=cols) In [76]: df Out[76]: A B C O I O I O I n 0.469112 -0.282863 -1.509059 -1.135632 1.212112 -0.173215 m 0.119209 -1.044236 -0.861849 -2.104569 -0.494929 1.071804 In [77]: df = df.div(df[\u0026#39;C\u0026#39;], level=1) In [78]: df Out[78]: A B C O I O I O I n 0.387021 1.633022 -1.244983 6.556214 1.0 1.0 m -0.240860 -0.974279 1.741358 -1.963577 1.0 1.0 Slicing Slicing a MultiIndex with xs\nIn [79]: coords = [(\u0026#39;AA\u0026#39;, \u0026#39;one\u0026#39;), (\u0026#39;AA\u0026#39;, \u0026#39;six\u0026#39;), (\u0026#39;BB\u0026#39;, \u0026#39;one\u0026#39;), (\u0026#39;BB\u0026#39;, \u0026#39;two\u0026#39;), ....: (\u0026#39;BB\u0026#39;, \u0026#39;six\u0026#39;)] ....: In [80]: index = pd.MultiIndex.from_tuples(coords) In [81]: df = pd.DataFrame([11, 22, 33, 44, 55], index, [\u0026#39;MyData\u0026#39;]) In [82]: df Out[82]: MyData AA one 11 six 22 BB one 33 two 44 six 55 To take the cross section of the 1st level and 1st axis the index:\n# Note : level and axis are optional, and default to zero In [83]: df.xs(\u0026#39;BB\u0026#39;, level=0, axis=0) Out[83]: MyData one 33 two 44 six 55 …and now the 2nd level of the 1st axis.\nIn [84]: df.xs(\u0026#39;six\u0026#39;, level=1, axis=0) Out[84]: MyData AA 22 BB 55 Slicing a MultiIndex with xs, method #2\nIn [85]: import itertools In [86]: index = list(itertools.product([\u0026#39;Ada\u0026#39;, \u0026#39;Quinn\u0026#39;, \u0026#39;Violet\u0026#39;], ....: [\u0026#39;Comp\u0026#39;, \u0026#39;Math\u0026#39;, \u0026#39;Sci\u0026#39;])) ....: In [87]: headr = list(itertools.product([\u0026#39;Exams\u0026#39;, \u0026#39;Labs\u0026#39;], [\u0026#39;I\u0026#39;, \u0026#39;II\u0026#39;])) In [88]: indx = pd.MultiIndex.from_tuples(index, names=[\u0026#39;Student\u0026#39;, \u0026#39;Course\u0026#39;]) In [89]: cols = pd.MultiIndex.from_tuples(headr) # Notice these are un-named In [90]: data = [[70 + x + y + (x * y) % 3 for x in range(4)] for y in range(9)] In [91]: df = pd.DataFrame(data, indx, cols) In [92]: df Out[92]: Exams Labs I II I II Student Course Ada Comp 70 71 72 73 Math 71 73 75 74 Sci 72 75 75 75 Quinn Comp 73 74 75 76 Math 74 76 78 77 Sci 75 78 78 78 Violet Comp 76 77 78 79 Math 77 79 81 80 Sci 78 81 81 81 In [93]: All = slice(None) In [94]: df.loc[\u0026#39;Violet\u0026#39;] Out[94]: Exams Labs I II I II Course Comp 76 77 78 79 Math 77 79 81 80 Sci 78 81 81 81 In [95]: df.loc[(All, \u0026#39;Math\u0026#39;), All] Out[95]: Exams Labs I II I II Student Course Ada Math 71 73 75 74 Quinn Math 74 76 78 77 Violet Math 77 79 81 80 In [96]: df.loc[(slice(\u0026#39;Ada\u0026#39;, \u0026#39;Quinn\u0026#39;), \u0026#39;Math\u0026#39;), All] Out[96]: Exams Labs I II I II Student Course Ada Math 71 73 75 74 Quinn Math 74 76 78 77 In [97]: df.loc[(All, \u0026#39;Math\u0026#39;), (\u0026#39;Exams\u0026#39;)] Out[97]: I II Student Course Ada Math 71 73 Quinn Math 74 76 Violet Math 77 79 In [98]: df.loc[(All, \u0026#39;Math\u0026#39;), (All, \u0026#39;II\u0026#39;)] Out[98]: Exams Labs II II Student Course Ada Math 73 74 Quinn Math 76 77 Violet Math 79 80 Setting portions of a MultiIndex with xs\nSorting Sort by specific column or an ordered list of columns, with a MultiIndex\nIn [99]: df.sort_values(by=(\u0026#39;Labs\u0026#39;, \u0026#39;II\u0026#39;), ascending=False) Out[99]: Exams Labs I II I II Student Course Violet Sci 78 81 81 81 Math 77 79 81 80 Comp 76 77 78 79 Quinn Sci 75 78 78 78 Math 74 76 78 77 Comp 73 74 75 76 Ada Sci 72 75 75 75 Math 71 73 75 74 Comp 70 71 72 73 Partial selection, the need for sortedness;\nLevels Prepending a level to a multiindex\nFlatten Hierarchical columns\nMissing data The missing data docs.\nFill forward a reversed timeseries\nIn [100]: df = pd.DataFrame(np.random.randn(6, 1), .....: index=pd.date_range(\u0026#39;2013-08-01\u0026#39;, periods=6, freq=\u0026#39;B\u0026#39;), .....: columns=list(\u0026#39;A\u0026#39;)) .....: In [101]: df.loc[df.index[3], \u0026#39;A\u0026#39;] = np.nan In [102]: df Out[102]: A 2013-08-01 0.721555 2013-08-02 -0.706771 2013-08-05 -1.039575 2013-08-06 NaN 2013-08-07 -0.424972 2013-08-08 0.567020 In [103]: df.reindex(df.index[::-1]).ffill() Out[103]: A 2013-08-08 0.567020 2013-08-07 -0.424972 2013-08-06 -0.424972 2013-08-05 -1.039575 2013-08-02 -0.706771 2013-08-01 0.721555 cumsum reset at NaN values\nReplace Using replace with backrefs\nGrouping The grouping docs.\nBasic grouping with apply\nUnlike agg, apply’s callable is passed a sub-DataFrame which gives you access to all the columns\nIn [104]: df = pd.DataFrame({\u0026#39;animal\u0026#39;: \u0026#39;cat dog cat fish dog cat cat\u0026#39;.split(), .....: \u0026#39;size\u0026#39;: list(\u0026#39;SSMMMLL\u0026#39;), .....: \u0026#39;weight\u0026#39;: [8, 10, 11, 1, 20, 12, 12], .....: \u0026#39;adult\u0026#39;: [False] * 5 + [True] * 2}) .....: In [105]: df Out[105]: animal size weight adult 0 cat S 8 False 1 dog S 10 False 2 cat M 11 False 3 fish M 1 False 4 dog M 20 False 5 cat L 12 True 6 cat L 12 True # List the size of the animals with the highest weight. In [106]: df.groupby(\u0026#39;animal\u0026#39;).apply(lambda subf: subf[\u0026#39;size\u0026#39;][subf[\u0026#39;weight\u0026#39;].idxmax()]) Out[106]: animal cat L dog M fish M dtype: object Using get_group\nIn [107]: gb = df.groupby([\u0026#39;animal\u0026#39;]) In [108]: gb.get_group(\u0026#39;cat\u0026#39;) Out[108]: animal size weight adult 0 cat S 8 False 2 cat M 11 False 5 cat L 12 True 6 cat L 12 True Apply to different items in a group\nIn [109]: def GrowUp(x): .....: avg_weight = sum(x[x[\u0026#39;size\u0026#39;] == \u0026#39;S\u0026#39;].weight * 1.5) .....: avg_weight += sum(x[x[\u0026#39;size\u0026#39;] == \u0026#39;M\u0026#39;].weight * 1.25) .....: avg_weight += sum(x[x[\u0026#39;size\u0026#39;] == \u0026#39;L\u0026#39;].weight) .....: avg_weight /= len(x) .....: return pd.Series([\u0026#39;L\u0026#39;, avg_weight, True], .....: index=[\u0026#39;size\u0026#39;, \u0026#39;weight\u0026#39;, \u0026#39;adult\u0026#39;]) .....: In [110]: expected_df = gb.apply(GrowUp) In [111]: expected_df Out[111]: size weight adult animal cat L 12.4375 True dog L 20.0000 True fish L 1.2500 True Expanding apply\nIn [112]: S = pd.Series([i / 100.0 for i in range(1, 11)]) In [113]: def cum_ret(x, y): .....: return x * (1 + y) .....: In [114]: def red(x): .....: return functools.reduce(cum_ret, x, 1.0) .....: In [115]: S.expanding().apply(red, raw=True) Out[115]: 0 1.010000 1 1.030200 2 1.061106 3 1.103550 4 1.158728 5 1.228251 6 1.314229 7 1.419367 8 1.547110 9 1.701821 dtype: float64 Replacing some values with mean of the rest of a group\nIn [116]: df = pd.DataFrame({\u0026#39;A\u0026#39;: [1, 1, 2, 2], \u0026#39;B\u0026#39;: [1, -1, 1, 2]}) In [117]: gb = df.groupby(\u0026#39;A\u0026#39;) In [118]: def replace(g): .....: mask = g \u0026lt; 0 .....: return g.where(mask, g[~mask].mean()) .....: In [119]: gb.transform(replace) Out[119]: B 0 1.0 1 -1.0 2 1.5 3 1.5 Sort groups by aggregated data\nIn [120]: df = pd.DataFrame({\u0026#39;code\u0026#39;: [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;] * 2, .....: \u0026#39;data\u0026#39;: [0.16, -0.21, 0.33, 0.45, -0.59, 0.62], .....: \u0026#39;flag\u0026#39;: [False, True] * 3}) .....: In [121]: code_groups = df.groupby(\u0026#39;code\u0026#39;) In [122]: agg_n_sort_order = code_groups[[\u0026#39;data\u0026#39;]].transform(sum).sort_values(by=\u0026#39;data\u0026#39;) In [123]: sorted_df = df.loc[agg_n_sort_order.index] In [124]: sorted_df Out[124]: code data flag 1 bar -0.21 True 4 bar -0.59 False 0 foo 0.16 False 3 foo 0.45 True 2 baz 0.33 False 5 baz 0.62 True Create multiple aggregated columns\nIn [125]: rng = pd.date_range(start=\u0026#34;2014-10-07\u0026#34;, periods=10, freq=\u0026#39;2min\u0026#39;) In [126]: ts = pd.Series(data=list(range(10)), index=rng) In [127]: def MyCust(x): .....: if len(x) \u0026gt; 2: .....: return x[1] * 1.234 .....: return pd.NaT .....: In [128]: mhc = {\u0026#39;Mean\u0026#39;: np.mean, \u0026#39;Max\u0026#39;: np.max, \u0026#39;Custom\u0026#39;: MyCust} In [129]: ts.resample(\u0026#34;5min\u0026#34;).apply(mhc) Out[129]: Mean 2014-10-07 00:00:00 1 2014-10-07 00:05:00 3.5 2014-10-07 00:10:00 6 2014-10-07 00:15:00 8.5 Max 2014-10-07 00:00:00 2 2014-10-07 00:05:00 4 2014-10-07 00:10:00 7 2014-10-07 00:15:00 9 Custom 2014-10-07 00:00:00 1.234 2014-10-07 00:05:00 NaT 2014-10-07 00:10:00 7.404 2014-10-07 00:15:00 NaT dtype: object In [130]: ts Out[130]: 2014-10-07 00:00:00 0 2014-10-07 00:02:00 1 2014-10-07 00:04:00 2 2014-10-07 00:06:00 3 2014-10-07 00:08:00 4 2014-10-07 00:10:00 5 2014-10-07 00:12:00 6 2014-10-07 00:14:00 7 2014-10-07 00:16:00 8 2014-10-07 00:18:00 9 Freq: 2T, dtype: int64 Create a value counts column and reassign back to the DataFrame\nIn [131]: df = pd.DataFrame({\u0026#39;Color\u0026#39;: \u0026#39;Red Red Red Blue\u0026#39;.split(), .....: \u0026#39;Value\u0026#39;: [100, 150, 50, 50]}) .....: In [132]: df Out[132]: Color Value 0 Red 100 1 Red 150 2 Red 50 3 Blue 50 In [133]: df[\u0026#39;Counts\u0026#39;] = df.groupby([\u0026#39;Color\u0026#39;]).transform(len) In [134]: df Out[134]: Color Value Counts 0 Red 100 3 1 Red 150 3 2 Red 50 3 3 Blue 50 1 Shift groups of the values in a column based on the index\nIn [135]: df = pd.DataFrame({\u0026#39;line_race\u0026#39;: [10, 10, 8, 10, 10, 8], .....: \u0026#39;beyer\u0026#39;: [99, 102, 103, 103, 88, 100]}, .....: index=[\u0026#39;Last Gunfighter\u0026#39;, \u0026#39;Last Gunfighter\u0026#39;, .....: \u0026#39;Last Gunfighter\u0026#39;, \u0026#39;Paynter\u0026#39;, \u0026#39;Paynter\u0026#39;, .....: \u0026#39;Paynter\u0026#39;]) .....: In [136]: df Out[136]: line_race beyer Last Gunfighter 10 99 Last Gunfighter 10 102 Last Gunfighter 8 103 Paynter 10 103 Paynter 10 88 Paynter 8 100 In [137]: df[\u0026#39;beyer_shifted\u0026#39;] = df.groupby(level=0)[\u0026#39;beyer\u0026#39;].shift(1) In [138]: df Out[138]: line_race beyer beyer_shifted Last Gunfighter 10 99 NaN Last Gunfighter 10 102 99.0 Last Gunfighter 8 103 102.0 Paynter 10 103 NaN Paynter 10 88 103.0 Paynter 8 100 88.0 Select row with maximum value from each group\nIn [139]: df = pd.DataFrame({\u0026#39;host\u0026#39;: [\u0026#39;other\u0026#39;, \u0026#39;other\u0026#39;, \u0026#39;that\u0026#39;, \u0026#39;this\u0026#39;, \u0026#39;this\u0026#39;], .....: \u0026#39;service\u0026#39;: [\u0026#39;mail\u0026#39;, \u0026#39;web\u0026#39;, \u0026#39;mail\u0026#39;, \u0026#39;mail\u0026#39;, \u0026#39;web\u0026#39;], .....: \u0026#39;no\u0026#39;: [1, 2, 1, 2, 1]}).set_index([\u0026#39;host\u0026#39;, \u0026#39;service\u0026#39;]) .....: In [140]: mask = df.groupby(level=0).agg(\u0026#39;idxmax\u0026#39;) In [141]: df_count = df.loc[mask[\u0026#39;no\u0026#39;]].reset_index() In [142]: df_count Out[142]: host service no 0 other web 2 1 that mail 1 2 this mail 2 Grouping like Python’s itertools.groupby\nIn [143]: df = pd.DataFrame([0, 1, 0, 1, 1, 1, 0, 1, 1], columns=[\u0026#39;A\u0026#39;]) In [144]: df[\u0026#39;A\u0026#39;].groupby((df[\u0026#39;A\u0026#39;] != df[\u0026#39;A\u0026#39;].shift()).cumsum()).groups Out[144]: {1: [0], 2: [1], 3: [2], 4: [3, 4, 5], 5: [6], 6: [7, 8]} In [145]: df[\u0026#39;A\u0026#39;].groupby((df[\u0026#39;A\u0026#39;] != df[\u0026#39;A\u0026#39;].shift()).cumsum()).cumsum() Out[145]: 0 0 1 1 2 0 3 1 4 2 5 3 6 0 7 1 8 2 Name: A, dtype: int64 Expanding data Alignment and to-date\nRolling Computation window based on values instead of counts\nRolling Mean by Time Interval\nSplitting Splitting a frame\nCreate a list of dataframes, split using a delineation based on logic included in rows.\nIn [146]: df = pd.DataFrame(data={\u0026#39;Case\u0026#39;: [\u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;, .....: \u0026#39;A\u0026#39;], .....: \u0026#39;Data\u0026#39;: np.random.randn(9)}) .....: In [147]: dfs = list(zip(*df.groupby((1 * (df[\u0026#39;Case\u0026#39;] == \u0026#39;B\u0026#39;)).cumsum() .....: .rolling(window=3, min_periods=1).median())))[-1] .....: In [148]: dfs[0] Out[148]: Case Data 0 A 0.276232 1 A -1.087401 2 A -0.673690 3 B 0.113648 In [149]: dfs[1] Out[149]: Case Data 4 A -1.478427 5 A 0.524988 6 B 0.404705 In [150]: dfs[2] Out[150]: Case Data 7 A 0.577046 8 A -1.715002 Pivot The Pivot docs.\nPartial sums and subtotals\nIn [151]: df = pd.DataFrame(data={\u0026#39;Province\u0026#39;: [\u0026#39;ON\u0026#39;, \u0026#39;QC\u0026#39;, \u0026#39;BC\u0026#39;, \u0026#39;AL\u0026#39;, \u0026#39;AL\u0026#39;, \u0026#39;MN\u0026#39;, \u0026#39;ON\u0026#39;], .....: \u0026#39;City\u0026#39;: [\u0026#39;Toronto\u0026#39;, \u0026#39;Montreal\u0026#39;, \u0026#39;Vancouver\u0026#39;, .....: \u0026#39;Calgary\u0026#39;, \u0026#39;Edmonton\u0026#39;, \u0026#39;Winnipeg\u0026#39;, .....: \u0026#39;Windsor\u0026#39;], .....: \u0026#39;Sales\u0026#39;: [13, 6, 16, 8, 4, 3, 1]}) .....: In [152]: table = pd.pivot_table(df, values=[\u0026#39;Sales\u0026#39;], index=[\u0026#39;Province\u0026#39;], .....: columns=[\u0026#39;City\u0026#39;], aggfunc=np.sum, margins=True) .....: In [153]: table.stack(\u0026#39;City\u0026#39;) Out[153]: Sales Province City AL All 12.0 Calgary 8.0 Edmonton 4.0 BC All 16.0 Vancouver 16.0 ... ... All Montreal 6.0 Toronto 13.0 Vancouver 16.0 Windsor 1.0 Winnipeg 3.0 [20 rows x 1 columns] Frequency table like plyr in R\nIn [154]: grades = [48, 99, 75, 80, 42, 80, 72, 68, 36, 78] In [155]: df = pd.DataFrame({\u0026#39;ID\u0026#39;: [\u0026#34;x%d\u0026#34; % r for r in range(10)], .....: \u0026#39;Gender\u0026#39;: [\u0026#39;F\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;F\u0026#39;, .....: \u0026#39;M\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;M\u0026#39;], .....: \u0026#39;ExamYear\u0026#39;: [\u0026#39;2007\u0026#39;, \u0026#39;2007\u0026#39;, \u0026#39;2007\u0026#39;, \u0026#39;2008\u0026#39;, \u0026#39;2008\u0026#39;, .....: \u0026#39;2008\u0026#39;, \u0026#39;2008\u0026#39;, \u0026#39;2009\u0026#39;, \u0026#39;2009\u0026#39;, \u0026#39;2009\u0026#39;], .....: \u0026#39;Class\u0026#39;: [\u0026#39;algebra\u0026#39;, \u0026#39;stats\u0026#39;, \u0026#39;bio\u0026#39;, \u0026#39;algebra\u0026#39;, .....: \u0026#39;algebra\u0026#39;, \u0026#39;stats\u0026#39;, \u0026#39;stats\u0026#39;, \u0026#39;algebra\u0026#39;, .....: \u0026#39;bio\u0026#39;, \u0026#39;bio\u0026#39;], .....: \u0026#39;Participated\u0026#39;: [\u0026#39;yes\u0026#39;, \u0026#39;yes\u0026#39;, \u0026#39;yes\u0026#39;, \u0026#39;yes\u0026#39;, \u0026#39;no\u0026#39;, .....: \u0026#39;yes\u0026#39;, \u0026#39;yes\u0026#39;, \u0026#39;yes\u0026#39;, \u0026#39;yes\u0026#39;, \u0026#39;yes\u0026#39;], .....: \u0026#39;Passed\u0026#39;: [\u0026#39;yes\u0026#39; if x \u0026gt; 50 else \u0026#39;no\u0026#39; for x in grades], .....: \u0026#39;Employed\u0026#39;: [True, True, True, False, .....: False, False, False, True, True, False], .....: \u0026#39;Grade\u0026#39;: grades}) .....: In [156]: df.groupby(\u0026#39;ExamYear\u0026#39;).agg({\u0026#39;Participated\u0026#39;: lambda x: x.value_counts()[\u0026#39;yes\u0026#39;], .....: \u0026#39;Passed\u0026#39;: lambda x: sum(x == \u0026#39;yes\u0026#39;), .....: \u0026#39;Employed\u0026#39;: lambda x: sum(x), .....: \u0026#39;Grade\u0026#39;: lambda x: sum(x) / len(x)}) .....: Out[156]: Participated Passed Employed Grade ExamYear 2007 3 2 3 74.000000 2008 3 3 0 68.500000 2009 3 2 2 60.666667 Plot pandas DataFrame with year over year data\nTo create year and month cross tabulation:\nIn [157]: df = pd.DataFrame({\u0026#39;value\u0026#39;: np.random.randn(36)}, .....: index=pd.date_range(\u0026#39;2011-01-01\u0026#39;, freq=\u0026#39;M\u0026#39;, periods=36)) .....: In [158]: pd.pivot_table(df, index=df.index.month, columns=df.index.year, .....: values=\u0026#39;value\u0026#39;, aggfunc=\u0026#39;sum\u0026#39;) .....: Out[158]: 2011 2012 2013 1 -1.039268 -0.968914 2.565646 2 -0.370647 -1.294524 1.431256 3 -1.157892 0.413738 1.340309 4 -1.344312 0.276662 -1.170299 5 0.844885 -0.472035 -0.226169 6 1.075770 -0.013960 0.410835 7 -0.109050 -0.362543 0.813850 8 1.643563 -0.006154 0.132003 9 -1.469388 -0.923061 -0.827317 10 0.357021 0.895717 -0.076467 11 -0.674600 0.805244 -1.187678 12 -1.776904 -1.206412 1.130127 Apply Rolling apply to organize - Turning embedded lists into a MultiIndex frame\nIn [159]: df = pd.DataFrame(data={\u0026#39;A\u0026#39;: [[2, 4, 8, 16], [100, 200], [10, 20, 30]], .....: \u0026#39;B\u0026#39;: [[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], [\u0026#39;jj\u0026#39;, \u0026#39;kk\u0026#39;], [\u0026#39;ccc\u0026#39;]]}, .....: index=[\u0026#39;I\u0026#39;, \u0026#39;II\u0026#39;, \u0026#39;III\u0026#39;]) .....: In [160]: def SeriesFromSubList(aList): .....: return pd.Series(aList) .....: In [161]: df_orgz = pd.concat({ind: row.apply(SeriesFromSubList) .....: for ind, row in df.iterrows()}) .....: In [162]: df_orgz Out[162]: 0 1 2 3 I A 2 4 8 16.0 B a b c NaN II A 100 200 NaN NaN B jj kk NaN NaN III A 10 20 30 NaN B ccc NaN NaN NaN Rolling apply with a DataFrame returning a Series\nRolling Apply to multiple columns where function calculates a Series before a Scalar from the Series is returned\nIn [163]: df = pd.DataFrame(data=np.random.randn(2000, 2) / 10000, .....: index=pd.date_range(\u0026#39;2001-01-01\u0026#39;, periods=2000), .....: columns=[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]) .....: In [164]: df Out[164]: A B 2001-01-01 -0.000144 -0.000141 2001-01-02 0.000161 0.000102 2001-01-03 0.000057 0.000088 2001-01-04 -0.000221 0.000097 2001-01-05 -0.000201 -0.000041 ... ... ... 2006-06-19 0.000040 -0.000235 2006-06-20 -0.000123 -0.000021 2006-06-21 -0.000113 0.000114 2006-06-22 0.000136 0.000109 2006-06-23 0.000027 0.000030 [2000 rows x 2 columns] In [165]: def gm(df, const): .....: v = ((((df[\u0026#39;A\u0026#39;] + df[\u0026#39;B\u0026#39;]) + 1).cumprod()) - 1) * const .....: return v.iloc[-1] .....: In [166]: s = pd.Series({df.index[i]: gm(df.iloc[i:min(i + 51, len(df) - 1)], 5) .....: for i in range(len(df) - 50)}) .....: In [167]: s Out[167]: 2001-01-01 0.000930 2001-01-02 0.002615 2001-01-03 0.001281 2001-01-04 0.001117 2001-01-05 0.002772 ... 2006-04-30 0.003296 2006-05-01 0.002629 2006-05-02 0.002081 2006-05-03 0.004247 2006-05-04 0.003928 Length: 1950, dtype: float64 Rolling apply with a DataFrame returning a Scalar\nRolling Apply to multiple columns where function returns a Scalar (Volume Weighted Average Price)\nIn [168]: rng = pd.date_range(start=\u0026#39;2014-01-01\u0026#39;, periods=100) In [169]: df = pd.DataFrame({\u0026#39;Open\u0026#39;: np.random.randn(len(rng)), .....: \u0026#39;Close\u0026#39;: np.random.randn(len(rng)), .....: \u0026#39;Volume\u0026#39;: np.random.randint(100, 2000, len(rng))}, .....: index=rng) .....: In [170]: df Out[170]: Open Close Volume 2014-01-01 -1.611353 -0.492885 1219 2014-01-02 -3.000951 0.445794 1054 2014-01-03 -0.138359 -0.076081 1381 2014-01-04 0.301568 1.198259 1253 2014-01-05 0.276381 -0.669831 1728 ... ... ... ... 2014-04-06 -0.040338 0.937843 1188 2014-04-07 0.359661 -0.285908 1864 2014-04-08 0.060978 1.714814 941 2014-04-09 1.759055 -0.455942 1065 2014-04-10 0.138185 -1.147008 1453 [100 rows x 3 columns] In [171]: def vwap(bars): .....: return ((bars.Close * bars.Volume).sum() / bars.Volume.sum()) .....: In [172]: window = 5 In [173]: s = pd.concat([(pd.Series(vwap(df.iloc[i:i + window]), .....: index=[df.index[i + window]])) .....: for i in range(len(df) - window)]) .....: In [174]: s.round(2) Out[174]: 2014-01-06 0.02 2014-01-07 0.11 2014-01-08 0.10 2014-01-09 0.07 2014-01-10 -0.29 ... 2014-04-06 -0.63 2014-04-07 -0.02 2014-04-08 -0.03 2014-04-09 0.34 2014-04-10 0.29 Length: 95, dtype: float64 Timeseries Between times\nUsing indexer between time\nConstructing a datetime range that excludes weekends and includes only certain times\nVectorized Lookup\nAggregation and plotting time series\nTurn a matrix with hours in columns and days in rows into a continuous row sequence in the form of a time series. How to rearrange a Python pandas DataFrame?\nDealing with duplicates when reindexing a timeseries to a specified frequency\nCalculate the first day of the month for each entry in a DatetimeIndex\nIn [175]: dates = pd.date_range(\u0026#39;2000-01-01\u0026#39;, periods=5) In [176]: dates.to_period(freq=\u0026#39;M\u0026#39;).to_timestamp() Out[176]: DatetimeIndex([\u0026#39;2000-01-01\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;2000-01-01\u0026#39;], dtype=\u0026#39;datetime64[ns]\u0026#39;, freq=None) Resampling The Resample docs.\nUsing Grouper instead of TimeGrouper for time grouping of values\nTime grouping with some missing values\nValid frequency arguments to Grouper Timeseries\nGrouping using a MultiIndex\nUsing TimeGrouper and another grouping to create subgroups, then apply a custom function\nResampling with custom periods\nResample intraday frame without adding new days\nResample minute data\nResample with groupby\nMerge The Concat docs. The Join docs.\nAppend two dataframes with overlapping index (emulate R rbind)\nIn [177]: rng = pd.date_range(\u0026#39;2000-01-01\u0026#39;, periods=6) In [178]: df1 = pd.DataFrame(np.random.randn(6, 3), index=rng, columns=[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]) In [179]: df2 = df1.copy() Depending on df construction, `ignore_index` may be needed In [180]: df = df1.append(df2, ignore_index=True) In [181]: df Out[181]: A B C 0 -0.870117 -0.479265 -0.790855 1 0.144817 1.726395 -0.464535 2 -0.821906 1.597605 0.187307 3 -0.128342 -1.511638 -0.289858 4 0.399194 -1.430030 -0.639760 5 1.115116 -2.012600 1.810662 6 -0.870117 -0.479265 -0.790855 7 0.144817 1.726395 -0.464535 8 -0.821906 1.597605 0.187307 9 -0.128342 -1.511638 -0.289858 10 0.399194 -1.430030 -0.639760 11 1.115116 -2.012600 1.810662 Self Join of a DataFrame\nIn [182]: df = pd.DataFrame(data={\u0026#39;Area\u0026#39;: [\u0026#39;A\u0026#39;] * 5 + [\u0026#39;C\u0026#39;] * 2, .....: \u0026#39;Bins\u0026#39;: [110] * 2 + [160] * 3 + [40] * 2, .....: \u0026#39;Test_0\u0026#39;: [0, 1, 0, 1, 2, 0, 1], .....: \u0026#39;Data\u0026#39;: np.random.randn(7)}) .....: In [183]: df Out[183]: Area Bins Test_0 Data 0 A 110 0 -0.433937 1 A 110 1 -0.160552 2 A 160 0 0.744434 3 A 160 1 1.754213 4 A 160 2 0.000850 5 C 40 0 0.342243 6 C 40 1 1.070599 In [184]: df[\u0026#39;Test_1\u0026#39;] = df[\u0026#39;Test_0\u0026#39;] - 1 In [185]: pd.merge(df, df, left_on=[\u0026#39;Bins\u0026#39;, \u0026#39;Area\u0026#39;, \u0026#39;Test_0\u0026#39;], .....: right_on=[\u0026#39;Bins\u0026#39;, \u0026#39;Area\u0026#39;, \u0026#39;Test_1\u0026#39;], .....: suffixes=(\u0026#39;_L\u0026#39;, \u0026#39;_R\u0026#39;)) .....: Out[185]: Area Bins Test_0_L Data_L Test_1_L Test_0_R Data_R Test_1_R 0 A 110 0 -0.433937 -1 1 -0.160552 0 1 A 160 0 0.744434 -1 1 1.754213 0 2 A 160 1 1.754213 0 2 0.000850 1 3 C 40 0 0.342243 -1 1 1.070599 0 How to set the index and join\nKDB like asof join\nJoin with a criteria based on the values\nUsing searchsorted to merge based on values inside a range\nPlotting The Plotting docs.\nMake Matplotlib look like R\nSetting x-axis major and minor labels\nPlotting multiple charts in an ipython notebook\nCreating a multi-line plot\nPlotting a heatmap\nAnnotate a time-series plot\nAnnotate a time-series plot #2\nGenerate Embedded plots in excel files using Pandas, Vincent and xlsxwriter\nBoxplot for each quartile of a stratifying variable\nIn [186]: df = pd.DataFrame( .....: {\u0026#39;stratifying_var\u0026#39;: np.random.uniform(0, 100, 20), .....: \u0026#39;price\u0026#39;: np.random.normal(100, 5, 20)}) .....: In [187]: df[\u0026#39;quartiles\u0026#39;] = pd.qcut( .....: df[\u0026#39;stratifying_var\u0026#39;], .....: 4, .....: labels=[\u0026#39;0-25%\u0026#39;, \u0026#39;25-50%\u0026#39;, \u0026#39;50-75%\u0026#39;, \u0026#39;75-100%\u0026#39;]) .....: In [188]: df.boxplot(column=\u0026#39;price\u0026#39;, by=\u0026#39;quartiles\u0026#39;) Out[188]: \u0026lt;matplotlib.axes._subplots.AxesSubplot at 0x7f9f2b8e9700\u0026gt; ![../_images/quartile_boxplot.png](https://pandas.pydata.org/pandas-docs/stable/_images/quartile_boxplot.png) Data in/out Performance comparison of SQL vs HDF5\nCSV The CSV docs\nread_csv in action\nappending to a csv\nReading a csv chunk-by-chunk\nReading only certain rows of a csv chunk-by-chunk\nReading the first few lines of a frame\nReading a file that is compressed but not by gzip/bz2 (the native compressed formats which read_csv understands). This example shows a WinZipped file, but is a general application of opening the file within a context manager and using that handle to read. See here\nInferring dtypes from a file\nDealing with bad lines\nDealing with bad lines II\nReading CSV with Unix timestamps and converting to local timezone\nWrite a multi-row index CSV without writing duplicates\nReading multiple files to create a single DataFrame The best way to combine multiple files into a single DataFrame is to read the individual frames one by one, put all of the individual frames into a list, and then combine the frames in the list using pd.concat():\nIn [189]: for i in range(3): .....: data = pd.DataFrame(np.random.randn(10, 4)) .....: data.to_csv(\u0026#39;file_{}.csv\u0026#39;.format(i)) .....: In [190]: files = [\u0026#39;file_0.csv\u0026#39;, \u0026#39;file_1.csv\u0026#39;, \u0026#39;file_2.csv\u0026#39;] In [191]: result = pd.concat([pd.read_csv(f) for f in files], ignore_index=True) You can use the same approach to read all files matching a pattern. Here is an example using glob:\nIn [192]: import glob In [193]: import os In [194]: files = glob.glob(\u0026#39;file_*.csv\u0026#39;) In [195]: result = pd.concat([pd.read_csv(f) for f in files], ignore_index=True) Finally, this strategy will work with the other pd.read_*(...) functions described in the io docs.\nParsing date components in multi-columns Parsing date components in multi-columns is faster with a format\nIn [196]: i = pd.date_range(\u0026#39;20000101\u0026#39;, periods=10000) In [197]: df = pd.DataFrame({\u0026#39;year\u0026#39;: i.year, \u0026#39;month\u0026#39;: i.month, \u0026#39;day\u0026#39;: i.day}) In [198]: df.head() Out[198]: year month day 0 2000 1 1 1 2000 1 2 2 2000 1 3 3 2000 1 4 4 2000 1 5 In [199]: %timeit pd.to_datetime(df.year * 10000 + df.month * 100 + df.day, format=\u0026#39;%Y%m%d\u0026#39;) .....: ds = df.apply(lambda x: \u0026#34;%04d%02d%02d\u0026#34; % (x[\u0026#39;year\u0026#39;], .....: x[\u0026#39;month\u0026#39;], x[\u0026#39;day\u0026#39;]), axis=1) .....: ds.head() .....: %timeit pd.to_datetime(ds) .....: 12.7 ms +- 111 us per loop (mean +- std. dev. of 7 runs, 100 loops each) 3.44 ms +- 99.2 us per loop (mean +- std. dev. of 7 runs, 100 loops each) Skip row between header and data In [200]: data = \u0026#34;\u0026#34;\u0026#34;;;;; .....: ;;;; .....: ;;;; .....: ;;;; .....: ;;;; .....: ;;;; .....: ;;;; .....: ;;;; .....: ;;;; .....: ;;;; .....: date;Param1;Param2;Param4;Param5 .....: ;m²;°C;m²;m .....: ;;;; .....: 01.01.1990 00:00;1;1;2;3 .....: 01.01.1990 01:00;5;3;4;5 .....: 01.01.1990 02:00;9;5;6;7 .....: 01.01.1990 03:00;13;7;8;9 .....: 01.01.1990 04:00;17;9;10;11 .....: 01.01.1990 05:00;21;11;12;13 .....: \u0026#34;\u0026#34;\u0026#34; .....: Option 1: pass rows explicitly to skip rows In [201]: from io import StringIO In [202]: pd.read_csv(StringIO(data), sep=\u0026#39;;\u0026#39;, skiprows=[11, 12], .....: index_col=0, parse_dates=True, header=10) .....: Out[202]: Param1 Param2 Param4 Param5 date 1990-01-01 00:00:00 1 1 2 3 1990-01-01 01:00:00 5 3 4 5 1990-01-01 02:00:00 9 5 6 7 1990-01-01 03:00:00 13 7 8 9 1990-01-01 04:00:00 17 9 10 11 1990-01-01 05:00:00 21 11 12 13 Option 2: read column names and then data In [203]: pd.read_csv(StringIO(data), sep=\u0026#39;;\u0026#39;, header=10, nrows=10).columns Out[203]: Index([\u0026#39;date\u0026#39;, \u0026#39;Param1\u0026#39;, \u0026#39;Param2\u0026#39;, \u0026#39;Param4\u0026#39;, \u0026#39;Param5\u0026#39;], dtype=\u0026#39;object\u0026#39;) In [204]: columns = pd.read_csv(StringIO(data), sep=\u0026#39;;\u0026#39;, header=10, nrows=10).columns In [205]: pd.read_csv(StringIO(data), sep=\u0026#39;;\u0026#39;, index_col=0, .....: header=12, parse_dates=True, names=columns) .....: Out[205]: Param1 Param2 Param4 Param5 date 1990-01-01 00:00:00 1 1 2 3 1990-01-01 01:00:00 5 3 4 5 1990-01-01 02:00:00 9 5 6 7 1990-01-01 03:00:00 13 7 8 9 1990-01-01 04:00:00 17 9 10 11 1990-01-01 05:00:00 21 11 12 13 SQL The SQL docs\nReading from databases with SQL\nExcel The Excel docs\nReading from a filelike handle\nModifying formatting in XlsxWriter output\nHTML Reading HTML tables from a server that cannot handle the default request header\nHDFStore The HDFStores docs\nSimple queries with a Timestamp Index\nManaging heterogeneous data using a linked multiple table hierarchy\nMerging on-disk tables with millions of rows\nAvoiding inconsistencies when writing to a store from multiple processes/threads\nDe-duplicating a large store by chunks, essentially a recursive reduction operation. Shows a function for taking in data from csv file and creating a store by chunks, with date parsing as well. See here\nCreating a store chunk-by-chunk from a csv file\nAppending to a store, while creating a unique index\nLarge Data work flows\nReading in a sequence of files, then providing a global unique index to a store while appending\nGroupby on a HDFStore with low group density\nGroupby on a HDFStore with high group density\nHierarchical queries on a HDFStore\nCounting with a HDFStore\nTroubleshoot HDFStore exceptions\nSetting min_itemsize with strings\nUsing ptrepack to create a completely-sorted-index on a store\nStoring Attributes to a group node\nIn [206]: df = pd.DataFrame(np.random.randn(8, 3)) In [207]: store = pd.HDFStore(\u0026#39;test.h5\u0026#39;) In [208]: store.put(\u0026#39;df\u0026#39;, df) # you can store an arbitrary Python object via pickle In [209]: store.get_storer(\u0026#39;df\u0026#39;).attrs.my_attribute = {\u0026#39;A\u0026#39;: 10} In [210]: store.get_storer(\u0026#39;df\u0026#39;).attrs.my_attribute Out[210]: {\u0026#39;A\u0026#39;: 10} You can create or load a HDFStore in-memory by passing the driver parameter to PyTables. Changes are only written to disk when the HDFStore is closed.\nIn [211]: store = pd.HDFStore(\u0026#39;test.h5\u0026#39;, \u0026#39;w\u0026#39;, diver=\u0026#39;H5FD_CORE\u0026#39;) In [212]: df = pd.DataFrame(np.random.randn(8, 3)) In [213]: store[\u0026#39;test\u0026#39;] = df # only after closing the store, data is written to disk: In [214]: store.close() Binary files pandas readily accepts NumPy record arrays, if you need to read in a binary file consisting of an array of C structs. For example, given this C program in a file called main.c compiled with gcc main.c -std=gnu99 on a 64-bit machine,\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; typedef struct _Data { int32_t count; double avg; float scale; } Data; int main(int argc, const char *argv[]) { size_t n = 10; Data d[n]; for (int i = 0; i \u0026lt; n; ++i) { d[i].count = i; d[i].avg = i + 1.0; d[i].scale = (float) i + 2.0f; } FILE *file = fopen(\u0026#34;binary.dat\u0026#34;, \u0026#34;wb\u0026#34;); fwrite(\u0026amp;d, sizeof(Data), n, file); fclose(file); return 0; } the following Python code will read the binary file 'binary.dat' into a pandas DataFrame, where each element of the struct corresponds to a column in the frame:\nnames = \u0026#39;count\u0026#39;, \u0026#39;avg\u0026#39;, \u0026#39;scale\u0026#39; # note that the offsets are larger than the size of the type because of # struct padding offsets = 0, 8, 16 formats = \u0026#39;i4\u0026#39;, \u0026#39;f8\u0026#39;, \u0026#39;f4\u0026#39; dt = np.dtype({\u0026#39;names\u0026#39;: names, \u0026#39;offsets\u0026#39;: offsets, \u0026#39;formats\u0026#39;: formats}, align=True) df = pd.DataFrame(np.fromfile(\u0026#39;binary.dat\u0026#39;, dt)) Note\nThe offsets of the structure elements may be different depending on the architecture of the machine on which the file was created. Using a raw binary file format like this for general data storage is not recommended, as it is not cross platform. We recommended either HDF5 or parquet, both of which are supported by pandas’ IO facilities.\nComputation Numerical integration (sample-based) of a time series\nCorrelation Often it’s useful to obtain the lower (or upper) triangular form of a correlation matrix calculated from DataFrame.corr(). This can be achieved by passing a boolean mask to where as follows:\nIn [215]: df = pd.DataFrame(np.random.random(size=(100, 5))) In [216]: corr_mat = df.corr() In [217]: mask = np.tril(np.ones_like(corr_mat, dtype=np.bool), k=-1) In [218]: corr_mat.where(mask) Out[218]: 0 1 2 3 4 0 NaN NaN NaN NaN NaN 1 -0.079861 NaN NaN NaN NaN 2 -0.236573 0.183801 NaN NaN NaN 3 -0.013795 -0.051975 0.037235 NaN NaN 4 -0.031974 0.118342 -0.073499 -0.02063 NaN The method argument within DataFrame.corr can accept a callable in addition to the named correlation types. Here we compute the distance correlation matrix for a DataFrame object.\nIn [219]: def distcorr(x, y): .....: n = len(x) .....: a = np.zeros(shape=(n, n)) .....: b = np.zeros(shape=(n, n)) .....: for i in range(n): .....: for j in range(i + 1, n): .....: a[i, j] = abs(x[i] - x[j]) .....: b[i, j] = abs(y[i] - y[j]) .....: a += a.T .....: b += b.T .....: a_bar = np.vstack([np.nanmean(a, axis=0)] * n) .....: b_bar = np.vstack([np.nanmean(b, axis=0)] * n) .....: A = a - a_bar - a_bar.T + np.full(shape=(n, n), fill_value=a_bar.mean()) .....: B = b - b_bar - b_bar.T + np.full(shape=(n, n), fill_value=b_bar.mean()) .....: cov_ab = np.sqrt(np.nansum(A * B)) / n .....: std_a = np.sqrt(np.sqrt(np.nansum(A**2)) / n) .....: std_b = np.sqrt(np.sqrt(np.nansum(B**2)) / n) .....: return cov_ab / std_a / std_b .....: In [220]: df = pd.DataFrame(np.random.normal(size=(100, 3))) In [221]: df.corr(method=distcorr) Out[221]: 0 1 2 0 1.000000 0.197613 0.216328 1 0.197613 1.000000 0.208749 2 0.216328 0.208749 1.000000 Timedeltas The Timedeltas docs.\nUsing timedeltas\nIn [222]: import datetime In [223]: s = pd.Series(pd.date_range(\u0026#39;2012-1-1\u0026#39;, periods=3, freq=\u0026#39;D\u0026#39;)) In [224]: s - s.max() Out[224]: 0 -2 days 1 -1 days 2 0 days dtype: timedelta64[ns] In [225]: s.max() - s Out[225]: 0 2 days 1 1 days 2 0 days dtype: timedelta64[ns] In [226]: s - datetime.datetime(2011, 1, 1, 3, 5) Out[226]: 0 364 days 20:55:00 1 365 days 20:55:00 2 366 days 20:55:00 dtype: timedelta64[ns] In [227]: s + datetime.timedelta(minutes=5) Out[227]: 0 2012-01-01 00:05:00 1 2012-01-02 00:05:00 2 2012-01-03 00:05:00 dtype: datetime64[ns] In [228]: datetime.datetime(2011, 1, 1, 3, 5) - s Out[228]: 0 -365 days +03:05:00 1 -366 days +03:05:00 2 -367 days +03:05:00 dtype: timedelta64[ns] In [229]: datetime.timedelta(minutes=5) + s Out[229]: 0 2012-01-01 00:05:00 1 2012-01-02 00:05:00 2 2012-01-03 00:05:00 dtype: datetime64[ns] Adding and subtracting deltas and dates\nIn [230]: deltas = pd.Series([datetime.timedelta(days=i) for i in range(3)]) In [231]: df = pd.DataFrame({\u0026#39;A\u0026#39;: s, \u0026#39;B\u0026#39;: deltas}) In [232]: df Out[232]: A B 0 2012-01-01 0 days 1 2012-01-02 1 days 2 2012-01-03 2 days In [233]: df[\u0026#39;New Dates\u0026#39;] = df[\u0026#39;A\u0026#39;] + df[\u0026#39;B\u0026#39;] In [234]: df[\u0026#39;Delta\u0026#39;] = df[\u0026#39;A\u0026#39;] - df[\u0026#39;New Dates\u0026#39;] In [235]: df Out[235]: A B New Dates Delta 0 2012-01-01 0 days 2012-01-01 0 days 1 2012-01-02 1 days 2012-01-03 -1 days 2 2012-01-03 2 days 2012-01-05 -2 days In [236]: df.dtypes Out[236]: A datetime64[ns] B timedelta64[ns] New Dates datetime64[ns] Delta timedelta64[ns] dtype: object Another example\nValues can be set to NaT using np.nan, similar to datetime\nIn [237]: y = s - s.shift() In [238]: y Out[238]: 0 NaT 1 1 days 2 1 days dtype: timedelta64[ns] In [239]: y[1] = np.nan In [240]: y Out[240]: 0 NaT 1 NaT 2 1 days dtype: timedelta64[ns] Creating example data To create a dataframe from every combination of some given values, like R’s expand.grid() function, we can create a dict where the keys are column names and the values are lists of the data values:\nIn [241]: def expand_grid(data_dict): .....: rows = itertools.product(*data_dict.values()) .....: return pd.DataFrame.from_records(rows, columns=data_dict.keys()) .....: In [242]: df = expand_grid({\u0026#39;height\u0026#39;: [60, 70], .....: \u0026#39;weight\u0026#39;: [100, 140, 180], .....: \u0026#39;sex\u0026#39;: [\u0026#39;Male\u0026#39;, \u0026#39;Female\u0026#39;]}) .....: In [243]: df Out[243]: height weight sex 0 60 100 Male 1 60 100 Female 2 60 140 Male 3 60 140 Female 4 60 180 Male 5 60 180 Female 6 70 100 Male 7 70 100 Female 8 70 140 Male 9 70 140 Female 10 70 180 Male 11 70 180 Female "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/date-time/pendulum/",
	"title": "pendulum",
	"tags": [],
	"description": "",
	"content": "Installing pendulum is quite simple:\n$ pip install pendulum or, if you are using poetry:\n$ poetry add pendulum Introduction Pendulum is a Python package to ease datetimes manipulation.\nIt provides classes that are drop-in replacements for the native ones (they inherit from them).\nSpecial care has been taken to ensure timezones are handled correctly, and are based on the underlying tzinfo implementation. For example all comparisons are done in UTC or in the timezone of the datetime being used.\nimport pendulum dt_toronto = pendulum.datetime(2012, 1, 1, tz=\u0026#39;America/Toronto\u0026#39;) dt_vancouver = pendulum.datetime(2012, 1, 1, tz=\u0026#39;America/Vancouver\u0026#39;) print(dt_vancouver.diff(dt_toronto).in_hours()) #3 The default timezone, except when using the now(), method will always be UTC.\nInstantiation There are several different methods available to create a new DateTime instance.\nFirst there is the main datetime() helper.\nimport pendulum dt = pendulum.datetime(2015, 2, 5) isinstance(dt, datetime) #True dt.timezone.name #\u0026#39;UTC\u0026#39; datetime() sets the time to 00:00:00 if it\u0026rsquo;s not specified, and the timezone (the tz keyword argument) to UTC. It otherwise can be a Timezone instance or simply a string timezone value.\nimport pendulum pendulum.datetime(2015, 2, 5, tz=\u0026#39;Europe/Paris\u0026#39;) tz = pendulum.timezone(\u0026#39;Europe/Paris\u0026#39;) pendulum.datetime(2015, 2, 5, tz=tz) Supported strings for timezones are the one provided by the IANA time zone database.\nThe special local string is also supported and will return your current timezone.\nThe tz argument is keyword-only, unlike in version 1.x\nThe local() helper is similar to datetime() but automatically sets the timezone to the local timezone.\nimport pendulum dt = pendulum.local(2015, 2, 5) print(dt.timezone.name) #\u0026#39;America/Toronto\u0026#39; local() is just an alias for datetime(..., tz='local').\nThere is also the now() method.\nimport pendulum now = pendulum.now() now_in_london_tz = pendulum.now(\u0026#39;Europe/London\u0026#39;) now_in_london_tz.timezone_name #\u0026#39;Europe/London\u0026#39; To accompany now(), a few other static instantiation helpers exist to create known instances. The only thing to really notice here is that today(), tomorrow() and yesterday(), besides behaving as expected, all accept a timezone parameter and each has their time value set to 00:00:00.\nnow = pendulum.now() print(now) #2016-06-28T16:51:45.978473-05:00 today = pendulum.today() print(today) #\u0026#39;2016-06-28T00:00:00-05:00\u0026#39; tomorrow = pendulum.tomorrow(\u0026#39;Europe/London\u0026#39;) print(tomorrow) #\u0026#39;2016-06-29T00:00:00+01:00\u0026#39; yesterday = pendulum.yesterday() print(yesterday) #\u0026#39;2016-06-27T00:00:00-05:00\u0026#39; Pendulum enforces timezone aware datetimes, and using them is the preferred and recommended way of using the library, however is you really need a naive DateTime object, the naive() helper is there for you.\nimport pendulum naive = pendulum.naive(2015, 2, 5) naive.timezone #None The next helper, from_format(), is similar to the native datetime.strptime() function but uses custom tokens to create a DateTime instance.\ndt = pendulum.from_format(\u0026#39;1975-05-21 22\u0026#39;, \u0026#39;YYYY-MM-DD HH\u0026#39;) print(dt) #\u0026#39;1975-05-21T22:00:00+00:00\u0026#39; To see all the available tokens, you can check the Formatter section.\nIt also accepts a tz keyword argument to specify the timezone:\ndt = pendulum.from_format(\u0026#39;1975-05-21 22\u0026#39;, \u0026#39;YYYY-MM-DD HH\u0026#39;, tz=\u0026#39;Europe/London\u0026#39;) #\u0026#39;1975-05-21T22:00:00+01:00\u0026#39; The final helper is for working with unix timestamps. from_timestamp() will create a DateTime instance equal to the given timestamp and will set the timezone as well or default it to UTC.\ndt = pendulum.from_timestamp(-1) print(dt) #\u0026#39;1969-12-31T23:59:59+00:00\u0026#39; dt = pendulum.from_timestamp(-1, tz=\u0026#39;Europe/London\u0026#39;) print(dt) #\u0026#39;1970-01-01T00:59:59+01:00\u0026#39; Finally, if you find yourself inheriting a DateTime instance, you can create a DateTime instance via the instance() function.\ndt = datetime(2008, 1, 1) p = pendulum.instance(dt) print(p) #\u0026#39;2008-01-01T00:00:00+00:00\u0026#39; Parsing The library natively supports the RFC 3339 format, most ISO 8601 formats and some other common formats.\nimport pendulum dt = pendulum.parse(\u0026#39;1975-05-21T22:00:00\u0026#39;) print(dt) #\u0026#39;1975-05-21T22:00:00+00:00 # You can pass a tz keyword to specify the timezone dt = pendulum.parse(\u0026#39;1975-05-21T22:00:00\u0026#39;, tz=\u0026#39;Europe/Paris\u0026#39;) print(dt) #\u0026#39;1975-05-21T22:00:00+01:00\u0026#39; # Not ISO 8601 compliant but common dt = pendulum.parse(\u0026#39;1975-05-21 22:00:00\u0026#39;) If you pass a non-standard or more complicated string, it will raise an exception so it is advised to use the from_format() helper instead.\nHowever, if you want the library to fallback on the dateutil parser, you have to pass strict=False.\nimport pendulum dt = pendulum.parse(\u0026#39;31-01-01\u0026#39;) Traceback (most recent call last): ... #ParserError: Unable to parse string [31-01-01] dt = pendulum.parse(\u0026#39;31-01-01\u0026#39;, strict=False) print(dt) #\u0026#39;2031-01-01T00:00:00+00:00\u0026#39; RFC 3339 STRING\nOUTPUT\n1996-12-19T16:39:57-08:00\n1996-12-19T16:39:57-08:00\n1990-12-31T23:59:59Z\n1990-12-31T23:59:59+00:00\nISO 8601 Datetime STRING\nOUTPUT\n20161001T143028+0530\n2016-10-01T14:30:28+05:30\n20161001T14\n2016-10-01T14:00:00+00:00\nDate STRING\nOUTPUT\n2012\n2012-01-01T00:00:00+00:00\n2012-05-03\n2012-05-03T00:00:00+00:00\n20120503\n2012-05-03T00:00:00+00:00\n2012-05\n2012-05-01T00:00:00+00:00\nOrdinal day STRING\nOUTPUT\n2012-007\n2012-01-07T00:00:00+00:00\n2012007\n2012-01-07T00:00:00+00:00\nWeek number STRING\nOUTPUT\n2012-W05\n2012-01-30T00:00:00+00:00\n2012W05\n2012-01-30T00:00:00+00:00\n2012-W05-5\n2012-02-03T00:00:00+00:00\n2012W055\n2012-02-03T00:00:00+00:00\nTime When passing only time information the date will default to today.\nSTRING\nOUTPUT\n00:00\n2016-12-17T00:00:00+00:00\n12:04:23\n2016-12-17T12:04:23+00:00\n120423\n2016-12-17T12:04:23+00:00\n12:04:23.45\n2016-12-17T12:04:23.450000+00:00\nIntervals STRING\nOUTPUT\n2007-03-01T13:00:00Z/2008-05-11T15:30:00Z\n2007-03-01T13:00:00+00:00 -\u0026gt; 2008-05-11T15:30:00+00:00\n2008-05-11T15:30:00Z/P1Y2M10DT2H30M\n2008-05-11T15:30:00+00:00 -\u0026gt; 2009-07-21T18:00:00+00:00\nP1Y2M10DT2H30M/2008-05-11T15:30:00Z\n2007-03-01T13:00:00+00:00 -\u0026gt; 2008-05-11T15:30:00+00:00\nYou can pass the exact keyword argument to parse() to get the exact type that the string represents:\nimport pendulum\npendulum.parse(\u0026lsquo;2012-05-03\u0026rsquo;, exact=True) Date(2012, 05, 03)\npendulum.parse(\u0026lsquo;12:04:23\u0026rsquo;, exact=True) Time(12, 04, 23)\nLocalization Localization occurs when using the format() method which accepts a locale keyword.\nimport pendulum dt = pendulum.datetime(1975, 5, 21) dt.format(\u0026#39;dddd DD MMMM YYYY\u0026#39;, locale=\u0026#39;de\u0026#39;) #\u0026#39;Mittwoch 21 Mai 1975\u0026#39; dt.format(\u0026#39;dddd DD MMMM YYYY\u0026#39;) #\u0026#39;Wednesday 21 May 1975\u0026#39; diff_for_humans() is also localized, you can set the locale by using pendulum.set_locale().\nimport pendulum pendulum.set_locale(\u0026#39;de\u0026#39;) pendulum.now().add(years=1).diff_for_humans() #\u0026#39;in 1 Jahr\u0026#39; pendulum.set_locale(\u0026#39;en\u0026#39;) However, you might not want to set the locale globally. The diff_for_humans() method accept a locale keyword argument to use a locale for a specific call.\npendulum.set_locale(\u0026#39;de\u0026#39;) dt = pendulum.now().add(years=1) dt.diff_for_humans(locale=\u0026#39;fr\u0026#39;) #\u0026#39;dans 1 an\u0026#39; Attributes and Properties Pendulum gives access to more attributes and properties than the default datetime class.\nimport pendulum dt = pendulum.parse(\u0026#39;2012-09-05T23:26:11.123789\u0026#39;) # These properties specifically return integers ```py dt.year 2012 dt.month 9 dt.day 5 dt.hour 23 dt.minute 26 dt.second 11 dt.microsecond 123789 dt.day_of_week 3 dt.day_of_year 248 dt.week_of_month 1 dt.week_of_year 36 dt.days_in_month 30 dt.timestamp() 1346887571.123789 dt.float_timestamp 1346887571.123789 dt.int_timestamp 1346887571 pendulum.datetime(1975, 5, 21).age 41 # calculated vs now in the same tz dt.quarter 3 # Returns an int of seconds difference from UTC (+/- sign included) pendulum.from_timestamp(0).offset 0 pendulum.from_timestamp(0, \u0026#39;America/Toronto\u0026#39;).offset -18000 # Returns a float of hours difference from UTC (+/- sign included) pendulum.from_timestamp(0, \u0026#39;America/Toronto\u0026#39;).offset_hours -5.0 pendulum.from_timestamp(0, \u0026#39;Australia/Adelaide\u0026#39;).offset_hours 9.5 # Gets the timezone instance pendulum.now().timezone pendulum.now().tz # Gets the timezone name pendulum.now().timezone_name # Indicates if daylight savings time is on dt = pendulum.datetime(2012, 1, 1, tz=\u0026#39;America/Toronto\u0026#39;) dt.is_dst() False dt = pendulum.datetime(2012, 9, 1, tz=\u0026#39;America/Toronto\u0026#39;) dt.is_dst() True # Indicates if the instance is in the same timezone as the local timezone pendulum.now().is_local() True pendulum.now(\u0026#39;Europe/London\u0026#39;).is_local() False # Indicates if the instance is in the UTC timezone pendulum.now().is_utc() False pendulum.now(\u0026#39;Europe/London\u0026#39;).is_local() False pendulum.now(\u0026#39;UTC\u0026#39;).is_utc() True Fluent helpers Pendulum provides helpers that returns a new instance with some attributes modified compared to the original instance. However, none of these helpers, with the exception of explicitely setting the timezone, will change the timezone of the instance. Specifically, setting the timestamp will not set the corresponding timezone to UTC.\nimport pendulum dt = pendulum.now() dt.set(year=1975, month=5, day=21).to_datetime_string() \u0026#39;1975-05-21 13:45:18\u0026#39; dt.set(hour=22, minute=32, second=5).to_datetime_string() \u0026#39;2016-11-16 22:32:05\u0026#39; You can also use the `on()` and `at()` methods to change the date and the time respectively dt.on(1975, 5, 21).at(22, 32, 5).to_datetime_string() \u0026#39;1975-05-21 22:32:05\u0026#39; dt.at(10).to_datetime_string() \u0026#39;2016-11-16 10:00:00\u0026#39; dt.at(10, 30).to_datetime_string() \u0026#39;2016-11-16 10:30:00\u0026#39; You can also modify the timezone.\ndt.set(tz=\u0026#39;Europe/London\u0026#39;) Setting the timezone just modify the timezone information without making any conversion while in_timezone() (or in_tz()) converts the time in the appropriate timezone.\nimport pendulum dt = pendulum.datetime(2013, 3, 31, 2, 30) print(dt) \u0026#39;2013-03-31T02:30:00+00:00\u0026#39; dt = dt.set(tz=\u0026#39;Europe/Paris\u0026#39;) print(dt) \u0026#39;2013-03-31T03:30:00+02:00\u0026#39; dt = dt.in_tz(\u0026#39;Europe/Paris\u0026#39;) print(dt) \u0026#39;2013-03-31T04:30:00+02:00\u0026#39; dt = dt.set(tz=\u0026#39;Europe/Paris\u0026#39;).set(tz=\u0026#39;UTC\u0026#39;) print(dt) \u0026#39;2013-03-31T03:30:00+00:00\u0026#39; dt = dt.in_tz(\u0026#39;Europe/Paris\u0026#39;).in_tz(\u0026#39;UTC\u0026#39;) print(dt) \u0026#39;2013-03-31T02:30:00+00:00\u0026#39; String formatting The __str__ magic method is defined which allows DateTime instances to be printed as a pretty date string when used in a string context.\nThe default string representation is the same as the one returned by the isoformat() method.\nimport pendulum dt = pendulum.datetime(1975, 12, 25, 14, 15, 16) print(dt) \u0026#39;1975-12-25T14:15:16+00:00\u0026#39; dt.to_date_string() \u0026#39;1975-12-25\u0026#39; dt.to_formatted_date_string() \u0026#39;Dec 25, 1975\u0026#39; dt.to_time_string() \u0026#39;14:15:16\u0026#39; dt.to_datetime_string() \u0026#39;1975-12-25 14:15:16\u0026#39; dt.to_day_datetime_string() \u0026#39;Thu, Dec 25, 1975 2:15 PM\u0026#39; # You can also use the format() method dt.format(\u0026#39;dddd Do [of] MMMM YYYY HH:mm:ss A\u0026#39;) \u0026#39;Thursday 25th of December 1975 02:15:16 PM\u0026#39; # Of course, the strftime method is still available dt.strftime(\u0026#39;%A %-d%t of %B %Y %I:%M:%S %p\u0026#39;) \u0026#39;Thursday 25th of December 1975 02:15:16 PM\u0026#39; For localization support see the Localization section.\nCommon Formats The following are methods to display a DateTime instance as a common format:\nimport pendulum dt = pendulum.now() dt.to_atom_string() \u0026#39;1975-12-25T14:15:16-05:00\u0026#39; dt.to_cookie_string() \u0026#39;Thursday, 25-Dec-1975 14:15:16 EST\u0026#39; dt.to_iso8601_string() \u0026#39;1975-12-25T14:15:16-0500\u0026#39; dt.to_rfc822_string() \u0026#39;Thu, 25 Dec 75 14:15:16 -0500\u0026#39; dt.to_rfc850_string() \u0026#39;Thursday, 25-Dec-75 14:15:16 EST\u0026#39; dt.to_rfc1036_string() \u0026#39;Thu, 25 Dec 75 14:15:16 -0500\u0026#39; dt.to_rfc1123_string() \u0026#39;Thu, 25 Dec 1975 14:15:16 -0500\u0026#39; dt.to_rfc2822_string() \u0026#39;Thu, 25 Dec 1975 14:15:16 -0500\u0026#39; dt.to_rfc3339_string() \u0026#39;1975-12-25T14:15:16-05:00\u0026#39; dt.to_rss_string() \u0026#39;Thu, 25 Dec 1975 14:15:16 -0500\u0026#39; dt.to_w3c_string() \u0026#39;1975-12-25T14:15:16-05:00\u0026#39; Formatter Pendulum uses its own formatter when using the format() method.\nThis format is more intuitive to use than the one used with strftime() and supports more directives.\nimport pendulum dt = pendulum.datetime(1975, 12, 25, 14, 15, 16) dt.format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) \u0026#39;1975-12-25 14:15:16\u0026#39; Tokens The following tokens are currently supported:\nTOKEN\nOUTPUT\nYEAR\nYYYY\n2000, 2001, 2002 \u0026hellip; 2012, 2013\nYY\n00, 01, 02 \u0026hellip; 12, 13\nQUARTER\nQ\n1 2 3 4\nQo\n1st 2nd 3rd 4th\nMONTH\nMMMM\nJanuary, February, March \u0026hellip;\nMMM\nJan, Feb, Mar \u0026hellip;\nMM\n01, 02, 03 \u0026hellip; 11, 12\nM\n1, 2, 3 \u0026hellip; 11, 12\nMo\n1st 2nd \u0026hellip; 11th 12th\nDAY OF YEAR\nDDDD\n001, 002, 003 \u0026hellip; 364, 365\nDDD\n1, 2, 3 \u0026hellip; 4, 5\nDAY OF MONTH\nDD\n01, 02, 03 \u0026hellip; 30, 31\nD\n1, 2, 3 \u0026hellip; 30, 31\nDo\n1st, 2nd, 3rd \u0026hellip; 30th, 31st\nDAY OF WEEK\ndddd\nMonday, Tuesday, Wednesday \u0026hellip;\nddd\nMon, Tue, Wed \u0026hellip;\ndd\nMo, Tu, We \u0026hellip;\nd\n0, 1, 2 \u0026hellip; 6\nDAYS OF ISO WEEK\nE\n1, 2, 3 \u0026hellip; 7\nHOUR\nHH\n00, 01, 02 \u0026hellip; 23, 24\nH\n0, 1, 2 \u0026hellip; 23, 24\nhh\n01, 02, 03 \u0026hellip; 11, 12\nh\n1, 2, 3 \u0026hellip; 11, 12\nMINUTE\nmm\n00, 01, 02 \u0026hellip; 58, 59\nm\n0, 1, 2 \u0026hellip; 58, 59\nSECOND\nss\n00, 01, 02 \u0026hellip; 58, 59\ns\n0, 1, 2 \u0026hellip; 58, 59\nFRACTIONAL SECOND\nS\n0 1 \u0026hellip; 8 9\nSS\n00, 01, 02 \u0026hellip; 98, 99\nSSS\n000 001 \u0026hellip; 998 999\nSSSS \u0026hellip;\n000[0..] 001[0..] \u0026hellip; 998[0..] 999[0..]\nSSSSSS\nAM / PM\nA\nAM, PM\nTIMEZONE\nZ\n-07:00, -06:00 \u0026hellip; +06:00, +07:00\nZZ\n-0700, -0600 \u0026hellip; +0600, +0700\nz\nAsia/Baku, Europe/Warsaw, GMT \u0026hellip;\nzz\nEST CST \u0026hellip; MST PST\nSECONDS TIMESTAMP\nX\n1381685817, 1234567890.123\nMICROSECONDS TIMESTAMP\nx\n1234567890123\nLocalized Formats Because preferred formatting differs based on locale, there are a few tokens that can be used to format an instance based on its locale.\nTIME\nLT\n8:30 PM\nTIME WITH SECONDS\nLTS\n8:30:25 PM\nMONTH NUMERAL, DAY OF MONTH, YEAR\nL\n09/04/1986\nMONTH NAME, DAY OF MONTH, YEAR\nLL\nSeptember 4 1986\nMONTH NAME, DAY OF MONTH, YEAR, TIME\nLLL\nSeptember 4 1986 8:30 PM\nMONTH NAME, DAY OF MONTH, DAY OF WEEK, YEAR, TIME\nLLLL\nThursday, September 4 1986 8:30 PM\nEscaping Characters To escape characters in format strings, you can wrap the characters in square brackets.\nimport pendulum\ndt = pendulum.now() dt.format('[today] dddd\u0026rsquo;, formatter='alternative\u0026rsquo;) \u0026lsquo;today Sunday\u0026rsquo;\nComparison Simple comparison is offered up via the basic operators. Remember that the comparison is done in the UTC timezone so things aren\u0026rsquo;t always as they seem.\nimport pendulum first = pendulum.datetime(2012, 9, 5, 23, 26, 11, 0, tz=\u0026#39;America/Toronto\u0026#39;) second = pendulum.datetime(2012, 9, 5, 20, 26, 11, 0, tz=\u0026#39;America/Vancouver\u0026#39;) first.to_datetime_string() \u0026#39;2012-09-05 23:26:11\u0026#39; first.timezone_name \u0026#39;America/Toronto\u0026#39; second.to_datetime_string() \u0026#39;2012-09-05 20:26:11\u0026#39; second.timezone_name \u0026#39;America/Vancouver\u0026#39; first == second True first != second False first \u0026gt; second False first \u0026gt;= second True first \u0026lt; second False first \u0026lt;= second True first = first.on(2012, 1, 1).at(0, 0, 0) second = second.on(2012, 1, 1).at(0, 0, 0) # tz is still America/Vancouver for second first == second False first != second True first \u0026gt; second False first \u0026gt;= second False first \u0026lt; second True first \u0026lt;= second True To handle the most used cases there are some simple helper functions. For the methods that compare to now() (ex. is_today()) in some manner the now() is created in the same timezone as the instance.\nimport pendulum dt = pendulum.now() dt.is_past() dt.is_leap_year() born = pendulum.datetime(1987, 4, 23) not_birthday = pendulum.datetime(2014, 9, 26) birthday = pendulum.datetime(2014, 2, 23) past_birthday = pendulum.now().subtract(years=50) born.is_birthday(not_birthday) False born.is_birthday(birthday) True past_birthday.is_birthday() # Compares to now by default True # Addition and Subtraction[](https://pendulum.eustace.io/docs/#addition-and-subtraction \u0026#34;Permanent link\u0026#34;) To easily adding and subtracting time, you can use the add() and subtract() methods. Each method returns a new DateTime instance.\nimport pendulum dt = pendulum.datetime(2012, 1, 31) dt.to_datetime_string() \u0026#39;2012-01-31 00:00:00\u0026#39; dt = dt.add(years=5) \u0026#39;2017-01-31 00:00:00\u0026#39; dt = dt.add(years=1) \u0026#39;2018-01-31 00:00:00\u0026#39; dt = dt.subtract(years=1) \u0026#39;2017-01-31 00:00:00\u0026#39; dt = dt.subtract(years=5) \u0026#39;2012-01-31 00:00:00\u0026#39; dt = dt.add(months=60) \u0026#39;2017-01-31 00:00:00\u0026#39; dt = dt.add(months=1) \u0026#39;2017-02-28 00:00:00\u0026#39; dt = dt.subtract(months=1) \u0026#39;2017-01-28 00:00:00\u0026#39; dt = dt.subtract(months=60) \u0026#39;2012-01-28 00:00:00\u0026#39; dt = dt.add(days=29) \u0026#39;2012-02-26 00:00:00\u0026#39; dt = dt.add(days=1) \u0026#39;2012-02-27 00:00:00\u0026#39; dt = dt.subtract(days=1) \u0026#39;2012-02-26 00:00:00\u0026#39; dt = dt.subtract(days=29) \u0026#39;2012-01-28 00:00:00\u0026#39; dt = dt.add(weeks=3) \u0026#39;2012-02-18 00:00:00\u0026#39; dt = dt.add(weeks=1) \u0026#39;2012-02-25 00:00:00\u0026#39; dt = dt.subtract(weeks=1) \u0026#39;2012-02-18 00:00:00\u0026#39; dt = dt.subtract(weeks=3) \u0026#39;2012-01-28 00:00:00\u0026#39; dt = dt.add(hours=24) \u0026#39;2012-01-29 00:00:00\u0026#39; dt = dt.add(hours=1) \u0026#39;2012-02-25 01:00:00\u0026#39; dt = dt.subtract(hours=1) \u0026#39;2012-02-29 00:00:00\u0026#39; dt = dt.subtract(hours=24) \u0026#39;2012-01-28 00:00:00\u0026#39; dt = dt.add(minutes=61) \u0026#39;2012-01-28 01:01:00\u0026#39; dt = dt.add(minutes=1) \u0026#39;2012-01-28 01:02:00\u0026#39; dt = dt.subtract(minutes=1) \u0026#39;2012-01-28 01:01:00\u0026#39; dt = dt.subtract(minutes=24) \u0026#39;2012-01-28 00:00:00\u0026#39; dt = dt.add(seconds=61) \u0026#39;2012-01-28 00:01:01\u0026#39; dt = dt.add(seconds=1) \u0026#39;2012-01-28 00:01:02\u0026#39; dt = dt.subtract(seconds=1) \u0026#39;2012-01-28 00:01:01\u0026#39; dt = dt.subtract(seconds=61) \u0026#39;2012-01-28 00:00:00\u0026#39; dt = dt.add(years=3, months=2, days=6, hours=12, minutes=31, seconds=43) \u0026#39;2015-04-03 12:31:43\u0026#39; dt = dt.subtract(years=3, months=2, days=6, hours=12, minutes=31, seconds=43) \u0026#39;2012-01-28 00:00:00\u0026#39; # You can also add or remove a timedelta dt.add_timedelta(timedelta(hours=3, minutes=4, seconds=5)) \u0026#39;2012-01-28 03:04:05\u0026#39; dt.sub_timedelta(timedelta(hours=3, minutes=4, seconds=5)) \u0026#39;2012-01-28 00:00:00\u0026#39; Passing negative values to add() is also possible and will act exactly like subtract()\nDifference The diff() method returns a Period instance that represents the total duration between two DateTime instances. This interval can be then expressed in various units. These interval methods always return the total difference expressed in the specified time requested. All values are truncated and not rounded.\nThe diff() method has a default first parameter which is the DateTime instance to compare to, or None if you want to use now(). The 2nd parameter is optional and indicates if you want the return value to be the absolute value or a relative value that might have a - (negative) sign if the passed in date is less than the current instance. This will default to True, return the absolute value.\nimport pendulum dt_ottawa = pendulum.datetime(2000, 1, 1, tz=\u0026#39;America/Toronto\u0026#39;) dt_vancouver = pendulum.datetime(2000, 1, 1, tz=\u0026#39;America/Vancouver\u0026#39;) dt_ottawa.diff(dt_vancouver).in_hours() 3 dt_ottawa.diff(dt_vancouver, False).in_hours() 3 dt_vancouver.diff(dt_ottawa, False).in_hours() -3 dt = pendulum.datetime(2012, 1, 31, 0) dt.diff(dt.add(months=1)).in_days() 29 dt.diff(dt.subtract(months=1), False).in_days() -31 dt = pendulum.datetime(2012, 4, 30, 0) dt.diff(dt.add(months=1)).in_days() 30 dt.diff(dt.add(weeks=1)).in_days() 7 dt = pendulum.datetime(2012, 1, 1, 0) dt.diff(dt.add(seconds=59)).in_minutes() 0 dt.diff(dt.add(seconds=60)).in_minutes() 1 dt.diff(dt.add(seconds=119)).in_minutes() 1 dt.diff(dt.add(seconds=120)).in_minutes() 2 Difference for Humans The diff_for_humans() method will add a phrase after the difference value relative to the instance and the passed in instance. There are 4 possibilities:\n  When comparing a value in the past to default now:\n 1 hour ago 5 months ago    When comparing a value in the future to default now:\n 1 hour from now 5 months from now    When comparing a value in the past to another value:\n 1 hour before 5 months before    When comparing a value in the future to another value:\n 1 hour after 5 months after    You may also pass True as a 2nd parameter to remove the modifiers ago, from now, etc.\nimport pendulum # The most typical usage is for comments # The instance is the date the comment was created # and its being compared to default now() pendulum.now().subtract(days=1).diff_for_humans() \u0026#39;5 days ago\u0026#39; pendulum.now().diff_for_humans(pendulum.now().subtract(years=1)) \u0026#39;1 year after\u0026#39; dt = pendulum.datetime(2011, 8, 1) dt.diff_for_humans(dt.add(months=1)) \u0026#39;1 month before\u0026#39; dt.diff_for_humans(dt.subtract(months=1)) \u0026#39;1 month after\u0026#39; pendulum.now().add(seconds=5).diff_for_humans() \u0026#39;5 seconds from now\u0026#39; pendulum.now().subtract(days=24).diff_for_humans() \u0026#39;3 weeks ago\u0026#39; pendulum.now().subtract(days=24).diff_for_humans(absolute=True) \u0026#39;3 weeks\u0026#39; You can also change the locale of the string either globally by using pendulum.set_locale('fr') before the diff_for_humans() call or specifically for the call by passing the locale keyword argument. See the Localization section for more detail.\nimport pendulum pendulum.set_locale(\u0026#39;de\u0026#39;) pendulum.now().add(years=1).diff_for_humans() \u0026#39;in 1 Jahr\u0026#39; pendulum.now().add(years=1).diff_for_humans(locale=\u0026#39;fr\u0026#39;) \u0026#39;dans 1 an\u0026#39; Modifiers These group of methods perform helpful modifications to a copy of the current instance. You\u0026rsquo;ll notice that the start_of(), next() and previous() methods set the time to 00:00:00 and the end_of() methods set the time to 23:59:59.999999.\nThe only one slightly different is the average() method. It returns the middle date between itself and the provided DateTime argument.\nimport pendulum dt = pendulum.datetime(2012, 1, 31, 12, 0, 0) dt.start_of(\u0026#39;day\u0026#39;) \u0026#39;2012-01-31 00:00:00\u0026#39; dt.end_of(\u0026#39;day\u0026#39;) \u0026#39;2012-01-31 23:59:59\u0026#39; dt.start_of(\u0026#39;month\u0026#39;) \u0026#39;2012-01-01 00:00:00\u0026#39; dt.end_of(\u0026#39;month\u0026#39;) \u0026#39;2012-01-31 23:59:59\u0026#39; dt.start_of(\u0026#39;year\u0026#39;) \u0026#39;2012-01-01 00:00:00\u0026#39; dt.end_of(\u0026#39;year\u0026#39;) \u0026#39;2012-01-31 23:59:59\u0026#39; dt.start_of(\u0026#39;decade\u0026#39;) \u0026#39;2010-01-01 00:00:00\u0026#39; dt.end_of(\u0026#39;decade\u0026#39;) \u0026#39;2019-01-31 23:59:59\u0026#39; dt.start_of(\u0026#39;century\u0026#39;) \u0026#39;2000-01-01 00:00:00\u0026#39; dt.end_of(\u0026#39;century\u0026#39;) \u0026#39;2099-12-31 23:59:59\u0026#39; dt.start_of(\u0026#39;week\u0026#39;) \u0026#39;2012-01-30 00:00:00\u0026#39; dt.day_of_week == pendulum.MONDAY True # ISO8601 week starts on Monday dt.end_of(\u0026#39;week\u0026#39;) \u0026#39;2012-02-05 23:59:59\u0026#39; dt.day_of_week == pendulum.SUNDAY True # ISO8601 week ends on SUNDAY dt.next(pendulum.WEDNESDAY) \u0026#39;2012-02-01 00:00:00\u0026#39; dt.day_of_week == pendulum.WEDNESDAY True dt = pendulum.datetime(2012, 1, 1, 12, 0, 0) dt.next() \u0026#39;2012-01-08 00:00:00\u0026#39; dt.next(keep_time=True) \u0026#39;2012-01-08T12:00:00+00:00\u0026#39; dt = pendulum.datetime(2012, 1, 31, 12, 0, 0) dt.previous(pendulum.WEDNESDAY) \u0026#39;2012-01-25 00:00:00\u0026#39; dt.day_of_week == pendulum.WEDNESDAY True dt = pendulum.datetime(2012, 1, 1, 12, 0, 0) dt.previous() \u0026#39;2011-12-25 00:00:00\u0026#39; dt.previous(keep_time=True) \u0026#39;2011-12-25 12:00:00\u0026#39; start = pendulum.datetime(2014, 1, 1) end = pendulum.datetime(2014, 1, 30) start.average(end) \u0026#39;2014-01-15 12:00:00\u0026#39; # others that are defined that are similar # and tha accept month, quarter and year units # first_of(), last_of(), nth_of() Timezones Timezones are an important part of every datetime library and pendulum tries to provide an easy and accurate system to handle them properly.\nThe timezone system works best inside the pendulum ecosystem but can also be used with the standard datetime library with a few limitations. See Using the timezone library directly.\nNormalization When you create a DateTime instance, the library will normalize it for the given timezone to properly handle any transition that might have occurred.\nimport pendulum pendulum.datetime(2013, 3, 31, 2, 30, tz=\u0026#39;Europe/Paris\u0026#39;) # 2:30 for the 31th of March 2013 does not exist # so pendulum will return the actual time which is 3:30+02:00 \u0026#39;2013-03-31T03:30:00+02:00\u0026#39; pendulum.datetime(2013, 10, 27, 2, 30, tz=\u0026#39;Europe/Paris\u0026#39;) # Here, 2:30 exists twice in the day so pendulum will # assume that the transition already occurred \u0026#39;2013-10-27T02:30:00+01:00\u0026#39; You can, however, control the normalization behavior:\nimport pendulum pendulum.datetime(2013, 3, 31, 2, 30, 0, 0, tz=\u0026#39;Europe/Paris\u0026#39;, dst_rule=pendulum.PRE_TRANSITION) \u0026#39;2013-03-31T01:30:00+01:00\u0026#39; pendulum.datetime(2013, 10, 27, 2, 30, 0, 0, tz=\u0026#39;Europe/Paris\u0026#39;, dst_rule=pendulum.PRE_TRANSITION) \u0026#39;2013-10-27T02:30:00+02:00\u0026#39; pendulum.datetime(2013, 3, 31, 2, 30, 0, 0, tz=\u0026#39;Europe/Paris\u0026#39;, dst_rule=pendulum.TRANSITION_ERROR) # NonExistingTime: The datetime 2013-03-31 02:30:00 does not exist pendulum.datetime(2013, 10, 27, 2, 30, 0, 0, tz=\u0026#39;Europe/Paris\u0026#39;, dst_rule=pendulum.TRANSITION_ERROR) # AmbiguousTime: The datetime 2013-10-27 02:30:00 is ambiguous. Note that it only affects instances at creation time. Shifting time around transition times still behaves the same.\nShifting time to transition So, what happens when you add time to a DateTime instance and stumble upon a transition time? Well pendulum, provided with the context of the previous instance, will adopt the proper behavior and apply the transition accordingly.\nimport pendulum dt = pendulum.datetime(2013, 3, 31, 1, 59, 59, 999999, tz=\u0026#39;Europe/Paris\u0026#39;) \u0026#39;2013-03-31T01:59:59.999999+01:00\u0026#39; dt = dt.add(microseconds=1) \u0026#39;2013-03-31T03:00:00+02:00\u0026#39; dt.subtract(microseconds=1) \u0026#39;2013-03-31T01:59:59.999998+01:00\u0026#39; dt = pendulum.datetime(2013, 10, 27, 2, 59, 59, 999999, tz=\u0026#39;Europe/Paris\u0026#39;, dst_rule=pendulum.PRE_TRANSITION) \u0026#39;2013-10-27T02:59:59.999999+02:00\u0026#39; dt = dt.add(microseconds=1) \u0026#39;2013-10-27T02:00:00+01:00\u0026#39; dt = dt.subtract(microseconds=1) \u0026#39;2013-10-27T02:59:59.999999+02:00\u0026#39; Switching timezones You can easily change the timezone of a DateTime instance with the in_timezone() method.\nYou can also use the more concise in_tz()\nin_paris = pendulum.datetime(2016, 8, 7, 22, 24, 30, tz=\u0026#39;Europe/Paris\u0026#39;) \u0026#39;2016-08-07T22:24:30+02:00\u0026#39; in_paris.in_timezone(\u0026#39;America/New_York\u0026#39;) \u0026#39;2016-08-07T16:24:30-04:00\u0026#39; in_paris.in_tz(\u0026#39;Asia/Tokyo\u0026#39;) \u0026#39;2016-08-08T05:24:30+09:00\u0026#39; Using the timezone library directly You should avoid using the timezone library in Python \u0026lt; 3.6.\nThis is due to the fact that Pendulum relies heavily on the presence of the fold attribute which was introduced in Python 3.6.\nThe reason it works inside the Pendulum ecosystem is that it backported the fold attribute in the DateTime class.\nLike said in the introduction, you can use the timezone library directly with standard datetime objects but with limitations, especially when adding and subtracting time around transition times.\nThe value of the fold attribute will be used by default to determine the transition rule.\nfrom datetime import datetime from pendulum import timezone paris = timezone(\u0026#39;Europe/Paris\u0026#39;) dt = datetime(2013, 3, 31, 2, 30) # By default, fold is set to 0 dt = paris.convert(dt) dt.isoformat() \u0026#39;2013-03-31T01:30:00+01:00\u0026#39; dt = datetime(2013, 3, 31, 2, 30, fold=1) dt = paris.convert(dt) dt.isoformat() \u0026#39;2013-03-31T03:30:00+02:00\u0026#39; Instead of relying on the fold attribute, you can use the dst_rule keyword argument, this is especially useful if you want to raise errors on non-existing and ambiguous times.\nimport pendulum dt = datetime(2013, 3, 31, 2, 30) # By default, fold is set to 0 dt = paris.convert(dt, dst_rule=pendulum.PRE_TRANSITION) dt.isoformat() \u0026#39;2013-03-31T01:30:00+01:00\u0026#39; dt = paris.convert(dt, dst_rule=pendulum.POST_TRANSITION) dt.isoformat() \u0026#39;2013-03-31T03:30:00+02:00\u0026#39; paris.convert(dt, dst_rule=pendulum.TRANSITION_ERROR) # NonExistingTime: The datetime 2013-03-31 02:30:00 does not exist This works as expected. However, whenever we add or subtract a timedelta object, things get tricky.\nfrom datetime import datetime, timedelta from pendulum import timezone dt = datetime(2013, 3, 31, 1, 59, 59, 999999) dt = paris.convert(dt) dt.isoformat() \u0026#39;2013-03-31T01:59:59.999999+01:00\u0026#39; dt = dt + timedelta(microseconds=1) dt.isoformat() \u0026#39;2013-03-31T02:00:00+01:00\u0026#39; This is not what we expect, it should be 2013-03-31T03:00:00+02:00. This is actually easy to retrieve the proper datetime by using convert() again.\ndt = tz.convert(dt) dt.isoformat() \u0026#39;2013-03-31T03:00:00+02:00\u0026#39; You can also get a normalized datetime object from a Timezone by using the datetime() method:\nimport pendulum tz = pendulum.timezone(\u0026#39;Europe/Paris\u0026#39;) dt = tz.datetime(2013, 3, 31, 2, 30) dt.isoformat() \u0026#39;2013-03-31T03:30:00+02:00\u0026#39; Duration The Duration class is inherited from the native timedelta class. It has many improvements over the base class.\nEven though, it inherits from the timedelta class, its behavior is slightly different. The more important to notice is that the native normalization does not happen, this is so that it feels more intuitive.\nimport pendulum from datetime import datetime d1 = datetime(2012, 1, 1, 1, 2, 3, tzinfo=pytz.UTC) d2 = datetime(2011, 12, 31, 22, 2, 3, tzinfo=pytz.UTC) delta = d2 - d1 delta.days -1 delta.seconds 75600 d1 = pendulum.datetime(2012, 1, 1, 1, 2, 3) d2 = pendulum.datetime(2011, 12, 31, 22, 2, 3) delta = d2 - d1 delta.days 0 delta.hours -3 Instantiation To create a Duration instance, you can use the duration() helper:\nimport pendulum it = pendulum.duration(days=1177, seconds=7284, microseconds=1234) Unlike the native timedelta class, durations support specifying years and months.\nimport pendulum it = pendulum.duration(years=2, months=3) However, to maintain compatibility, native methods and properties will make approximations:\nit.days #820 it.total_seconds() #70848000.0 Properties and Duration Methods The Duration class brings more properties than the default days, seconds and microseconds.\nimport pendulum it = pendulum.duration( ... years=2, months=3, ... days=1177, seconds=7284, microseconds=1234 ... ) it.years 2 it.months 3 # Weeks are based on the total of days # It does not take into account years and months it.weeks 168 # Days, just like in timedelta, represents the total of days # in the duration. If years and/or months are specified # it will use an approximation it.days 1997 # If you want the remaining days not included in full weeks it.remaining_days 1 # The remaining number in each unit it.hours 2 it.minutes 1 # Seconds are, like days, a special case and the default # property will return the whole value of remaining # seconds just like the timedelta class for compatibility it.seconds 7284 # If you want the number of seconds not included # in hours and minutes it.remaining_seconds 24 it.microseconds 1234 If you want to get the duration in each supported unit you can use the appropriate methods.\n# Each method returns a float like the native # total_seconds() method it.total_weeks() 168.15490079569113 it.total_days() 1177.0843055698379 it.total_hours() 28250.02333367611 it.total_minutes() 1695001.4000205665 it.total_seconds() 101700084.001234 Similarly, the in_xxx() methods return the total duration in each supported unit as a truncated integer.\nit.in_weeks() 168 it.in_days() 1997 it.in_hours() 28250 it.in_minutes() 1695001 it.in_seconds() 101700084 It also has a handy `in_words()` method, which determines the duration representation when printed. import pendulum pendulum.set_locale(\u0026#39;fr\u0026#39;) it = pendulum.duration(days=1177, seconds=7284, microseconds=1234) it.in_words() \u0026#39;168 semaines 1 jour 2 heures 1 minute 24 secondes\u0026#39; print(it) \u0026#39;168 semaines 1 jour 2 heures 1 minute 24 secondes\u0026#39; it.in_words(locale=\u0026#39;de\u0026#39;) \u0026#39;168 Wochen 1 Tag 2 Stunden 1 Minute 24 Sekunden\u0026#39; Period When you subtract a DateTime instance to another, or use the diff() method, it will return a Period instance. It inherits from the Duration class with the added benefit that it is aware of the instances that generated it, so that it can give access to more methods and properties:\nimport pendulum start = pendulum.datetime(2000, 11, 20) end = pendulum.datetime(2016, 11, 5) period = end - start period.years 15 period.months 11 period.in_years() 15 period.in_months() 191 # Note that the weeks property # will change compared to the Duration class period.weeks 2 # 832 for the duration # However the days property will still remain the same # to keep the compatiblity with the timedelta class period.days 5829 Be aware that a period, just like an interval, is compatible with the timedelta class regarding its attributes. However, its custom attributes (like remaining_days) will be aware of any DST transitions that might have occurred and adjust accordingly. Let\u0026rsquo;s take an example:\nimport pendulum start = pendulum.datetime(2017, 3, 7, tz=\u0026#39;America/Toronto\u0026#39;) end = start.add(days=6) period = end - start # timedelta properties period.days 5 period.seconds 82800 # period properties period.remaining_days 6 period.hours 0 period.remaining_seconds 0 Due to its nature (fixed duration between two datetimes), most arithmetic operations will return a Duration instead of a Period.\nimport pendulum dt1 = pendulum.datetime(2016, 8, 7, 12, 34, 56) dt2 = dt1.add(days=6, seconds=34) period = pendulum.period(dt1, dt2) period * 2 Duration(weeks=1, days=5, minutes=1, seconds=8) Instantiation You can create an instance by using the period() helper:\nimport pendulum start = pendulum.datetime(2000, 1, 1) end = pendulum.datetime(2000, 1, 31) period = pendulum.period(start, end) You can also make an inverted period: period = pendulum.period(end, start) period.remaining_days -2 If you have inverted dates but want to make sure that the period is positive, you set the absolute keyword argument to True:\nperiod = pendulum.period(end, start, absolute=True) period.remaining_days 2\nRange If you want to iterate over a period, you can use the range() method:\nimport pendulum start = pendulum.datetime(2000, 1, 1) end = pendulum.datetime(2000, 1, 10) period = pendulum.period(start, end) for dt in period.range(\u0026#39;days\u0026#39;): print(dt) \u0026#39;2000-01-01T00:00:00+00:00\u0026#39; \u0026#39;2000-01-02T00:00:00+00:00\u0026#39; \u0026#39;2000-01-03T00:00:00+00:00\u0026#39; \u0026#39;2000-01-04T00:00:00+00:00\u0026#39; \u0026#39;2000-01-05T00:00:00+00:00\u0026#39; \u0026#39;2000-01-06T00:00:00+00:00\u0026#39; \u0026#39;2000-01-07T00:00:00+00:00\u0026#39; \u0026#39;2000-01-08T00:00:00+00:00\u0026#39; \u0026#39;2000-01-09T00:00:00+00:00\u0026#39; \u0026#39;2000-01-10T00:00:00+00:00\u0026#39; Supported units for range() are: years, months, weeks, days, hours, minutes and seconds\nYou can pass an amount for the passed unit to control the length of the gap:\nfor dt in period.range(\u0026#39;days\u0026#39;, 2): print(dt) \u0026#39;2000-01-01T00:00:00+00:00\u0026#39; \u0026#39;2000-01-03T00:00:00+00:00\u0026#39; \u0026#39;2000-01-05T00:00:00+00:00\u0026#39; \u0026#39;2000-01-07T00:00:00+00:00\u0026#39; \u0026#39;2000-01-09T00:00:00+00:00\u0026#39; You can also directly iterate over the Period instance, the unit will be days in this case:\nfor dt in period: print(dt) You can check if a DateTime instance is inside a period using the in keyword:\ndt = pendulum.datetime(2000, 1, 4) dt in period #True Testing The testing methods allow you to set a DateTime instance (real or mock) to be returned when a \u0026ldquo;now\u0026rdquo; instance is created. The provided instance will be returned specifically under the following conditions:\n A call to the now() method, ex. pendulum.now(). When the string \u0026ldquo;now\u0026rdquo; is passed to the parse() method, ex. pendulum.parse('now')  import pendulum # Create testing datetime known = pendulum.datetime(2001, 5, 21, 12) # Set the mock pendulum.set_test_now(known) print(pendulum.now()) \u0026#39;2001-05-21T12:00:00+00:00\u0026#39; print(pendulum.parse(\u0026#39;now\u0026#39;)) \u0026#39;2001-05-21T12:00:00+00:00\u0026#39; # Clear the mock pendulum.set_test_now() print(pendulum.now()) \u0026#39;2016-07-10T22:10:33.954851-05:00\u0026#39; Related methods will also returned values mocked according to the **now** instance. ```python print(pendulum.today()) \u0026#39;2001-05-21T00:00:00+00:00\u0026#39; print(pendulum.tomorrow()) \u0026#39;2001-05-22T00:00:00+00:00\u0026#39; print(pendulum.yesterday()) \u0026#39;2001-05-20T00:00:00+00:00\u0026#39; If you don\u0026rsquo;t want to manually clear the mock (or you are afraid of forgetting), you can use the provided test() contextmanager.\nimport pendulum known = pendulum.datetime(2001, 5, 21, 12) with pendulum.test(known): print(pendulum.now()) \u0026#39;2001-05-21T12:00:00+00:00\u0026#39; print(pendulum.now()) \u0026#39;2016-07-10T22:10:33.954851-05:00\u0026#39; Limitations Even though the DateTime class is a subclass of datetime, there are some rare cases where it can\u0026rsquo;t replace the native class directly. Here is a list (non-exhaustive) of the reported cases with a possible solution, if any:\n sqlite3 will use the the type() function to determine the type of the object by default. To work around it you can register a new adapter: import pendulum from sqlite3 import register_adapter register_adapter(pendulum.DateTime, lambda val: val.isoformat(\u0026#39; \u0026#39;))  mysqlclient (former MySQLdb) and PyMySQL will use the the type() function to determine the type of the object by default. To work around it you can register a new adapter: import pendulum import MySQLdb.converters import pymysql.converters MySQLdb.converters.conversions[pendulum.DateTime] = MySQLdb.converters.DateTime2literal pymysql.converters.conversions[pendulum.DateTime] = pymysql.converters.escape_datetime  django will use the isoformat() method to store datetimes in the database. However since pendulum is always timezone aware the offset information will always be returned by isoformat() raising an error, at least for MySQL databases. To work around it you can either create your own DateTimeField or use the previous workaround for MySQLdb: import pendulum from django.db.models import DateTimeField as BaseDateTimeField class DateTimeField(BaseDateTimeField): def value_to_string(self, obj): val = self.value_from_object(obj) if isinstance(value, pendulum.DateTime): return value.format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) return \u0026#39;\u0026#39; if val is None else val.isoformat()   \u0026gt; [Source : ](https://pendulum.eustace.io/docs/.) \u0026lt;!--stackedit_data: eyJoaXN0b3J5IjpbOTU5MTkyMDZdfQ== --\u0026gt;"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/",
	"title": "phyblas",
	"tags": [],
	"description": "",
	"content": "phyblas กำลังศึกษาต่ออยู่ที่มหาวิทยาลัยในไต้หวัน มีความสนใจในหลาย ๆ ด้าน เนื้อหาที่เขียนภายในบล็อกนี้ก็มีอยู่หลากหลาย ขึ้นอยู่กับความสนใจในแต่ละช่วง มีทั้งเรื่องราวท่องเที่ยว ซึ่งเน้นที่จีนและญี่ปุ่นเป็นหลัก นอกจากนี้ก็เขียนบันทึกประจำวัน ความรู้ทั่วไป ประสบการณ์ต่างๆ เรื่องราวรอบๆตัว แล้วก็เกี่ยวกับอนิเมะที่ดู เกมที่ได้เคยเล่นเป็นต้น\nReference : https://phyblas.hinaboshi.com/\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/files/file_operations/",
	"title": "Python File I/O",
	"tags": [],
	"description": "",
	"content": "In this tutorial, you\u0026rsquo;ll learn about Python file operations. More specifically, opening a file, reading from it, writing into it, closing it, and various file methods that you should be aware of.\nFiles Files are named locations on disk to store related information. They are used to permanently store data in a non-volatile memory (e.g. hard disk).\nSince Random Access Memory (RAM) is volatile (which loses its data when the computer is turned off), we use files for future use of the data by permanently storing them.\nWhen we want to read from or write to a file, we need to open it first. When we are done, it needs to be closed so that the resources that are tied with the file are freed.\nHence, in Python, a file operation takes place in the following order:\n Open a file Read or write (perform operation) Close the file   Opening Files in Python Python has a built-in open() function to open a file. This function returns a file object, also called a handle, as it is used to read or modify the file accordingly.\nf = open(\u0026#34;test.txt\u0026#34;) # open file in current directory f = open(\u0026#34;C:/Python38/README.txt\u0026#34;) # specifying full path We can specify the mode while opening a file. In mode, we specify whether we want to read r, write w or append a to the file. We can also specify if we want to open the file in text mode or binary mode.\nThe default is reading in text mode. In this mode, we get strings when reading from the file.\nOn the other hand, binary mode returns bytes and this is the mode to be used when dealing with non-text files like images or executable files.\n   Mode Description     r Opens a file for reading. (default)   w Opens a file for writing. Creates a new file if it does not exist or truncates the file if it exists.   x Opens a file for exclusive creation. If the file already exists, the operation fails.   a Opens a file for appending at the end of the file without truncating it. Creates a new file if it does not exist.   t Opens in text mode. (default)   b Opens in binary mode.   + Opens a file for updating (reading and writing)    Opens a file for updating (reading and writing)\nf = open(\u0026#34;test.txt\u0026#34;) # equivalent to \u0026#39;r\u0026#39; or \u0026#39;rt\u0026#39; f = open(\u0026#34;test.txt\u0026#34;,\u0026#39;w\u0026#39;) # write in text mode f = open(\u0026#34;img.bmp\u0026#34;,\u0026#39;r+b\u0026#39;) # read and write in binary mode Unlike other languages, the character a does not imply the number 97 until it is encoded using ASCII (or other equivalent encodings).\nMoreover, the default encoding is platform dependent. In windows, it is cp1252 but utf-8 in Linux.\nSo, we must not also rely on the default encoding or else our code will behave differently in different platforms.\nHence, when working with files in text mode, it is highly recommended to specify the encoding type.\nf = open(\u0026#34;test.txt\u0026#34;, mode=\u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;)  Closing Files in Python When we are done with performing operations on the file, we need to properly close the file.\nClosing a file will free up the resources that were tied with the file. It is done using the close() method available in Python.\nPython has a garbage collector to clean up unreferenced objects but we must not rely on it to close the file.\nf = open(\u0026#34;test.txt\u0026#34;, encoding = \u0026#39;utf-8\u0026#39;) # perform file operations f.close() This method is not entirely safe. If an exception occurs when we are performing some operation with the file, the code exits without closing the file.\nA safer way is to use a try\u0026hellip;finally block.\ntry: f = open(\u0026#34;test.txt\u0026#34;, encoding = \u0026#39;utf-8\u0026#39;) # perform file operations finally: f.close() This way, we are guaranteeing that the file is properly closed even if an exception is raised that causes program flow to stop.\nThe best way to close a file is by using the with statement. This ensures that the file is closed when the block inside the with statement is exited.\nWe don\u0026rsquo;t need to explicitly call the close() method. It is done internally.\nwith open(\u0026#34;test.txt\u0026#34;, encoding = \u0026#39;utf-8\u0026#39;) as f: # perform file operations  Writing to Files in Python In order to write into a file in Python, we need to open it in write w, append a or exclusive creation x mode.\nWe need to be careful with the w mode, as it will overwrite into the file if it already exists. Due to this, all the previous data are erased.\nWriting a string or sequence of bytes (for binary files) is done using the write() method. This method returns the number of characters written to the file.\nwith open(\u0026#34;test.txt\u0026#34;,\u0026#39;w\u0026#39;,encoding = \u0026#39;utf-8\u0026#39;) as f: f.write(\u0026#34;my first file\\n\u0026#34;) f.write(\u0026#34;This file\\n\\n\u0026#34;) f.write(\u0026#34;contains three lines\\n\u0026#34;) This program will create a new file named test.txt in the current directory if it does not exist. If it does exist, it is overwritten.\nWe must include the newline characters ourselves to distinguish the different lines.\n Reading Files in Python To read a file in Python, we must open the file in reading r mode.\nThere are various methods available for this purpose. We can use the read(size) method to read in the size number of data. If the size parameter is not specified, it reads and returns up to the end of the file.\nWe can read the text.txt file we wrote in the above section in the following way:\nf = open(\u0026#34;test.txt\u0026#34;,\u0026#39;r\u0026#39;,encoding = \u0026#39;utf-8\u0026#39;) f.read(4) # read the first 4 data \u0026#39;This\u0026#39; f.read(4) # read the next 4 data \u0026#39; is \u0026#39; f.read() # read in the rest till end of file \u0026#39;my first file\\nThis file\\ncontains three lines\\n\u0026#39; f.read() # further reading returns empty sting \u0026#39;\u0026#39; We can see that the read() method returns a newline as '\\n'. Once the end of the file is reached, we get an empty string on further reading.\nWe can change our current file cursor (position) using the seek() method. Similarly, the tell() method returns our current position (in number of bytes).\nf.tell() # get the current file position 56 f.seek(0) # bring file cursor to initial position 0 print(f.read()) # read the entire file This is my first file This file contains three lines We can read a file line-by-line using a for loop. This is both efficient and fast.\nfor line in f: ... print(line, end = \u0026#39;\u0026#39;) ... This is my first file This file contains three lines In this program, the lines in the file itself include a newline character \\n. So, we use the end parameter of the print() function to avoid two newlines when printing.\nAlternatively, we can use the readline() method to read individual lines of a file. This method reads a file till the newline, including the newline character.\nf.readline() \u0026#39;This is my first file\\n\u0026#39; f.readline() \u0026#39;This file\\n\u0026#39; f.readline() \u0026#39;contains three lines\\n\u0026#39; f.readline() \u0026#39;\u0026#39; Lastly, the readlines() method returns a list of remaining lines of the entire file. All these reading methods return empty values when the end of file (EOF) is reached.\nf.readlines() [\u0026#39;This is my first file\\n\u0026#39;, \u0026#39;This file\\n\u0026#39;, \u0026#39;contains three lines\\n\u0026#39;]  Python File Methods There are various methods available with the file object. Some of them have been used in the above examples.\nHere is the complete list of methods in text mode with a brief description:\n   Method Description     close() Closes an opened file. It has no effect if the file is already closed.   detach() Separates the underlying binary buffer from the TextIOBase and returns it.   fileno() Returns an integer number (file descriptor) of the file.   flush() Flushes the write buffer of the file stream.   isatty() Returns True if the file stream is interactive.   read(n) Reads at most n characters from the file. Reads till end of file if it is negative or None.   readable() Returns True if the file stream can be read from.   readline(n=-1) Reads and returns one line from the file. Reads in at most n bytes if specified.   readlines(n=-1) Reads and returns a list of lines from the file. Reads in at most n bytes/characters if specified.   seek(offset,from=SEEK_SET) Changes the file position to offset bytes, in reference to from (start, current, end).   seekable() Returns True if the file stream supports random access.   tell() Returns the current file location.   truncate(size=None) Resizes the file stream to size bytes. If size is not specified, resizes to current location.   writable() Returns True if the file stream can be written to.   write(s) Writes the string s to the file and returns the number of characters written.   writelines(lines) Writes a list of lines to the file.     Source : https://www.programiz.com/python-programming/file-operation\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/w3resource/",
	"title": "Python Tutorial (w3resource)",
	"tags": [],
	"description": "",
	"content": " Reference : https://www.w3resource.com/python/python-tutorial.php\n What is Python?  Python is an open source, object-oriented, high-level powerful programming language. Developed by Guido van Rossum in the early 1990s. Named after Monty Python Python runs on many Unix variants, on the Mac, and on Windows 2000 and later. Available for download from http://www.python.org.  Contents:\n Python Program Features of Python Python Interpreter How stable is Python? History Python Language Overview Python Environment Major uses of Python Organizations Using Python (sector wise) Is Python a good language for beginning programmers? Features of the w3resource Python tutorials Python Exercises, Practice and Solution  Python Program  Python programs are composed of modules Modules contain statements Statements contain expressions Expressions create and process objects  Features of Python Open source: Python is publicly available open source software, any one can use source code that doesn\u0026rsquo;t cost anything.\nEasy-to-learn: Popular (scripting/extension) language, clear and easy syntax, no type declarations, automatic memory management, high-level data types and operations, design to read (more English like syntax) and write (shorter code compared to C, C++, and Java) fast.\nHigh-level Language:\nHigh-level language (closer to human) refers to the higher level of concept from machine language (for example assembly languages). Python is an example of a high-level language like C, C++, Perl, and Java with low-level optimization.\nPortable:\nHigh level languages are portable, which means they are able to run across all major hardware and software platforms with few or no change in source code. Python is portable and can be used on Linux, Windows, Macintosh, Solaris, FreeBSD, OS/2, Amiga, AROS, AS/400 and many more.\nObject-Oriented: Python is a full-featured object-oriented programming language, with features such as classes, inheritance, objects, and overloading.\nPython is Interactive :\nPython has an interactive console where you get a Python prompt (command line) and interact with the interpreter directly to write and test your programs. This is useful for mathematical programming.\nInterpreted : Python programs are interpreted, takes source code as input, and then compiles (to portable byte-code) each statement and executes it immediately. No need to compiling or linking\nExtendable : Python is often referred to as a \u0026ldquo;glue\u0026rdquo; language, meaning that it is capable to work in mixed-language environment. The Python interpreter is easily extended and can add a new built-in function or modules written in C/C++/Java code.\nLibraries : Databases, web services, networking, numerical packages, graphical user interfaces, 3D graphics, others.\n**Supports :**Support from online Python community\nPython Interpreter  In interactive mode, type Python programs and the interpreter displays the result: Type python into your terminal\u0026rsquo;s command line After a short message, the \u0026raquo;\u0026gt; symbol will appear The above symbol signals the start of a Python interpreter\u0026rsquo;s command line. Python interpreter evaluates inputs (For example \u0026raquo;\u0026gt; 4*(6-2) return 16)  How stable is Python? Very stable. New, stable releases have been coming out roughly every 6 to 18 months since 1991, and this seems likely to continue. Currently there are usually around 18 months between major releases.\nThe latest stable releases can always be found on the Python download page. There are two recommended production-ready versions at this point in time, because at the moment there are two branches of stable releases: 2.x and 3.x.\nHistory The name Python was selected from \u0026ldquo;Monty Python\u0026rsquo;s Flying Circus\u0026rdquo; which was a British sketch comedy series created by the comedy group Monty Python and broadcast by the BBC from 1969 to 1974.\nPython was created in the early 1990s by Guido van Rossum at the National Research Institute for Mathematics and Computer Science in Netherlands.\nPython was created as a successor of a language called ABC (All Basic Code) and released publicly in1991. Guido remains Python\u0026rsquo;s principal author, although it includes many contributions from active user community.\nBetween 1991 and 2001 there are several versions released, current stable release is 3.2. In 2001 the Python Software Foundation (PSF) was formed, a non-profit organization created specifically to own Python-related Intellectual Property. Zope Corporation is a sponsoring member of the PSF.\nAll most all Python releases are Open Source. To see the details of release versions and licence agreement of Python check here.\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/w3resource/bytes/",
	"title": "Python: Bytes, Bytearray",
	"tags": [],
	"description": "",
	"content": "Bytes, Bytearray Python supports a range of types to store sequences. There are six sequence types: strings, byte sequences (bytes objects), byte arrays (bytearray objects), lists, tuples, and range objects.\nStrings contain Unicode characters. Their literals are written in single or double quotes : \u0026lsquo;python\u0026rsquo;, \u0026ldquo;data\u0026rdquo;. Bytes and bytearray objects contain single bytes – the former is immutable while the latter is a mutable sequence. Bytes objects can be constructed the constructor, bytes(), and from literals; use a b prefix with normal string syntax: b\u0026rsquo;python\u0026rsquo;. To construct byte arrays, use the bytearray() function.\nContents\n Bytes literals bytes() and bytearray() functions Create a bytes object in Python Convert bytes to string Convert hex string to bytes Numeric code representing a character of a bytes object in Python Define a mapping table characters for use with a bytes object in Python Convert bytes to hex in Python How to get the character from the numeric code in bytes objects in Python Determine the length of a bytes object in Python Use the operators + and * with bytes objects in Python How to get a byte from a bytes object in Python Create a bytearray object Difference between bytes and bytearray object in Python Convert a bytes to bytearray Slice of a bytes object in Python Difference between bytes and string object  Bytes literals bytesliteral ::= bytesprefix(shortbytes | longbytes) bytesprefix ::= \u0026#34;b\u0026#34; | \u0026#34;B\u0026#34; | \u0026#34;br\u0026#34; | \u0026#34;Br\u0026#34; | \u0026#34;bR\u0026#34; | \u0026#34;BR\u0026#34; shortbytes ::= \u0026#34;\u0026#39;\u0026#34; shortbytesitem* \u0026#34;\u0026#39;\u0026#34; | \u0026#39;\u0026#34;\u0026#39; shortbytesitem* \u0026#39;\u0026#34;\u0026#39; longbytes ::= \u0026#34;\u0026#39;\u0026#39;\u0026#39;\u0026#34; longbytesitem* \u0026#34;\u0026#39;\u0026#39;\u0026#39;\u0026#34; | \u0026#39;\u0026#34;\u0026#34;\u0026#34;\u0026#39; longbytesitem* \u0026#39;\u0026#34;\u0026#34;\u0026#34;\u0026#39; shortbytesitem ::= shortbyteschar | bytesescapeseq longbytesitem ::= longbyteschar | bytesescapeseq shortbyteschar ::= \u0026lt;any ASCII character except \u0026#34;\\\u0026#34; or newline or the quote\u0026gt; longbyteschar ::= \u0026lt;any ASCII character except \u0026#34;\\\u0026#34;\u0026gt; bytesescapeseq ::= \u0026#34;\\\u0026#34; \u0026lt;any ASCII character\u0026gt; bytes() and bytearray() functions bytes() function:\nReturn a new \u0026ldquo;bytes\u0026rdquo; object, which is an immutable sequence of small integers in the range 0 \u0026lt;= x \u0026lt; 256, print as ASCII characters when displayed. bytes is an immutable version of bytearray – it has the same non-mutating methods and the same indexing and slicing behavior.\nSyntax:\nbytes([source[, encoding[, errors]]]) bytearray() function :\nReturn a new array of bytes. The bytearray type is a mutable sequence of integers in the range 0 \u0026lt;= x \u0026lt; 256. It has most of the usual methods of mutable sequences, described in Mutable Sequence Types, as well as most methods that the bytes type has, see Bytes and Byte Array Methods.\nSyntax:\nbytearray([source[, encoding[, errors]]]) The optional source parameter can be used to initialize the array in a few different ways:\n If it is a string, you must also give the encoding (and optionally, errors) parameters; bytearray() then converts the string to bytes using str.encode(). If it is an integer, the array will have that size and will be initialized with null bytes. If it is an object conforming to the buffer interface, a read-only buffer of the object will be used to initialize the bytes array. If it is iterable, it must be an iterable of integers in the range 0 \u0026lt;= x \u0026lt; 256, which are used as the initial contents of the array.  Without an argument, an array of size 0 is created.\nCreate a bytes object in Python Example-1 :\nCode :\n\u0026gt;\u0026gt;\u0026gt; x = b\u0026#34;Bytes objects are immutable sequences of single bytes\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(x) b\u0026#39;Bytes objects are immutable sequences of single bytes\u0026#39; \u0026gt;\u0026gt;\u0026gt; Copy\nExample-2:\nCode:\n#triple single or double quotes allows multiple lines x = b\u0026#39;\u0026#39;\u0026#39;Python Tutorial, Javascript Tutorial, MySQL Tutorial\u0026#39;\u0026#39;\u0026#39; print(x) Output:\nb\u0026#39;Python Tutorial,\\nJavascript Tutorial,\\nMySQL Tutorial\u0026#39; Example-3 :\nCode :\n#created from a iterable of ints, string, bytes or buffer objects. x = bytes(\u0026#39;Python, bytes\u0026#39;, \u0026#39;utf8\u0026#39;) print(x) Output:\nb\u0026#39;Python, bytes\u0026#39; Convert bytes to string Example-1:\nCode:\n#create a bytes object x = b\u0026#39;El ni\\xc3\\xb1o come camar\\xc3\\xb3n\u0026#39; print(x) Copy\nOutput:\nb\u0026#39;El ni\\xc3\\xb1o come camar\\xc3\\xb3n\u0026#39; Example-2:\nCode:\n# create a string using the decode() method of bytes.  #This method takes an encoding argument, such as UTF-8, and optionally an errors argument. x = b\u0026#39;El ni\\xc3\\xb1o come camar\\xc3\\xb3n\u0026#39; s = x.decode() print(type(s)) print(s) Output:\nEl niño come camarón Example-3:\nCode:\n#create a bytes object encoded using \u0026#39;cp855\u0026#39; x = b\u0026#39;\\xd8\\xe1\\xb7\\xeb\\xa8\\xe5\\xd2\\xb7\\xe1\u0026#39; print(x) #return a string using decode \u0026#39;cp855\u0026#39; y = x.decode(\u0026#39;cp855\u0026#39;) print(y) Output:\nb\u0026#39;\\xd8\\xe1\\xb7\\xeb\\xa8\\xe5 \\xd2\\xb7\\xe1\u0026#39; привет мир Convert hex string to bytes Example-1:\nCode :\n#create a string with hexadecimal data x = \u0026#39;45678c6c56f205876f72c64\u0026#39; print(x) Output:\n45678c6c56f205876f72c64 Example-2:\n#this class method returns a bytes object, decoding the given string object. #the string must contain two hexadecimal digits per byte. x = \u0026#39;45678c6c56f205876f72c64\u0026#39; y = bytes.fromhex(x) Output:\nb\u0026#39;.\\xf0\\xf1\\xf2\u0026#39; Numeric code representing a character of a bytes object in Python Example-1:\nCode:\n#return an integer representing the Unicode code point of that character. x = ord(b\u0026#39;m\u0026#39;) print(x) Copy\nOutput:\n109 Example-2:\nCode:\n#create a bytes object y = b\u0026#39;Python bytes\u0026#39; #generates a list of codes from the characters of bytes z = list(y) print(z) Output:\n[80, 121, 116, 104, 111, 110, 32, 98, 121, 116, 101, 115] Define a mapping table characters for use with a bytes object in Python Example-1:\nCode:\n#create a str x = b\u0026#39;Python mapping table characters\u0026#39; print(x) Output:\nb\u0026#39;Python mapping table characters\u0026#39; Example-2:\nCode:\nb_table = bytes.maketrans(b\u0026#39;abcdef\u0026#39;, b\u0026#39;uvwxyz\u0026#39;) print(type(b_table)) print(b_table) Copy\nOutput:\n\u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; b\u0026#39;\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\u0026#34;#$% \u0026amp;\\\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`uvwxyzghijklmnopqrstuvwxyz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x 90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\ xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3 \\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf 5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\u0026#39; Example-3:\nCode:\nb_table = bytes.maketrans(b\u0026#39;abcdef\u0026#39;, b\u0026#39;uvwxyz\u0026#39;) str = \u0026#39;Write a Python function to find a distinct pair of numbers whose product is odd from a sequence of integer values.\u0026#39; b_new = str.translate(b_table) print(b_new) Output:\nWrity u Python zunwtion to zinx u xistinwt puir oz numvyrs whosy proxuwt is oxx zrom u syquynwy oz intygyr vuluys. Convert bytes to hex in Python \u0026gt;\u0026gt;\u0026gt; import binascii \u0026gt;\u0026gt;\u0026gt; binascii.hexlify(\u0026#34;Python\u0026#34;.encode(\u0026#34;utf8\u0026#34;)) b\u0026#39;507974686f6e\u0026#39; \u0026gt;\u0026gt;\u0026gt; binascii.unhexlify(_).decode(\u0026#34;utf8\u0026#34;) \u0026#39;Python\u0026#39; \u0026gt;\u0026gt;\u0026gt; How to get the character from the numeric code in bytes objects in Python \u0026gt;\u0026gt;\u0026gt; #this method return a single character based on the integer value. \u0026gt;\u0026gt;\u0026gt; x = chr(60) \u0026gt;\u0026gt;\u0026gt; print(x) \u0026lt; \u0026gt;\u0026gt;\u0026gt; x = chr(50) \u0026gt;\u0026gt;\u0026gt; print(x) 2 \u0026gt;\u0026gt;\u0026gt; #create a list with integers in the range 0 through 255 \u0026gt;\u0026gt;\u0026gt; y = [70, 111, 106, 94, 101, 100, 22, 95, 105, 22, 91, 87, 125, 135] \u0026gt;\u0026gt;\u0026gt; print(y) [70, 111, 106, 94, 101, 100, 22, 95, 105, 22, 91, 87, 125, 135] \u0026gt;\u0026gt;\u0026gt; #create a bytes object from a list of integers in the range 0 through 255. \u0026gt;\u0026gt;\u0026gt; z = bytes(y) \u0026gt;\u0026gt;\u0026gt; print(z) b\u0026#39;Foj^ed\\x16_i\\x16[W}\\x87\u0026#39; \u0026gt;\u0026gt;\u0026gt; Determine the length of a bytes object in Python \u0026gt;\u0026gt;\u0026gt; #create a string \u0026gt;\u0026gt;\u0026gt; x = \u0026#34;Python, Bytes\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(x) Python, Bytes \u0026gt;\u0026gt;\u0026gt; #know the length of the string using the len() function \u0026gt;\u0026gt;\u0026gt; print(len(x)) 13 \u0026gt;\u0026gt;\u0026gt; #create a bytes object \u0026gt;\u0026gt;\u0026gt; y = bytes(x, \u0026#34;utf8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(y) b\u0026#39;Python, Bytes\u0026#39; \u0026gt;\u0026gt;\u0026gt; #know the length of the bytes object using the len() function \u0026gt;\u0026gt;\u0026gt; print(len(y)) 13 \u0026gt;\u0026gt;\u0026gt; Use the operators + and * with bytes objects in Python \u0026gt;\u0026gt;\u0026gt; #create a bytes object \u0026gt;\u0026gt;\u0026gt; x = b\u0026#34;byte 213\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(x) b\u0026#39;byte 213\u0026#39; \u0026gt;\u0026gt;\u0026gt; #The * operator allow repeat the characters of a bytes object \u0026gt;\u0026gt;\u0026gt; print(x * 5) b\u0026#39;byte 213byte 213byte 213byte 213byte 213\u0026#39; \u0026gt;\u0026gt;\u0026gt; #create two bytes objects. \u0026gt;\u0026gt;\u0026gt; x1 = bytes([70, 111, 106, 94, 101, 100, 22, 95, 105, 22, 91, 87, 125, 135]) \u0026gt;\u0026gt;\u0026gt; x2 = b\u0026#34;Python\u0026#34; \u0026gt;\u0026gt;\u0026gt; #The + operator allow create a new bytes object joining two or more bytes. \u0026gt;\u0026gt;\u0026gt; x = x1 + x2 \u0026gt;\u0026gt;\u0026gt; print(x) b\u0026#39;Foj^ed\\x16_i\\x16[W}\\x87Python\u0026#39; \u0026gt;\u0026gt;\u0026gt; #create a bytes object combining operators \u0026gt;\u0026gt;\u0026gt; x = b\u0026#34;Python\u0026#34; + b\u0026#34;Bytes\u0026#34; * 3 + b\u0026#34;$\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(x) b\u0026#39;PythonBytesBytesBytes$\u0026#39; \u0026gt;\u0026gt;\u0026gt; How to get a byte from a bytes object in Python? \u0026gt;\u0026gt;\u0026gt; y = [80, 121, 116, 104, 111, 110, 32, 105, 115, 32, 101, 97, 115, 121] \u0026gt;\u0026gt;\u0026gt; print(y) [80, 121, 116, 104, 111, 110, 32, 105, 115, 32, 101, 97, 115, 121] \u0026gt;\u0026gt;\u0026gt; #create a bytes object \u0026gt;\u0026gt;\u0026gt; x1 = bytes([70, 111, 106, 94, 101, 100, 22, 95, 105, 22, 91, 87, 125, 135]) \u0026gt;\u0026gt;\u0026gt; print(x1) b\u0026#39;Foj^ed\\x16_i\\x16[W}\\x87\u0026#39; \u0026gt;\u0026gt;\u0026gt; #is similar to the handling of lists, the index is defined in brackets \u0026gt;\u0026gt;\u0026gt; x = y[3] \u0026gt;\u0026gt;\u0026gt; print(x) 104 \u0026gt;\u0026gt;\u0026gt; print(chr(x)) h \u0026gt;\u0026gt;\u0026gt; #can also use negative indices to get a byte from bytes object \u0026gt;\u0026gt;\u0026gt; x = [-8] \u0026gt;\u0026gt;\u0026gt; print(x) [-8] \u0026gt;\u0026gt;\u0026gt; x = y[-8] \u0026gt;\u0026gt;\u0026gt; print(x) 110 \u0026gt;\u0026gt;\u0026gt; print(chr(x)) n \u0026gt;\u0026gt;\u0026gt; Create a bytearray object in Python \u0026gt;\u0026gt;\u0026gt; #create a bytearray from a bytes object \u0026gt;\u0026gt;\u0026gt; x = bytearray(b\u0026#34;Python Bytes\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(x) bytearray(b\u0026#39;Python Bytes\u0026#39;) \u0026gt;\u0026gt;\u0026gt; #create a bytearray from a string defining the standard of coding \u0026gt;\u0026gt;\u0026gt; x = bytearray(\u0026#34;Python Bytes\u0026#34;, \u0026#34;utf8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(x) bytearray(b\u0026#39;Python Bytes\u0026#39;) \u0026gt;\u0026gt;\u0026gt; #create a bytearray from a list of integers in the range 0 through 255 \u0026gt;\u0026gt;\u0026gt; x = bytearray([94, 91, 101, 125, 111, 35, 120, 101, 115, 101, 200]) \u0026gt;\u0026gt;\u0026gt; print(x) bytearray(b\u0026#39;^[e}o#xese\\xc8\u0026#39;) \u0026gt;\u0026gt;\u0026gt; Difference between bytes and bytearray object in Python \u0026gt;\u0026gt;\u0026gt; #bytearray objects are a mutable counterpart to bytes objects \u0026gt;\u0026gt;\u0026gt; x = bytearray(\u0026#34;Python bytearray\u0026#34;, \u0026#34;utf8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(x) bytearray(b\u0026#39;Python bytearray\u0026#39;) \u0026gt;\u0026gt;\u0026gt; #can remove items from the bytes \u0026gt;\u0026gt;\u0026gt; del x[11:15] \u0026gt;\u0026gt;\u0026gt; print(x) bytearray(b\u0026#39;Python bytey\u0026#39;) \u0026gt;\u0026gt;\u0026gt; #can add items from the bytes \u0026gt;\u0026gt;\u0026gt; x[11:15] = b\u0026#34; object\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(x) bytearray(b\u0026#39;Python byte object\u0026#39;) \u0026gt;\u0026gt;\u0026gt; #can use the methods of mutable type iterable objects as the lists \u0026gt;\u0026gt;\u0026gt; x.append(45) \u0026gt;\u0026gt;\u0026gt; print(x) bytearray(b\u0026#39;Python byte object-\u0026#39;) \u0026gt;\u0026gt;\u0026gt; Convert a bytes to bytearray \u0026gt;\u0026gt;\u0026gt; #create a bytes object from a list of integers in the range 0 through 255 \u0026gt;\u0026gt;\u0026gt; x = bytes([105, 100, 107, 112, 132, 118, 107, 112, 200]) \u0026gt;\u0026gt;\u0026gt; print(x) b\u0026#39;idkp\\x84vkp\\xc8\u0026#39; \u0026gt;\u0026gt;\u0026gt; #generates a new array of bytes from a bytes object \u0026gt;\u0026gt;\u0026gt; x1 = bytearray(x) \u0026gt;\u0026gt;\u0026gt; print(x1) bytearray(b\u0026#39;idkp\\x84vkp\\xc8\u0026#39;) \u0026gt;\u0026gt;\u0026gt; Slice of a bytes object in Python \u0026gt;\u0026gt;\u0026gt; #create a bytes object \u0026gt;\u0026gt;\u0026gt; x = b\u0026#34;Python slice\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(x) b\u0026#39;Python slice\u0026#39; \u0026gt;\u0026gt;\u0026gt; #b[start:stop] the start index is inclusive and the end index is exclusive. \u0026gt;\u0026gt;\u0026gt; x1 = x[2:6] \u0026gt;\u0026gt;\u0026gt; print(x1) b\u0026#39;thon\u0026#39; \u0026gt;\u0026gt;\u0026gt; #if the start index isn\u0026#39;t defined, is starts from the beginning \u0026gt;\u0026gt;\u0026gt; x1 = x[-5:] \u0026gt;\u0026gt;\u0026gt; print(x1) b\u0026#39;slice\u0026#39; \u0026gt;\u0026gt;\u0026gt; #if the end index isn\u0026#39;t defined, it goes until the end \u0026gt;\u0026gt;\u0026gt; x1 = x[:4] \u0026gt;\u0026gt;\u0026gt; print(x1) b\u0026#39;Pyth\u0026#39; \u0026gt;\u0026gt;\u0026gt; #if neither is defined, returns the full bytes object \u0026gt;\u0026gt;\u0026gt; x1 = x[:] \u0026gt;\u0026gt;\u0026gt; print(x1) b\u0026#39;Python slice\u0026#39; \u0026gt;\u0026gt;\u0026gt; Difference between bytes and string object \u0026gt;\u0026gt;\u0026gt; # bytes objects are immutable sequences of integers, each value in the sequence \u0026gt;\u0026gt;\u0026gt; # string objects are immutable sequences of unicode characters. \u0026gt;\u0026gt;\u0026gt; x = \u0026#34;Python String\u0026#34; \u0026gt;\u0026gt;\u0026gt; y = b\u0026#34;Python String\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(x) Python String \u0026gt;\u0026gt;\u0026gt; print(y) b\u0026#39;Python String\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Found in unicode representation of characters but not in ascii \u0026gt;\u0026gt;\u0026gt; x = \u0026#34;Python\u0026#34; \u0026gt;\u0026gt;\u0026gt; y = bytes(\u0026#34;Python\u0026#34;, \u0026#34;utf8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(x) Python \u0026gt;\u0026gt;\u0026gt; print(y) b\u0026#39;Python\u0026#39; \u0026gt;\u0026gt;\u0026gt;  Reference : https://www.w3resource.com/python/python-bytes.php\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/quick_guide/",
	"title": "Python: Quick Guide",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/w3resource/regular_expression/",
	"title": "Python: Regular Expression",
	"tags": [],
	"description": "",
	"content": " Reference : https://www.w3resource.com/python/python-regular-expression.php\n A regular expression (or RE) specifies a set of strings that matches it; the functions in this module let you check if a particular string matches a given regular expression (or if a given regular expression matches a particular string, which comes down to the same thing).\nContents:\n Compare HTML tags re.findall() match string Group Comparison Non capturing group Back Reference Named Grouping (?P) Substitute String Look around Match common username or password Match hex color value Match email Match URL Match IP address Match Mac address Lexer Python Regular Expression - Exercises, Practice, Solution  The following table provides a list and description of the special pattern matching characters that can be used in regular expressions.\nMatches only at the end of the string.\nCompare HTML tags :    tag type format example     open tag \u0026lt;[^/\u0026gt;][^\u0026gt;]*\u0026gt; \u0026lt;a\u0026gt;, \u0026lt;table\u0026gt;   close tag \u0026lt;/[^\u0026gt;]+\u0026gt; \u0026lt;/p\u0026gt;, \u0026lt;/a\u0026gt;   self close \u0026lt;[^/\u0026gt;]+/\u0026gt; \u0026lt;br /\u0026gt;   all tag \u0026lt;[^\u0026gt;]+\u0026gt; \u0026lt;br /\u0026gt;, \u0026lt;a\u0026gt;    # open tag \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#39;\u0026lt;[^/\u0026gt;][^\u0026gt;]*\u0026gt;\u0026#39;, \u0026#39;\u0026lt;table\u0026gt;\u0026#39;) != None True \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#39;\u0026lt;[^/\u0026gt;][^\u0026gt;]*\u0026gt;\u0026#39;, \u0026#39;\u0026lt;a href=\u0026#34;#label\u0026#34;\u0026gt;\u0026#39;) != None True \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#39;\u0026lt;[^/\u0026gt;][^\u0026gt;]*\u0026gt;\u0026#39;, \u0026#39;\u0026lt;img src=\u0026#34;/img\u0026#34;\u0026gt;\u0026#39;) != None True \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#39;\u0026lt;[^/\u0026gt;][^\u0026gt;]*\u0026gt;\u0026#39;, \u0026#39;\u0026lt;/table\u0026gt;\u0026#39;) != None False # close tag \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#39;\u0026lt;/[^\u0026gt;]+\u0026gt;\u0026#39;, \u0026#39;\u0026lt;/table\u0026gt;\u0026#39;) != None True # self close \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#39;\u0026lt;[^/\u0026gt;]+/\u0026gt;\u0026#39;, \u0026#39;\u0026lt;br /\u0026gt;\u0026#39;) != None True re.findall() match string : # split all string \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; source = \u0026#34;split all string\u0026#34; \u0026gt;\u0026gt;\u0026gt; re.findall(\u0026#39;[\\w]+\u0026#39;, source) [\u0026#39;split\u0026#39;, \u0026#39;all\u0026#39;, \u0026#39;string\u0026#39;] # parsing python.org website \u0026gt;\u0026gt;\u0026gt; import urllib \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; x = urllib.urlopen(\u0026#39;https://www.w3resource.org\u0026#39;) \u0026gt;\u0026gt;\u0026gt; html = x.read() \u0026gt;\u0026gt;\u0026gt; x.close() \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;open tags\u0026#34;) open tags \u0026gt;\u0026gt;\u0026gt; re.findall(\u0026#39;\u0026lt;[^/\u0026gt;][^\u0026gt;]*\u0026gt;\u0026#39;, html)[0:2] [\u0026#39;\u0026lt;!doctype html\u0026gt;\u0026#39;, \u0026#39;\u0026lt;!-[if lt IE 7]\u0026gt;\u0026#39;] \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;close tags\u0026#34;) close tags \u0026gt;\u0026gt;\u0026gt; re.findall(\u0026#39;\u0026lt;/[^\u0026gt;]+\u0026gt;\u0026#39;, html)[0:2] [\u0026#39;\u0026lt;/script\u0026gt;\u0026#39;, \u0026#39;\u0026lt;/title\u0026gt;\u0026#39;] \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;self-closing tags\u0026#34;) Group Comparison : # (...) group a regular expression \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; mon = re.search(r\u0026#39;(\\d{4})-(\\d{2})-(\\d{2})\u0026#39;, \u0026#39;2018-09-01\u0026#39;) \u0026gt;\u0026gt;\u0026gt; mon \u0026lt;_sre.SRE_Match object at 0x019A72F0\u0026gt; \u0026gt;\u0026gt;\u0026gt; mon.groups() (\u0026#39;2018\u0026#39;, \u0026#39;09\u0026#39;, \u0026#39;01\u0026#39;) \u0026gt;\u0026gt;\u0026gt; mon.group() \u0026#39;2018-09-01\u0026#39;) \u0026gt;\u0026gt;\u0026gt; mon.group(1) \u0026#39;2018\u0026#39; \u0026gt;\u0026gt;\u0026gt; mon.group(2) \u0026#39;09\u0026#39; \u0026gt;\u0026gt;\u0026gt; mon.group(3) \u0026#39;01\u0026#39; # Nesting groups \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; mon = re.search(r\u0026#39;(((\\d{4})-\\d{2})-\\d{2})\u0026#39;, \u0026#39;2018-09-01\u0026#39;) \u0026gt;\u0026gt;\u0026gt; mon.groups() (\u0026#39;2018-09-01\u0026#39;, \u0026#39;2018-09\u0026#39;, \u0026#39;2018\u0026#39;) \u0026gt;\u0026gt;\u0026gt; mon.group() \u0026#39;2018-09-01\u0026#39; \u0026gt;\u0026gt;\u0026gt; mon.group(1) \u0026#39;2018-09-01\u0026#39; \u0026gt;\u0026gt;\u0026gt; mon.group(2) \u0026#39;2018-09\u0026#39; \u0026gt;\u0026gt;\u0026gt; mon.group(3) \u0026#39;2018\u0026#39; Non capturing group : # non capturing group \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; url = \u0026#39;http://w3resource.com/\u0026#39; \u0026gt;\u0026gt;\u0026gt; mon = re.search(\u0026#39;(?:http|ftp)://([^/\\r\\n]+)(/[^\\r\\n]*)?\u0026#39;, url) \u0026gt;\u0026gt;\u0026gt; mon.groups() (\u0026#39;w3resource.com\u0026#39;, \u0026#39;/\u0026#39;) # capturing group \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; mon = re.search(\u0026#39;(http|ftp)://([^/\\r\\n]+)(/[^\\r\\n]*)?\u0026#39;, url) \u0026gt;\u0026gt;\u0026gt; mon.groups() (\u0026#39;http\u0026#39;, \u0026#39;w3resource.com\u0026#39;, \u0026#39;/\u0026#39;) Back Reference : # compare \u0026#39;xx\u0026#39;, \u0026#39;yy\u0026#39; \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(r\u0026#39;([a-z])\\1$\u0026#39;,\u0026#39;xx\u0026#39;) != None True \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(r\u0026#39;([a-z])\\1$\u0026#39;,\u0026#39;yy\u0026#39;) != None True \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(r\u0026#39;([a-z])\\1$\u0026#39;,\u0026#39;xy\u0026#39;) != None False # compare open tag and close tag \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; pattern = r\u0026#39;\u0026lt;([^\u0026gt;]+)\u0026gt;[\\s\\S]*?\u0026lt;/\\1\u0026gt;\u0026#39; \u0026gt;\u0026gt;\u0026gt; re.search(pattern, \u0026#39;\u0026lt;bold\u0026gt; test \u0026lt;/bold\u0026gt;\u0026#39;) != None True \u0026gt;\u0026gt;\u0026gt; re.search(pattern, \u0026#39;\u0026lt;h1\u0026gt; test \u0026lt;/h1\u0026gt;\u0026#39;) != None True \u0026gt;\u0026gt;\u0026gt; re.search(pattern, \u0026#39;\u0026lt;bold\u0026gt; test \u0026lt;/h1\u0026gt;\u0026#39;) != None False Named Grouping (?P) : # group reference ``(?P\u0026lt;name\u0026gt;...)`` \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; pattern = \u0026#39;(?P\u0026lt;year\u0026gt;\\d{4})-(?P\u0026lt;month\u0026gt;\\d{2})-(?P\u0026lt;day\u0026gt;\\d{2})\u0026#39; \u0026gt;\u0026gt;\u0026gt; mon = re.search(pattern, \u0026#39;2018-09-01\u0026#39;) \u0026gt;\u0026gt;\u0026gt; mon.group(\u0026#39;year\u0026#39;) \u0026#39;2018\u0026#39; \u0026gt;\u0026gt;\u0026gt; mon.group(\u0026#39;month\u0026#39;) \u0026#39;09\u0026#39; \u0026gt;\u0026gt;\u0026gt; mon.group(\u0026#39;day\u0026#39;) \u0026#39;01\u0026#39; # back reference ``(?P=name)`` \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.search(\u0026#39;^(?P\u0026lt;char\u0026gt;[a-z])(?P=char)\u0026#39;,\u0026#39;aa\u0026#39;) \u0026lt;_sre.SRE_Match object at 0x01A08660\u0026gt; Substitute String : # basic substitute \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; res = \u0026#34;4x5y6z\u0026#34; \u0026gt;\u0026gt;\u0026gt; re.sub(r\u0026#39;[a-z]\u0026#39;,\u0026#39; \u0026#39;, res) \u0026#39;4 5 6 \u0026#39; # substitute with group reference \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; date = r\u0026#39;2018-09-01\u0026#39; \u0026gt;\u0026gt;\u0026gt; re.sub(r\u0026#39;(\\d{4})-(\\d{2})-(\\d{2})\u0026#39;,r\u0026#39;\\2/\\3/\\1/\u0026#39;,date) \u0026#39;09/01/2018/\u0026#39; # camelcase to underscore \u0026gt;\u0026gt;\u0026gt; def convert(s): ... res = re.sub(r\u0026#39;(.)([A-Z][a-z]+)\u0026#39;,r\u0026#39;\\1_\\2\u0026#39;, s) ... return re.sub(r\u0026#39;([a-z])([A-Z])\u0026#39;,r\u0026#39;\\1_\\2\u0026#39;, res).lower() ... \u0026gt;\u0026gt;\u0026gt; convert(\u0026#39;SentenceCase\u0026#39;) \u0026#39;sentence_case\u0026#39; \u0026gt;\u0026gt;\u0026gt; convert(\u0026#39;SentenceSentenceCase\u0026#39;) \u0026#39;sentence_sentence_case\u0026#39; \u0026gt;\u0026gt;\u0026gt; convert(\u0026#39;SampleExampleHTTPServer\u0026#39;) \u0026#39;sample_example_http_server\u0026#39; Look around :    notation compare direction     (?\u0026lt;=\u0026hellip;) right to left   (?=\u0026hellip;) left to right   (?!\u0026lt;\u0026hellip;) right to left   (?!\u0026hellip;) left to right    # basic \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.sub(\u0026#39;(?=\\d{3})\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;56789\u0026#39;) \u0026#39; 5 6 789\u0026#39; \u0026gt;\u0026gt;\u0026gt; re.sub(\u0026#39;(?!\\d{3})\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;56789\u0026#39;) \u0026#39;567 8 9 \u0026#39; \u0026gt;\u0026gt;\u0026gt; re.sub(\u0026#39;(?\u0026lt;=\\d{3})\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;56789\u0026#39;) \u0026#39;567 8 9 \u0026#39; \u0026gt;\u0026gt;\u0026gt; re.sub(\u0026#39;(?\u0026lt;!\\d{3})\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;56789\u0026#39;) \u0026#39; 5 6 789\u0026#39; Match common username or password : \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#39;^[a-zA-Z0-9-_]{3,16}$\u0026#39;, \u0026#39;Foo\u0026#39;) is not None True \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#39;^\\w|[-_]{3,16}$\u0026#39;, \u0026#39;Foo\u0026#39;) is not None True Match hex color value : \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#39;^#?([a-f0-9]{6}|[a-f0-9]{3})$\u0026#39;, \u0026#39;#ff0000\u0026#39;) \u0026lt;_sre.SRE_Match object at 0x019E7720\u0026gt; \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#39;^#?([a-f0-9]{6}|[a-f0-9]{3})$\u0026#39;, \u0026#39;#000000\u0026#39;) \u0026lt;_sre.SRE_Match object at 0x019E77A0\u0026gt; Match email : \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; re.match(\u0026#39;^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$\u0026#39;, \u0026#39;citi.world@example.com\u0026#39;) \u0026lt;_sre.SRE_Match object; span=(0, 22), match=\u0026#39;citi.world@example.com\u0026#39;\u0026gt; # or \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; example = re.compile(r\u0026#39;\u0026#39;\u0026#39;^([a-zA-Z0-9._%-]+@ [a-zA-Z0-9.-]+ \\.[a-zA-Z]{2,4})*$\u0026#39;\u0026#39;\u0026#39;, re.X) \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;citi.world@example.citi.com\u0026#39;) \u0026lt;_sre.SRE_Match object; span=(0, 27), match=\u0026#39;citi.world@example.citi.com\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;citi%world@example.citi.com\u0026#39;) \u0026lt;_sre.SRE_Match object; span=(0, 27), match=\u0026#39;citi%world@example.citi.com\u0026#39;\u0026gt; Match URL : \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; example = re.compile(r\u0026#39;\u0026#39;\u0026#39;^(https?:\\/\\/)? # match http or https ... ([\\da-z\\.-]+) # match domain ... \\.([a-z\\.]{2,6}) # match domain ... ([\\/\\w \\.-]*)\\/?$ # match api or file ... \u0026#39;\u0026#39;\u0026#39;, re.X) \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;www.yahoo.com\u0026#39;) \u0026lt;_sre.SRE_Match object; span=(0, 13), match=\u0026#39;www.yahoo.com\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;http://www.example\u0026#39;) \u0026lt;_sre.SRE_Match object; span=(0, 18), match=\u0026#39;http://www.example\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;http://www.example/w3r.html\u0026#39;) \u0026lt;_sre.SRE_Match object; span=(0, 27), match=\u0026#39;http://www.example/w3r.html\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;http://www.example/w3r!.html\u0026#39;) \u0026gt;\u0026gt;\u0026gt; example re.compile(\u0026#39;^(https?:\\\\/\\\\/)?\\n([\\\\da-z\\\\.-]+)\\n\\\\.([a-z\\\\.]{2,6})\\n([\\\\/\\\\w \\\\.-]*)\\\\/?$\\n\u0026#39;, re.VERBOSE) Match IP address :    notation description     [1]?[0-9][0-9] Match 0-199 pattern   2[0-4][0-9] Match 200-249 pattern   25[0-5] Match 251-255 pattern   (?:\u0026hellip;) Don\u0026rsquo;t capture group    \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; example = re.compile(r\u0026#39;\u0026#39;\u0026#39;^(?:(?:25[0-5] ... |2[0-4][0-9] ... |[1]?[0-9][0-9]?)\\.){3} ... (?:25[0-5] ... |2[0-4][0-9] ... |[1]?[0-9][0-9]?)$\u0026#39;\u0026#39;\u0026#39;, re.X) \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;192.168.1.1\u0026#39;) \u0026lt;_sre.SRE_Match object at 0x0134A608\u0026gt; \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;255.255.255.0\u0026#39;) \u0026lt;_sre.SRE_Match object at 0x01938678\u0026gt; \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;172.17.0.5\u0026#39;) \u0026lt;_sre.SRE_Match object at 0x0134A608\u0026gt; \u0026gt;\u0026gt;\u0026gt; example.match(\u0026#39;256.0.0.0\u0026#39;) is None True Match Mac address : \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; mac = [random.randint(0x00, 0x6b), ... random.randint(0x00, 0x6b), ... random.randint(0x00, 0x6b), ... random.randint(0x00, 0x6b), ... random.randint(0x00, 0x6b), ... random.randint(0x00, 0x6b)] \u0026gt;\u0026gt;\u0026gt; mac = \u0026#39;:\u0026#39;.join(map(lambda x: \u0026#34;%02x\u0026#34; % x, mac)) \u0026gt;\u0026gt;\u0026gt; mac \u0026#39;05:38:64:60:55:63\u0026#39; \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; example = re.compile(r\u0026#39;\u0026#39;\u0026#39;[0-9a-f]{2}([:]) ... [0-9a-f]{2} ... (\\1[0-9a-f]{2}){4}$\u0026#39;\u0026#39;\u0026#39;, re.X) \u0026gt;\u0026gt;\u0026gt; example.match(mac) is not None True Lexer : \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; from collections import namedtuple \u0026gt;\u0026gt;\u0026gt; tokens = [r\u0026#39;(?P\u0026lt;NUMBER\u0026gt;\\d+)\u0026#39;, r\u0026#39;(?P\u0026lt;PLUS\u0026gt;\\+)\u0026#39;, r\u0026#39;(?P\u0026lt;MINUS\u0026gt;-)\u0026#39;, r\u0026#39;(?P\u0026lt;TIMES\u0026gt;\\*)\u0026#39;, r\u0026#39;(?P\u0026lt;DIVIDE\u0026gt;/)\u0026#39;, r\u0026#39;(?P\u0026lt;WS\u0026gt;\\s+)\u0026#39;] \u0026gt;\u0026gt;\u0026gt; lex = re.compile(\u0026#39;|\u0026#39;.join(tokens)) \u0026gt;\u0026gt;\u0026gt; Token = namedtuple(\u0026#39;Token\u0026#39;, [\u0026#39;type\u0026#39;, \u0026#39;value\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; def tokenize(text): scan = lex.scanner(text) return (Token(m.lastgroup, m.group()) for m in iter(scan.match, None) if m.lastgroup != \u0026#39;WS\u0026#39;) \u0026gt;\u0026gt;\u0026gt; for _t in tokenize(\u0026#39;9 + 5 * 2 - 7\u0026#39;): print(_t) Token(type=\u0026#39;NUMBER\u0026#39;, value=\u0026#39;9\u0026#39;) Token(type=\u0026#39;PLUS\u0026#39;, value=\u0026#39;+\u0026#39;) Token(type=\u0026#39;NUMBER\u0026#39;, value=\u0026#39;5\u0026#39;) Token(type=\u0026#39;TIMES\u0026#39;, value=\u0026#39;*\u0026#39;) Token(type=\u0026#39;NUMBER\u0026#39;, value=\u0026#39;2\u0026#39;) Token(type=\u0026#39;MINUS\u0026#39;, value=\u0026#39;-\u0026#39;) Token(type=\u0026#39;NUMBER\u0026#39;, value=\u0026#39;7\u0026#39;) \u0026gt;\u0026gt;\u0026gt; tokens # [\u0026#39;(?P\u0026lt;NUMBER\u0026gt;\\\\d+)\u0026#39;, \u0026#39;(?P\u0026lt;PLUS\u0026gt;\\\\+)\u0026#39;, \u0026#39;(?P\u0026lt;MINUS\u0026gt;-)\u0026#39;, \u0026#39;(?P\u0026lt;TIMES\u0026gt;\\\\*)\u0026#39;, \u0026#39;(?P\u0026lt;DIVIDE\u0026gt;/)\u0026#39;, \u0026#39;(?P\u0026lt;WS\u0026gt;\\\\s+)\u0026#39;] "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/resources/quick_reference_cards/",
	"title": "Quick Reference Card",
	"tags": [],
	"description": "",
	"content": "Python 3 – Quick Reference Card Data types Strings: s = \u0026#34;foo bar\u0026#34; s = \u0026#39;foo bar\u0026#39; s = r\u0026#34;c:\\dir\\new\u0026#34; # raw (== \u0026#39;c:\\\\dir\\\\new\u0026#39;) s = \u0026#34;\u0026#34;\u0026#34;Hello world\u0026#34;\u0026#34;\u0026#34; s.join(\u0026#34; baz\u0026#34;) n = len(s) \u0026#34;Ala ma {} psy i {} koty\u0026#34;.format(2,3) \u0026#34;Square root of 2 is equal to {:.2f}\u0026#34;.format(math.sqrt(2)) Lists: L = [1, 2, 3, 4, 5] L[0] # single position L[0:3] # the first three elements L[-2:] # the last two elements L[1:4] = [7,8] # substitute del L[2] # remove elements L.append(x) # x is a value L.remove(x) L.extend(L2) # or: L3 = L + L2 L.pop() # simple stack (with append) L.sort() x in L # does L contain x? L.index(x) # index of the first occurrence [x*2 for x in L if x\u0026gt;2] # list comprehensions Tuples: x = 1,2,3 x = (1,2,3) x[1] a,b,c = x Dictionaries: D = {\u0026#39;f1\u0026#39;: 10, \u0026#39;f2\u0026#39;: 20} # dict creation D = dict(f1=10, f2=20) keys = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) D = dict.fromkeys(keys) # new dict with empty values for k in D: print(k) # keys for v in D.values(): print(v) # values for k, v in D.items(): # tuples with keys and values list(D.keys()) # list of keys sorted(D.keys()) # sorted list of keys D = {} D[(1,8,5)] = 100 # 3D sparse matrix D.get((1,8,5)) D.get((1,1,1), -1) Sets: S = {1,3,5} L = [1, 3, 1, 5, 3] S = set(L) # set([1, 3, 5]) if (3 in S): S1+S2, S1-S2, S1^S2, S1|S2 See also https://docs.python.org/3/library/stdtypes.html.\nLoops for x in range(6): # 0, 1, 2, 3, 4, 5 for x in range(1,6): # 1, 2, 3, 4, 5 for x in range(1,6,2): # 1, 3, 5 for k,v in D.items(): print(\u0026#34;D[{}]={}\u0026#34;.format(k,v)) # D[f1]=10 D[f2]=20 L = [1, 3, 5] for i,v in enumerate(L): # (index,value) for x,y in zip(L1,L2): # returns tuples for i in sorted(set(L)): print(i) # sorted set from a list for x in reversed(L1): Functions def foo(arg1, *args, **dic): \u0026#34;\u0026#34;\u0026#34;Example documentation string. This function does not do anything special. \u0026#34;\u0026#34;\u0026#34; # arg1 is a positional argument # args is a list # dic is a dictionary of named arguments def foo(a,b,c=0): L = [1, 2, 3] foo(*L) # unpacking a list of arguments D = {\u0026#39;a\u0026#39;: 10, \u0026#39;b\u0026#39;: 20} foo(**D) # unpacking a dictionary of arguments foo.__doc__ # the docstring Input/output Printing: str(x) # human readable representation repr(x) # interpretable representation File access: f = open(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;) # r / r+ / rb / rb+ / w / wb f.write(\u0026#34;Ala ma kota\\n\u0026#34;) f.close() for line in open(\u0026#34;test.txt\u0026#34;): print(line, end=\u0026#34;\u0026#34;) L = open(\u0026#34;test.txt\u0026#34;).readlines() # returns a list of lines Exclusive access:\nf = os.fdopen(os.open(\u0026#34;test.txt\u0026#34;, os.O_WRONLY|os.O_EXCL), \u0026#34;w\u0026#34;) Input: x = raw_input(\u0026#34;Name: \u0026#34;) for line in sys.stdin: print(line) String buffers:\nfrom StringIO import StringIO buf = StringIO() sys.stdout = buf print(\u0026#34;Hello\u0026#34;) x = buf.getvalue() Error stream: print(\u0026#34;Error!\u0026#34;, file=sys.stderr, flush=True) Other file operations: os.rename(from, to) os.remove(path) os.chmod(file, 0700) os.stat(file) Special names `__name__` name of the file being run not imported Typical usage: if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;Do something) Exceptions try: raise TypeError(\u0026#34;arg\u0026#34;) except (RuntimeError, NameError): pass # empty instruction (NOP) except: info = sys.exc_info() print(info[0]) print(info[1]) traceback.print_tb(info[2]) raise else: ... # no exception but before finally finally: # on the way out ... # unhandled exc, release resources Object-oriented programming class Person: ID = 0 # static variable def __init__(self, name, age=0): self.name = name self.age = age Person.ID += 1 self.ID = Person.ID def lastName(self): return self.name.split()[-1] def __str__(self): return \u0026#34;{}({},{})\u0026#34;.format(self.__class__.__name__, self.name, self.age) class Worker(Person): def __init__(self, name, position, age=0): super().__init__(name, age) self.position = position def __str__(self): return \u0026#34;{}({},{},{})\u0026#34;.format(self.__class__.__name__, self.name, self.position, self.age) bob = Worker(\u0026#34;Bob Smith\u0026#34;, \u0026#34;developer\u0026#34;, 25) print(bob) Useful APIs Queues: Q = collections.deque([10,20,30]) Q.append(40) Q.popleft() Pickling: f = open(\u0026#34;myobj.dat\u0026#34;, \u0026#34;w\u0026#34;) pickle.dump(x, f) f = open(\u0026#34;myobj.dat\u0026#34;, \u0026#34;r\u0026#34;) x = pickle.load(f) Databases: conn = sqlite3.connect(\u0026#34;data.db\u0026#34;) c = conn.cursor() c.execute(\u0026#34;SELECT * FROM employees\u0026#34;) for row in c: print(row[0]) conn.commit() conn.close() db = shelve.open(\u0026#34;file\u0026#34;) db[\u0026#34;x\u0026#34;] = y db.close() CGI: form = cgi.FieldStorage() print(\u0026#34;Content-type: text/html\\n\u0026#34;) print(cgi.escape(form[\u0026#34;user\u0026#34;].value)) HTTP Server: srvraddr = (\u0026#34;\u0026#34;, 8080) # my hostname, portnumber srvrobj = BaseHTTPServer.HTTPServer(srvraddr, CGIHTTPServer.CGIHTTPRequestHandler) srvrobj.serve_forever() URLs: conn = urllib.urlopen(\u0026#34;http://localhost:8080\u0026#34;) reply = conn.read() Environment Encoding: #!/usr/bin/python3 # -*- coding: latin-2 -*- Windows – use .pyw extension to run the script (with GUI) without a console window.\nPaths: PYTHONPATH export PYTHONSTARTUP=~/.pythonrc.py Module sys: sys.argv sys.stdin sys.stdout sys.stderr sys.path sys.platform sys.version Processes (module subprocess): res = subprocess.call([\u0026#34;hostname\u0026#34;,\u0026#34;-f\u0026#34;], stderr=subprocess.DEVNULL) res = subprocess.call(\u0026#34;ps axu | grep ^root\u0026#34;, shell=True) output = subprocess.check_output([\u0026#34;mycmd\u0026#34;, \u0026#34;myarg\u0026#34;],universal_newlines=True) Module os: os.pathsep os.sep os.pardir os.curdir os.linesep os.startfile(\u0026#34;index.html\u0026#34;) os.popen(\u0026#34;ps ax\u0026#34;).readlines() os.listdir(\u0026#34;/usr/local\u0026#34;) # [\u0026#39;bin\u0026#39;, \u0026#39;etc\u0026#39;, ...] os.glob(\u0026#34;*.txt\u0026#34;) # [\u0026#39;test.txt\u0026#39;, \u0026#39;out.txt\u0026#39;, ...] Module os.path: os.path.split(\u0026#34;/usr/bin/go.sh\u0026#34;) # (\u0026#39;/usr/bin\u0026#39;, \u0026#39;go.sh\u0026#39;) os.path.join(\u0026#34;/usr/bin\u0026#34;, \u0026#34;go.sh\u0026#34;) # \u0026#39;/usr/bin/go.sh\u0026#39; os.path.splitext(\u0026#34;/usr/bin/go.sh\u0026#34;) # (\u0026#39;/usr/bin/go\u0026#39;, \u0026#39;.sh\u0026#39;) os.path.abspath(\u0026#34;../bin/go.sh\u0026#34;) # \u0026#39;/usr/bin/go.sh\u0026#39; os.path.isfile(\u0026#34;go.sh\u0026#34;) Module os.environ: os.environ.get(\u0026#34;PYTHONSTARTUP\u0026#34;) Directories: for (dir, subdirs, files) in os.walk(\u0026#34;/tmp\u0026#34;): for f in files: print(f) Functional programming f = lambda x: x+10 # creates an anonymous function f(5) # returns 15 L = [1, 4, 7] for x in filter(lambda i: i\u0026lt;5, L): # returns [1, 4] for x in map(lambda: x: x*2, L): # returns [2, 8, 14] References  The Python Tutorial, https://docs.python.org/3/tutorial/ The Python Language Reference, http://docs.python.org/3/reference/ The Python Standard Library, http://docs.python.org/3/library/ PEP-8: Style Guide for Python Code, http://www.python.org/dev/peps/pep-0008/   Reference : http://www.cs.put.poznan.pl/csobaniec/software/python/py-qrc.html\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/short_introduction/",
	"title": "Short Introduction",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/pythonstandardlibrary/",
	"title": "Standard Library",
	"tags": [],
	"description": "",
	"content": "The Python Standard Library By Example\nPyMOTW-3 is a series of articles written by Doug Hellmann to demonstrate how to use the modules of the Python 3 standard library. It is based on the original PyMOTW series, which covered Python 2.7. See About Python Module of the Week for details including the version of Python and tools used.\n Text  string — Text Constants and Templates textwrap — Formatting Text Paragraphs re — Regular Expressions difflib — Compare Sequences   Data Structures  enum – Enumeration Type collections — Container Data Types array — Sequence of Fixed-type Data heapq – Heap Sort Algorithm bisect — Maintain Lists in Sorted Order queue — Thread-Safe FIFO Implementation struct — Binary Data Structures weakref — Impermanent References to Objects copy — Duplicate Objects pprint — Pretty-Print Data Structures   Algorithms  functools — Tools for Manipulating Functions itertools — Iterator Functions operator — Functional Interface to Built-in Operators contextlib — Context Manager Utilities   Dates and Times  time — Clock Time datetime — Date and Time Value Manipulation calendar — Work with Dates   Mathematics  decimal — Fixed and Floating Point Math fractions — Rational Numbers random — Pseudorandom Number Generators math — Mathematical Functions statistics — Statistical Calculations   The File System  os.path — Platform-independent Manipulation of Filenames pathlib — Filesystem Paths as Objects glob — Filename Pattern Matching fnmatch — Unix-style Glob Pattern Matching linecache — Read Text Files Efficiently tempfile — Temporary File System Objects shutil — High-level File Operations filecmp — Compare Files mmap — Memory-map Files codecs — String Encoding and Decoding io — Text, Binary, and Raw Stream I/O Tools   Data Persistence and Exchange  pickle — Object Serialization shelve — Persistent Storage of Objects dbm — Unix Key-Value Databases sqlite3 — Embedded Relational Database xml.etree.ElementTree — XML Manipulation API csv — Comma-separated Value Files   Data Compression and Archiving  zlib — GNU zlib Compression gzip — Read and Write GNU zip Files bz2 — bzip2 Compression tarfile — Tar Archive Access zipfile — ZIP Archive Access   Cryptography  hashlib — Cryptographic Hashing hmac — Cryptographic Message Signing and Verification   Concurrency with Processes, Threads, and Coroutines  subprocess — Spawning Additional Processes signal — Asynchronous System Events threading — Manage Concurrent Operations Within a Process multiprocessing — Manage Processes Like Threads asyncio — Asynchronous I/O, event loop, and concurrency tools concurrent.futures — Manage Pools of Concurrent Tasks   Networking  ipaddress — Internet Addresses socket — Network Communication selectors — I/O Multiplexing Abstractions select — Wait for I/O Efficiently socketserver — Creating Network Servers   The Internet  urllib.parse — Split URLs into Components urllib.request — Network Resource Access urllib.robotparser — Internet Spider Access Control base64 — Encode Binary Data with ASCII http.server — Base Classes for Implementing Web Servers http.cookies — HTTP Cookies webbrowser — Displays web pages uuid — Universally Unique Identifiers json — JavaScript Object Notation xmlrpc.client — Client Library for XML-RPC xmlrpc.server — An XML-RPC server   Email  smtplib — Simple Mail Transfer Protocol Client smtpd — Sample Mail Servers mailbox — Manipulate Email Archives imaplib — IMAP4 Client Library   Application Building Blocks  argparse — Command-Line Option and Argument Parsing getopt — Command Line Option Parsing readline — The GNU readline Library getpass — Secure Password Prompt cmd — Line-oriented Command Processors shlex — Parse Shell-style Syntaxes configparser — Work with Configuration Files logging — Report Status, Error, and Informational Messages fileinput — Command-Line Filter Framework atexit — Program Shutdown Callbacks sched — Timed Event Scheduler   Internationalization and Localization  gettext — Message Catalogs locale — Cultural Localization API   Developer Tools  pydoc — Online Help for Modules doctest — Testing Through Documentation unittest — Automated Testing Framework trace — Follow Program Flow traceback — Exceptions and Stack Traces cgitb — Detailed Traceback Reports pdb — Interactive Debugger profile and pstats — Performance Analysis timeit — Time the execution of small bits of Python code. tabnanny — Indentation validator compileall — Byte-compile Source Files pyclbr — Class Browser venv — Create Virtual Environments ensurepip — Install the Python Package Installer   Runtime Features  site — Site-wide Configuration sys — System-specific Configuration os — Portable access to operating system specific features platform — System Version Information resource — System Resource Management gc — Garbage Collector sysconfig — Interpreter Compile-time Configuration   Language Tools  warnings — Non-fatal Alerts abc — Abstract Base Classes dis — Python Bytecode Disassembler inspect — Inspect Live Objects   Modules and Packages  importlib — Python’s Import Mechanism pkgutil — Package Utilities zipimport — Load Python Code from ZIP Archives   Unix-specific Services  pwd — Unix Password Database grp — Unix Group Database   Porting Notes  References New Modules Renamed Modules Removed Modules Deprecated Modules Summary of Changes to Modules   Outside of the Standard Library  Text Algorithms Dates and Times Mathematics Data Persistence and Exchange Cryptography Concurrency with Processes, Threads, and Coroutines The Internet Email Application Building Blocks Developer Tools   About Python Module of the Week  Subscribe Tools Translations and Other Versions Copyright and Licensing     Source : https://pymotw.com/3/index.html\nsource code : https://github.com/dhellmann/pymotw-3\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/pythonstandardlibrary/text/string/",
	"title": "String",
	"tags": [],
	"description": "",
	"content": "String — Text Constants and Templates  Contains constants and classes for working with text.\n The string module dates from the earliest versions of Python. Many of the functions previously implemented in this module have been moved to methods of str objects. The string module retains several useful constants and classes for working with str objects. This discussion will concentrate on them.\nFunctions The function capwords() capitalizes all of the words in a string.\n# string_capwords.py import string s = \u0026#39;The quick brown fox jumped over the lazy dog.\u0026#39; print(s) print(string.capwords(s)) The results are the same as those obtained by calling split(), capitalizing the words in the resulting list, and then calling join() to combine the results.\n$ python3 string_capwords.py The quick brown fox jumped over the lazy dog. The Quick Brown Fox Jumped Over The Lazy Dog. Templates String templates were added as part of PEP 292 and are intended as an alternative to the built-in interpolation syntax. With string.Template interpolation, variables are identified by prefixing the name with $ (e.g., $var). Alternatively, if necessary to set them off from surrounding text, they can also be wrapped with curly braces (e.g., ${var}).\nThis example compares a simple template with similar string interpolation using the % operator and the new format string syntax using str.format().\n# string_template.py import string values = {\u0026#39;var\u0026#39;: \u0026#39;foo\u0026#39;} t = string.Template(\u0026#34;\u0026#34;\u0026#34; Variable : $var Escape : $$ Variable in text: ${var}iable \u0026#34;\u0026#34;\u0026#34;) print(\u0026#39;TEMPLATE:\u0026#39;, t.substitute(values)) s = \u0026#34;\u0026#34;\u0026#34; Variable : %(var)sEscape : %%Variable in text: %(var)siable \u0026#34;\u0026#34;\u0026#34; print(\u0026#39;INTERPOLATION:\u0026#39;, s % values) s = \u0026#34;\u0026#34;\u0026#34; Variable : {var} Escape : {{}} Variable in text: {var}iable \u0026#34;\u0026#34;\u0026#34; print(\u0026#39;FORMAT:\u0026#39;, s.format(**values)) In the first two cases, the trigger character ($ or %) is escaped by repeating it twice. For the format syntax, both { and } need to be escaped by repeating them.\n$ python3 string_template.py TEMPLATE: Variable : foo Escape : $ Variable in text: fooiable INTERPOLATION: Variable : foo Escape : % Variable in text: fooiable FORMAT: Variable : foo Escape : {} Variable in text: fooiable One key difference between templates and string interpolation or formatting is that the type of the arguments is not taken into account. The values are converted to strings, and the strings are inserted into the result. No formatting options are available. For example, there is no way to control the number of digits used to represent a floating-point value.\nA benefit, though, is that use of the safe_substitute() method makes it possible to avoid exceptions if not all of the values needed by the template are provided as arguments.\n# string_template_missing.py import string values = {\u0026#39;var\u0026#39;: \u0026#39;foo\u0026#39;} t = string.Template(\u0026#34;$var is here but $missing is not provided\u0026#34;) try: print(\u0026#39;substitute() :\u0026#39;, t.substitute(values)) except KeyError as err: print(\u0026#39;ERROR:\u0026#39;, str(err)) print(\u0026#39;safe_substitute():\u0026#39;, t.safe_substitute(values)) Since there is no value for missing in the values dictionary, a KeyError is raised by substitute(). Instead of raising the error, safe_substitute() catches it and leaves the variable expression alone in the text.\n$ python3 string_template_missing.py ERROR: \u0026#39;missing\u0026#39; safe_substitute(): foo is here but $missing is not provided Advanced Templates The default syntax for string.Template can be changed by adjusting the regular expression patterns it uses to find the variable names in the template body. A simple way to do that is to change the delimiter and idpattern class attributes.\n# string_template_advanced.py import string class MyTemplate(string.Template): delimiter = \u0026#39;%\u0026#39; idpattern = \u0026#39;[a-z]+_[a-z]+\u0026#39; template_text = \u0026#39;\u0026#39;\u0026#39; Delimiter : %%Replaced : %with_underscore Ignored : %notunderscored \u0026#39;\u0026#39;\u0026#39; d = { \u0026#39;with_underscore\u0026#39;: \u0026#39;replaced\u0026#39;, \u0026#39;notunderscored\u0026#39;: \u0026#39;not replaced\u0026#39;, } t = MyTemplate(template_text) print(\u0026#39;Modified ID pattern:\u0026#39;) print(t.safe_substitute(d)) In this example, the substitution rules are changed so that the delimiter is % instead of $ and variable names must include an underscore somewhere in the middle. The pattern %notunderscored is not replaced by anything, because it does not include an underscore character.\n$ python3 string_template_advanced.py Modified ID pattern: Delimiter : % Replaced : replaced Ignored : %notunderscored For even more complex changes, it is possible to override the pattern attribute and define an entirely new regular expression. The pattern provided must contain four named groups for capturing the escaped delimiter, the named variable, a braced version of the variable name, and invalid delimiter patterns.\n# string_template_defaultpattern.py import string t = string.Template(\u0026#39;$var\u0026#39;) print(t.pattern.pattern) The value of t.pattern is a compiled regular expression, but the original string is available via its pattern attribute.\n\\$(?: (?P\u0026lt;escaped\u0026gt;\\$) | # two delimiters (?P\u0026lt;named\u0026gt;[_a-z][_a-z0-9]*) | # identifier {(?P\u0026lt;braced\u0026gt;[_a-z][_a-z0-9]*)} | # braced identifier (?P\u0026lt;invalid\u0026gt;) # ill-formed delimiter exprs ) This example defines a new pattern to create a new type of template, using {{var}} as the variable syntax.\n# string_template_newsyntax.py import re import string class MyTemplate(string.Template): delimiter = \u0026#39;{{\u0026#39; pattern = r\u0026#39;\u0026#39;\u0026#39; \\{\\{(?: (?P\u0026lt;escaped\u0026gt;\\{\\{)| (?P\u0026lt;named\u0026gt;[_a-z][_a-z0-9]*)\\}\\}| (?P\u0026lt;braced\u0026gt;[_a-z][_a-z0-9]*)\\}\\}| (?P\u0026lt;invalid\u0026gt;) ) \u0026#39;\u0026#39;\u0026#39; t = MyTemplate(\u0026#39;\u0026#39;\u0026#39; {{{{ {{var}} \u0026#39;\u0026#39;\u0026#39;) print(\u0026#39;MATCHES:\u0026#39;, t.pattern.findall(t.template)) print(\u0026#39;SUBSTITUTED:\u0026#39;, t.safe_substitute(var=\u0026#39;replacement\u0026#39;)) Both the named and braced patterns must be provided separately, even though they are the same. Running the sample program generates the following output:\n$ python3 string_template_newsyntax.py MATCHES: [(\u0026#39;{{\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;), (\u0026#39;\u0026#39;, \u0026#39;var\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;)] SUBSTITUTED: {{ replacement Formatter The Formatter class implements the same layout specification language as the format() method of str. Its features include type coersion, alignment, attribute and field references, named and positional template arguments, and type-specific formatting options. Most of the time the format() method is a more convenient interface to these features, but Formatter is provided as a way to build subclasses, for cases where variations are needed.\nConstants The string module includes a number of constants related to ASCII and numerical character sets.\n# string_constants.py import inspect import string def is_str(value): return isinstance(value, str) for name, value in inspect.getmembers(string, is_str): if name.startswith(\u0026#39;_\u0026#39;): continue print(\u0026#39;%s=%r\\n\u0026#39; % (name, value)) These constants are useful when working with ASCII data, but since it is increasingly common to encounter non-ASCII text in some form of Unicode, their application is limited.\n$ python3 string_constants.py ascii_letters=\u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVW XYZ\u0026#39; ascii_lowercase=\u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39; ascii_uppercase=\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; digits=\u0026#39;0123456789\u0026#39; hexdigits=\u0026#39;0123456789abcdefABCDEF\u0026#39; octdigits=\u0026#39;01234567\u0026#39; printable=\u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQ RSTUVWXYZ!\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c\u0026#39; punctuation=\u0026#39;!\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`{|}~\u0026#39; whitespace=\u0026#39; \\t\\n\\r\\x0b\\x0c\u0026#39; See also\n Standard library documentation for string String Methods – Methods of str objects that replace the deprecated functions in string. PEP 292 – Simpler String Substitutions Format String Syntax – The formal definition of the layout specification language used by Formatter and str.format().   Reference : https://pymotw.com/3/string/index.html\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/pythonstandardlibrary/text/",
	"title": "Text",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/tutorial-geeksforgeeks/",
	"title": "Tutorial (GeeksforGeeks)",
	"tags": [],
	"description": "",
	"content": " Reference : https://www.geeksforgeeks.org/pandas-tutorial/?ref=leftbar-rightbar#introduction\n Pandas is an open-source library that is built on top of NumPy library. It is a Python package that offers various data structures and operations for manipulating numerical data and time series. It is mainly popular for importing and analyzing data much easier. Pandas is fast and it has high-performance \u0026amp; productivity for users.\nThis Pandas Tutorial will help learning Pandas from Basics to advance data analysis operations, including all necessary functions explained in detail.\nTable of Contents\n  Introduction Creating Objects Viewing Data Selection Manipulating Data Grouping Data Merging, Joining and Concatenating Working with Date and Time Working With Text Data Working with CSV and Excel files Operations Visualization Applications and Projects Miscellaneous   Pandas Practice problems with solutions !\nRecent Articles on Python Pandas !\nIntroduction  Introduction to Pandas in Python How to Install Python Pandas on Windows and Linux? How To Use Jupyter Notebook – An Ultimate Guide  Creating Objects  Python | Pandas DataFrame Creating a Pandas DataFrame Python | Pandas Series Creating a Pandas Series  Viewing Data  View the top rows of the frame View the bottom rows of the frame View basic statistical details Convert the pandas DataFrame to numpy Array Convert the pandas Series to numpy Array Convert series or dataframe object to Numpy-array using .as_matrix().  Selection  Dealing with Rows and Columns in Pandas DataFrame How to select multiple columns in a pandas dataframe Python | Pandas Extracting rows using .loc[] Python | Extracting rows using Pandas .iloc[] Indexing and Selecting Data with Pandas Boolean Indexing in Pandas Label and Integer based slicing technique using DataFrame.ix  Recent Articles on Pandas-Indexing\nManipulating Data  Adding new column to existing DataFrame in Pandas Python | Delete rows/columns from DataFrame Truncate a DataFrame before and after some index value Truncate a Series before and after some index value Iterating over rows and columns in Pandas DataFrame Working with Missing Data in Pandas Sorts a data frame in Pandas | Set-1 Sorts a data frame in Pandas | Set-2  Grouping Data  Pandas GroupBy Grouping Rows in pandas Combining multiple columns in Pandas groupby with dictionary  Merging, Joining and Concatenating  Python | Pandas Merging, Joining, and Concatenating Concatenate Strings Append rows to Dataframe Concatenate two or more series Append a single or a collection of indices Combine two series into one Add a row at top in pandas DataFrame Join all elements in list present in a series Join two text columns into a single column in Pandas  Working with Date and Time  Python | Working with date and time using Pandas Timestamp using Pandas Current Time using Pandas Convert timestamp to ISO Format Get datetime object using Pandas Replace the member values of the given Timestamp Convert string Date time into Python Date time object using Pandas Get a fixed frequency DatetimeIndex using Pandas  Working With Text Data  Python | Pandas Working With Text Data Convert String into lower, upper or camel case Replace Text Value Replace Text Value using series.replace() Removing Whitespaces Move dates forward a given number of valid dates using Pandas  Working with CSV and Excel files  Read csv using pandas Saving a Pandas Dataframe as a CSV Loading Excel spreadsheet as pandas DataFrame Creating a dataframe using Excel files Working with Pandas and XlsxWriter | Set – 1 Working with Pandas and XlsxWriter | Set – 2 Working with Pandas and XlsxWriter | Set – 3  Operations  Apply a function on the possible series Apply function to every row in a Pandas DataFrame Apply a function on each element of the series Aggregation data across one or more column Mean of the values for the requested axis Mean of the underlying data in the Series Mean absolute deviation of the values for the requested axis Mean absolute deviation of the values for the Series Unbiased standard error of the mean Find the Series containing counts of unique values Find the Series containing counts of unique values using Index.value_counts()  Visualization  Pandas Built-in Data Visualization Data analysis and Visualization with Python | Set 1 Data analysis and Visualization with Python | Set 2 Box plot visualization with Pandas and Seaborn  Applications and Projects  How to Do a vLookup in Python using pandas Convert CSV to HTML Table in Python KDE Plot Visualization with Pandas and Seaborn Analyzing selling price of used cars using Python Add CSS to the Jupyter Notebook using Pandas  Miscellaneous  More Functions on Python-Pandas More articles on pandas-dataframe More Functions on pandas-dataframe More articles on pandas-series More Functions on pandas-series More Articles on pandas-general-functions More Functions on pandas-datetime More Functions on pandas-datetimeIndex More Functions on pandas-timedelta More Functions on pandas-TimeDeltaIndex More Functions on pandas-Timestmap More Functions on pandas-series-datetime More Functions on pandas-multiindex  Recommended Posts:  Python | Pandas Index.insert() Python | Pandas DatetimeIndex.inferred_freq Python | Pandas PeriodIndex.start_time Python | Pandas PeriodIndex.week Python | Pandas Timestamp.second How to get column names in Pandas dataframe Python | Pandas Series.asobject Python | Pandas str.join() to join string/list elements with passed delimiter Python | Pandas DataFrame.reset_index() Python | Pandas dataframe.notna() Python | Pandas PeriodIndex.weekday Python | Pandas Series.dt.floor Python | Pandas Index.get_slice_bound() Python | Pandas Dataframe.duplicated() How to Remove repetitive characters from words of the given Pandas DataFrame using Regex? Python | Pandas dataframe.notnull() Capitalize first letter of a column in Pandas dataframe Python | Pandas series.cumprod() to find Cumulative product of a Series Use Pandas to Calculate Statistics in Python Python | Pandas Timestamp.date  "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/date-time/overview/",
	"title": "การจัดการวันเวลา",
	"tags": [],
	"description": "",
	"content": " เขียนเมื่อ 2016/06/21 19:35\n มอดูล datetime เป็นหนึ่งในมอดูลภายในตัวของไพธอน มีหน้าที่จัดการเกี่ยวกับเรื่องวันเดือนปีและเวลาต่างๆ หน้าที่มีความคล้ายคลึงกับมอดูล time (อ่านรายละเอียดใน https://phyblas.hinaboshi.com/20160610) แต่ก็มีความต่างกันอยู่ บางครั้งก็อาจใช้ร่วมกัน datetime มักถูกใช้เมื่อต้องการจัดการกับข้อมูลที่อยู่ในรูปของวันเดือนปีหรือเวลาชั่วโมงนาทีวินาที เวลาและวันเดือนปีนั้นเป็นปริมาณที่ใช้หน่วยหลากหลายในการอธิบาย และการแปลงหน่วยก็มีความยุ่งยากเพราะมีความไม่สม่ำเสมอ เช่นจำนวนวันในหนึ่งปีหรือหนึ่งเดือนเป็นต้น\nการใช้ออบเจ็กต์พิเศษของ datetime จะทำให้การคำนวณทำได้โดยง่ายขึ้น อีกทั้งยังสามารถปรับเปลี่ยนรูปแบบการแสดงผลให้เป็นไปตามที่ต้องการได้ง่ายด้วย การใช้มอดูลนี้ก่อนอื่นต้องเริ่มจากทำการ import เรียกใช้ก่อน\nimport datetime ออบเจ็กต์พิเศษใน datetime มอดูล datetime นั้นมีการนิยามคลาสของออบเจ็กต์สำหรับเก็บค่าวันเดือนปีและเวลาโดยเฉพาะ มีอยู่ ๔ ชนิดคือ\n datetime.date\tออบเจ็กต์เก็บค่าวันเดือนปี datetime.time\tออบเจ็กต์เก็บค่าเวลา datetime.datetime\tเป็นออบเจ็กต์ที่เอา datetime.date กับ datetime.time มารวมกัน เก็บค่าทั้งวันเดือนปีและเวลา datetime.timedelta\tออบเจ็กต์เก็บค่าระยะห่างระหว่างเวลาซึ่งมีหน่วยเป็นวันและวินาที  datetime.date จะเก็บค่าตัวเลขปี เดือน วัน ทั้งหมดเป็นจำนวนเต็มเอาไว้ ในการสร้าง datetime.date จะต้องใส่ค่าปี, เดือน, วัน ตามลำดับ เช่น\ndatetime.date(1905, 6, 1) เมื่อใช้คำสั่ง print จะแสดงผลเป็น ปี-เดือน-วัน\nprint(datetime.date(1905, 6, 1)) # ได้ 1905-06-01 ค่าเดือนจะใส่ได้แค่ 1 ถึง 12 และค่าวันจะใส่ได้แค่ไหนขึ้นอยู่กับจำนวนวันในเดือนนั้น และทั้งหมดต้องเป็นจำนวนเต็มเท่านั้น จะมีทศนิยมไม่ได้ ถ้าใส่ค่าที่ไม่อยู่ในขอบเขตที่กำหนดจะเกิดข้อผิดพลาดทันที เช่น\ndatetime.date(1911,2,29) # ได้ ValueError: day is out of range for month  datetime.date(1911,0,28) # ได้ ValueError: month must be in 1..12  datetime.date(1911,2,27.1) # ได้ TypeError: integer argument expected, got float ส่วน datetime.timeจะเก็บค่าเวลาในหน่วยชั่วโมง, นาที, วินาที และไมโครวินาที การสร้าง datetime.time จะต้องใส่ค่า ชั่วโมง, นาที, วินาที และไมโครวินาที เรียงตามลำดับ โดยจะใส่แต่ค่าชั่วโมงอย่างเดียวก็ได้ ค่าที่เหลือจะเป็น 0 เช่น\ndatetime.time(1) # คือ 1 ชั่วโมง 0 นาที 0 วินาที 0 ไมโครวินาที\ndatetime.time(23, 59, 59, 999999) # คือ 23 ชั่วโมง 59 นาที 59 วินาที 999999 ไมโครวินาที\nเมื่อสั่ง print จะแสดงผลเป็น ชั่วโมง:นาที:วินาที.ไมโครวินาที\nprint(datetime.time(23, 59, 59, 999999)) # ได้ 23:59:59.999999 ค่าชั่วโมงจะต้องอยู่ในช่วง 0 ถึง 23 นาทีและวินาทีเป็น 0 ถึง 60 ส่วนไมโครวินาทีตั้งแต่ 0 ถึง 999999 ค่าทั้งหมดต้องเป็นจำนวนเต็มเท่านั้น\nส่วนออบเจ็กต์ชนิด datetime.datetime นั้นเป็นตัวที่รวม datetime.date กับ datetime.time เข้าด้วยกัน คือจะเก็บค่า ปี, เดือน, วัน, ชั่วโมง, นาที, วินาที, ไมโครวินาที\nเวลาที่สร้าง datetime.datetime ขึ้นมาก็ใส่ค่าเรียงไล่ตั้งแต่ปีไปจนถึงไมโครวินาที โดยอาจใส่แค่ปีเดือนวัน ๓ ตัวเท่านั้นส่วนที่เหลือละไว้ก็ได้ เช่น\ndatetime.datetime(2016,6,21) # 21 มิ.ย. 2016 เวลา 0:00:00:000000 น. เมื่อสั่ง print จะแสดงผลเป็น ปี-เดือน-วัน ชั่วโมง:นาที:วินาที.ไมโครวินาที\nprint(datetime.datetime(2016,6,21,17,35,30,115421)) # ได้ 2016-06-21 17:35:30.115421 ส่วน datetime.timedelta นั้นจะเก็บค่าช่วงระยะเวลา โดยเก็บในรูปของวัน, วินาที และ ไมโครวินาทีเท่านั้น โดย 1 วันมีค่าเท่ากับ 606024 = 86400 วินาที\nการสร้าง datetime.timedelta นั้นต้องใส่ค่าเป็น วัน, วินาที และไมโครวินาที ตามลำดับ โดยสามารถละตัวหลังแล้วใส่แต่ตัวแรกๆก็ได้ เช่น\ndatetime.timedelta(1, 60) # คือ 1 วัน 60 วินาที (1 นาที) ค่าวันและวินาทีจะเป็นทศนิยมก็ได้ ถ้าใส่เป็นทศนิยมค่าจะถูกแปลงไปเป็นตัวหลังแทน เช่น\ndatetime.timedelta(1.1) # กลายเป็น datetime.timedelta(1, 8640)  datetime.timedelta(1.1111111111) # กลายเป็น datetime.timedelta(1, 9599, 999999) ในทางกลับกันหากใส่ค่าวินาทีเกิน 86400 ก็จะถูกแปลงเป็นวัน และหากใส่ไมโครวินาทีเกิน 1 ล้านก็จะถูกแปลงเป็นวินาที\nค่าที่ใส่จะติดลบก็ได้ ถ้าหากวินาทีหรือไมโครวินาทีติดลบจะถูกนำไปหักจากวันและวินาทีตามลำดับ เช่น\ndatetime.timedelta(1,-1,-1) # กลายเป็น datetime.timedelta(0, 86398, 999999) เรายังอาจสร้าง datetime.timedelta โดยกำหนดระยะเวลาเป็นมิลลิวินาที, นาที, ชั่วโมง, หรือสัปดาห์ได้ด้วย โดยใส่ในรูปคีย์เวิร์ด เวลาจะถูกแปลงเป็นหน่วยวัน, วินาที และไมโครวินาทีโดยอัตโนมัติ\ndatetime.timedelta(weeks=1,hours=17,minutes=2,milliseconds=999) # ได้ datetime.timedelta(7, 61320, 999000) เมื่อสั่ง print จะอยู่ในรูปของ วัน days, ชั่วโมง:นาที:วินาที.ไมโครวินาที\nprint(datetime.timedelta(111.9999999)) # ได้ 111 days, 23:59:59.991360 การคำนวณของ datetime.datetime และ datetime.timedelta\nเมื่อนำ datetime.datetime มาลบกันจะได้ผลออกมาเป็น datetime.timedelta ซึ่งเก็บค่าระยะเวลาระหว่างสองเวลาที่เอามาลบกันนั้น เช่น\ndatetime.datetime(2016,6,21)-datetime.datetime(2016,6,20) # ได้ datetime.timedelta(1) เนื่องจากหน่วยที่เก็บใน datetime.timedelta นั้นใหญ่สุดเป็นวัน และรองลงมาเป็นวินาที ดังนั้นหน่วยอื่นก็จะถูกแปลงเป็นวันและวินาทีหมด\ndatetime.datetime(2016,6,21,7)-datetime.datetime(2016,6,21,3) # ได้ datetime.timedelta(0, 14400)  datetime.datetime(2016,6,21)-datetime.datetime(1905,6,21) # ได้ datetime.timedelta(40543) นอกจากการลบกันแล้ว datetime.datetime และ datetime.datetime ด้วยกันไม่สามารถนำมาคำนวณอย่างอื่นได้เลย ทั้งบวก, คูณ, และยกกำลัง\nแต่ datetime.datetime สามารถนำมาบวกหรือลบกับ datetime.timedelta ได้ ซึ่งก็จะได้ผลเป็น datetime.datetime ตัวใหม่ เช่น\ndatetime.datetime(2016,6,21)+datetime.timedelta(0.71) # ได้ datetime.datetime(2016, 6, 21, 17, 2, 24)  datetime.datetime(2016,6,21)-datetime.timedelta(1,1,1) # ได้ datetime.datetime(2016, 6, 19, 23, 59, 58, 999999) ส่วน datetime.timedelta นั้นสามารถเอามาคูณหรือหารกับตัวเลขได้ แต่ไม่สามารถบวกหรือลบหรือยกกำลังได้\ndatetime.timedelta(1,1,1)*2 # ได้ datetime.timedelta(2, 2, 2)  datetime.timedelta(1,1,1)/2 # ได้ datetime.timedelta(0, 43200, 500000) datetime.timedelta กับ datetime.timedelta สามารถนำมาบวกหรือลบกันได้ แต่ไม่สามารถคูณหรือยกกำลังกันได้\ndatetime.timedelta(1,1)+datetime.timedelta(0,0,111) # ได้ datetime.timedelta(1, 1, 111)  datetime.timedelta(1,1,1)-datetime.timedelta(1,1,1) # ได้ datetime.timedelta(0) และสามารถหารกันได้ ผลที่ได้คือค่าจำนวนเท่าของระยะเวลา\ndatetime.timedelta(1,1,1)/datetime.timedelta(1) # ได้ 1.0000115740856481 และสามารถหารเอาเศษได้\ndatetime.timedelta(7,1,1)%datetime.timedelta(1) # ได้ datetime.timedelta(0, 1, 1)  datetime.timedelta(7,2,1)%datetime.timedelta(0,0,999999) # ได้ datetime.timedelta(0, 0, 604803) สำหรับการเปรียบเทียบระหว่างเวลานั้น datetime.datetime นึงจะมากกว่าอีก datetime.datetime หนึ่งเมื่อเป็นเวลาช้ากว่า ส่วน datetime.timedelta ก็เทียบตามความยาวของเวลา\ndatetime.datetime(2016,6,21)\u0026gt;datetime.datetime(2016,6,20) # ได้ True แอตทริบิวต์และเมธอดของ datetime.timedelta\nค่าของวัน, วินาที และไมโครวินาที ถูกเก็บอยู่ในแอตทริบิวต์ days, seconds และ microseconds ตามลำดับ\nสามารถแสดงค่าทั้งหมดเป็นวินาทีได้ด้วยเมธอด total_seconds()\nตัวอย่าง\ntdt = datetime.timedelta(3,70000,400000) print(tdt.days) # ได้ 3  print(tdt.seconds) # ได้ 70000  print(tdt.microseconds) # ได้ 400000  print(tdt.total_seconds()) # ได้ 329200.4 แอตทริบิวต์และเมธอดของ datetime.datetime\nภายในออบเจ็กต์ datetime.datetime นั้นเก็บข้อมูลของปี, เดือน, วัน, ชั่วโมง, นาที, วินาที, ไมโครวินาที เอาไว้โดยสามารถดูค่าแต่ละค่าได้ที่แอตทริบิวต์ year, month, day, hour, minute, second, microsecond\ndtdt = datetime.datetime(2016,6,21,17,35,30,115421) print(dtdt.year) # ได้ 2016  print(dtdt.month) # ได้ 6  print(dtdt.day) # ได้ 21  print(dtdt.hour) # ได้ 17  print(dtdt.minute) # ได้ 35  print(dtdt.second) # ได้ 30  print(dtdt.microsecond) # ได้ 115421 datetime.datetime ยังประกอบด้วยเมธอดต่างๆที่ใช้แสดงผลข้อมูลส่วนต่างๆในรูปแบบต่างๆ ได้แก่\ndate()\tแสดงส่วนวันเดือนปีในรูป datetime.date time()\tแสดงส่วนเวลาในรูป datetime.time weekday()\tแสดงเลขวันในสัปดาห์ โดยวันจันทร์เป็น 0 วันอาทิตย์เป็น 6 isoweekday()\tแสดงเลขวันในสัปดาห์ โดยวันจันทร์เป็น 1 วันอาทิตย์เป็น 7 isocalendar()\tแสดงผลวันเดือนปีในรูปแบบทูเพิล ctime()\tแสดงวันเวลาในรูป _วันในสัปดาห์ เดือน วัน ชั่วโมง:นาที:วินาที ปี_ timetuple()\tแสดงวันเวลาในรูปออบเจ็กต์ time.struct_time timestamp()\tแสดงเวลาในรูปของจำนวนวินาทีนับจากเที่ยงคืนเวลา UTC ของวันที่ 1 ม.ค. 1970 isoformat()\tแสดงวันเวลาในรูป _ปี-เดือน-วันTชั่วโมง:นาที:วินาที.ไมโครวินาที_ สำหรับ isoformat ถ้าใส่อาร์กิวเมนต์ลงไปจะเป็นตัวคั่นระหว่างวันกับชั่วโมงแทนตัว T\nตัวอย่างเมธอดต่างๆ\ndtdt = datetime.datetime(2016,6,21,17,35,30,115421) print(dtdt.date()) # ได้ 2016-06-21  print(dtdt.time()) # ได้ 17:35:30.115421  print(dtdt.weekday()) # ได้ 1  print(dtdt.isoweekday()) # ได้ 2  print(dtdt.isocalendar()) # ได้ (2016, 25, 2)  print(dtdt.ctime()) # ได้ Tue Jun 21 17:35:30 2016  print(dtdt.timetuple()) # ได้ time.struct_time(tm_year=2016, tm_mon=6, tm_mday=21, tm_hour=17, tm_min=35, tm_sec=30, tm_wday=1, tm_yday=173, tm_isdst=-1)  print(dtdt.isoformat()) # ได้ 2016-06-21T17:35:30.115421  print(dtdt.isoformat(\u0026#39; \u0026#39;)) # ได้ 2016-06-21 17:35:30.115421 สำหรับ timestamp() ค่าจะเป็น 0 ที่เวลา 7 โมงเช้าของวันที่ 1 ม.ค. 1970 เนื่องจากไทยอยู่เขตเวลา +7\nprint(dtdt.timestamp()) # ได้ 1466505330.115421  print(datetime.datetime(1970,1,1,0,0,0).timestamp()) # ได้ -25200.0  print(datetime.datetime(1970,1,1,7,0,0).timestamp()) # ได้ 0.0 การแก้ค่าวันเวลาใน datetime.datetime\nใน datetime.datetime มีเมธอด replace ซึ่งใช้แก้ไขค่าต่างๆภายใน datetime.datetime โดยอาร์กิวเมนต์ที่ต้องใส่นั้นเหมือนกับตอนสร้าง datetime.datetime เพียงแต่ว่าจะใส่แค่บางค่าในรูปคีย์เวิร์ดเฉพาะค่าที่ต้องการแก้เท่านั้น เพียงแต่ว่าเมธอดนี้ไม่ได้ทำการเปลี่ยนแปลงตัว datetime.datetime แค่คืนค่าของ datetime.datetime ที่ถูกแก้แล้วกลับมาเท่านั้น\nตัวอย่าง\ndtdt = datetime.datetime(2016,6,21,17,35,30,115421) dtdt.replace(2015) # ได้ datetime.datetime(2015, 6, 21, 17, 35, 30, 115421)  dtdt.replace(month=7) # ได้ datetime.datetime(2016, 7, 21, 17, 35, 30, 115421)  dtdt.replace(second=0,microsecond=0) # ได้ datetime.datetime(2016, 6, 21, 17, 35) การแสดงผลวันเวลาตามที่ต้องการ\nนอกจาก การแสดงผล datetime.datetime ด้วยเมธอดตามที่กล่าวมาข้างต้น เราสามารถให้แสดงผลวันเวลาในรูปแบบตามที่ต้องการซึ่งกำหนดเองได้โดยใช้เมธอด strftime อาร์กิวเมนต์ที่ต้องใส่คือสายอักขระที่ประกอบไปด้วย % ตามด้วยอักษร ซึ่งแทนค่าในส่วนต่างๆในรูปแบบต่างๆของวันเวลา ซึ่งสรุปได้ตามนี้\n%a\tวันในสัปดาห์ในรูปย่อ %A\tวันในสัปดาห์เป็นชื่อเต็ม %w\tวันในสัปดาห์เป็นตัวเลข อาทิตย์เป็น 0 เสาร์เป็น 6\t%d\tวันที่ในรูปเลขสองหลัก (เติม 0 เมื่อมีหลักเดียว) %b\tชื่อเดือนในรูปย่อ %B\tชื่อเดือนเป็นชื่อเต็ม %m\tเลขเดือนเป็นเลขสองหลัก (เติม 0 เมื่อมีหลักเดียว) %y\tเลขปีในรูปเลขสองหลักสุดท้าย %Y\tเลขปีในรูปเลขสี่หลัก (เติม 0 เมื่อมีไม่ถึงสี่หลัก) %H\tเวลาชั่วโมงเป็นเลขสองหลักถึง 24 (เติม 0 เมื่อมีหลักเดียว) %I\tเวลาชั่วโมงเป็นเลขสองหลักไม่เกิน 12 (เติม 0 เมื่อมีหลักเดียว) %p\tเวลา AM หรือ PM %M\tเวลานาทีเป็นเลขสองหลัก (เติม 0 เมื่อมีหลักเดียว) %S\tเวลาวินาทีเป็นเลขสองหลัก (เติม 0 เมื่อมีหลักเดียว) %f\tเวลาไมโครวินาทีเป็นเลขหกหลัก (เติม 0 เมื่อมีไม่ถึงหกหลัก) %j\tเลขลำดับวันในปี (1 ถึง 366) %U\tหรือ %W ลำดับของสัปดาห์ภายในปี %c\tแสดงวันเวลาในรูปแบบเดียวกับ ctime() %x\tเดือน/ปี/วัน %X\tชั่วโมง:นาที:วินาที ตัวอย่าง\ndtdt = datetime.datetime(2016,6,21,17,35,30,115421) print(dtdt.strftime(\u0026#39;%a\u0026#39;)) # ได้ Tue  print(dtdt.strftime(\u0026#39;%A\u0026#39;)) # ได้ Tuesday  print(dtdt.strftime(\u0026#39;%w\u0026#39;)) # ได้ 2  print(dtdt.strftime(\u0026#39;%d\u0026#39;)) # ได้ 21  print(dtdt.strftime(\u0026#39;%b\u0026#39;)) # ได้ Jun  print(dtdt.strftime(\u0026#39;%B\u0026#39;)) # ได้ June  print(dtdt.strftime(\u0026#39;%m\u0026#39;)) # ได้ 06  print(dtdt.strftime(\u0026#39;%y\u0026#39;)) # ได้ 16  print(dtdt.strftime(\u0026#39;%Y\u0026#39;)) # ได้ 2016  print(dtdt.strftime(\u0026#39;%H\u0026#39;)) # ได้ 17  print(dtdt.strftime(\u0026#39;%I\u0026#39;)) # ได้ 05  print(dtdt.strftime(\u0026#39;%p\u0026#39;)) # ได้ PM  print(dtdt.strftime(\u0026#39;%M\u0026#39;)) # ได้ 35  print(dtdt.strftime(\u0026#39;%S\u0026#39;)) # ได้ 30  print(dtdt.strftime(\u0026#39;%f\u0026#39;)) # ได้ 115421  print(dtdt.strftime(\u0026#39;%j\u0026#39;)) # ได้ 173  print(dtdt.strftime(\u0026#39;%U\u0026#39;)) # ได้ 25  print(dtdt.strftime(\u0026#39;%W\u0026#39;)) # ได้ 25  print(dtdt.strftime(\u0026#39;%c\u0026#39;)) # ได้ Tue Jun 21 17:35:30 2016  print(dtdt.strftime(\u0026#39;%x\u0026#39;)) # ได้ 06/21/16  print(dtdt.strftime(\u0026#39;%X\u0026#39;)) # ได้ 17:35:30 การสร้าง datetime.datetime จากเมธอดของคลาส\nเราสามารถสร้าง datetime.datetime ขึ้นมาจากเมธอดของคลาส datetime.datetime เองได้ด้วย เมธอดเหล่านั้นได้แก่\nnow()\tสร้าง datetime.datetime ขึ้นจากเวลาขณะนี้ utcnow()\tสร้าง datetime.datetime ขึ้นจากเวลาขณะนี้ในเขตเวลาสากล fromtimestamp()\tสร้าง datetime.datetime ขึ้นจาก timestamp โดยอิงเวลาท้องถิ่น utcfromtimestamp()\tสร้าง datetime.datetime ขึ้นจาก timestamp โดยอิงเวลาสากล combine()\tสร้าง datetime.datetime โดยใช้ datetime.date และ datetime.time มารวมกัน strptime()\tสร้าง datetime.datetime ขึ้นจากกระบวนการตรงข้ามกับ strftime ตัวอย่าง\nprint(datetime.datetime.now()) # ได้เวลาปัจจุบัน  print(datetime.datetime.utcnow()) # ได้เวลาปัจจุบันลบ 7 ชั่วโมง  print(datetime.datetime.fromtimestamp(0)) # ได้ 1970-01-01 07:00:00  print(datetime.datetime.utcfromtimestamp(0)) # ได้ 1970-01-01 00:00:00  dtd = datetime.date(2016,6,21) dtt = datetime.time(17,35,30,115421) print(datetime.datetime.combine(dtd,dtt)) # ได้ 2016-06-21 17:35:30.115421 เมธอด strptime นั้นเป็นกระบวนการที่ตรงกันข้ามกันกับ strftime ใช้แปลงสายอักขระที่มีรูปแบบตามที่กำหนดให้กลายเป็น datetime.datetime ในการใช้ให้ใส่สายอักขระที่จะแปลง ตามด้วยสายอักขระที่เขียนรูปแบบที่กำหนดการแปลง\nตัวอย่าง\nprint(datetime.datetime.strptime(\u0026#39;11:11:11.1111\u0026#39;,\u0026#39;%X.%f\u0026#39;)) # ได้ 1900-01-01 11:11:11.111100  print(datetime.datetime.strptime(\u0026#39;02\u0026#39;,\u0026#39;%H\u0026#39;)) # ได้ 1900-01-01 02:00:00  print(datetime.datetime.strptime(\u0026#39;7/6/1991\u0026#39;,\u0026#39;%d/%m/%Y\u0026#39;)) # ได้ 1991-06-07 00:00:00  r = u\u0026#39;1842-11-5 เวลา 8 โมง 41 นาที 32 วินาที\u0026#39; fmt = u\u0026#39;%Y-%m-%dเวลา %I โมง %M นาที %S วินาที\u0026#39; print(datetime.datetime.strptime(r,fmt)) # ได้ 1842-11-05 08:41:32 อ้างอิง\nhttp://docs.python.jp/3/library/datetime.html\nhttp://nkmk.github.io/blog/python-datetime\n Source : \n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/beginer/",
	"title": "ผู้เริ่มต้น (Beginer)",
	"tags": [],
	"description": "",
	"content": "ระดับพื้นฐาน\nบทที่ ๑: รู้จักกับภาษาไพธอน\n※\nบทที่ ๒: การติดตั้งและเริ่มเขียนโปรแกรม\n※ print\nบทที่ ๓: ตัวแปรและชนิดของข้อมูล\n※ int float complex str bool type\nบทที่ ๔: ฟังก์ชันพื้นฐาน\n※ input len\nบทที่ ๕: นิพจน์และการคำนวณ\n※ + - * / // % ** pow abs\nบทที่ ๖: ความเป็นจริงเท็จและการตั้งเงื่อนไข\n※ if elif else or and not == \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= !=\nบทที่ ๗: การทำซ้ำด้วย while\n※ while break continue\nบทที่ ๘: ข้อมูลชนิดลำดับ\n※ list tuple range append insert remove pop\nบทที่ ๙: การทำซ้ำด้วย for\n※ for in\nบทที่ ๑๐: การแสดงผลตัวอักษร\n※ \\n \\t \\b \\a %d %f %e %x %s\nบทที่ ๑๑: การจัดการกับสายอักขระ\n※ split join splitlines lower upper strip lstrip rstrip find rfind index rindex count startswith endswith replace\nบทที่ ๑๒: การจัดการกับลิสต์\n※ sort sorted reverse reversed max min\nบทที่ ๑๓: เซ็ต\n※ set add update remove discard issubset issuperset union intersection difference symmetric_difference\nบทที่ ๑๔: ดิกชันนารี\n※ dict keys values items\nบทที่ ๑๕: การเรียกใช้มอดูล\n※ from import as\nบทที่ ๑๖: ฟังก์ชันที่เกี่ยวข้องกับคณิตศาสตร์\n※ math\nเนื้อหาเพิ่มเติม ⊟ [2015/12/17] ความแตกต่างระหว่าง python 2.x และ 3.x\n⊟ [2015/12/18] range และ xrange ใน python 2.x และ 3.x\n⊟ [2015/12/19] unicode และ ASCII ใน python 2.x และ 3.x\n⊟ [2019/01/06] วิธีการติดตั้ง anaconda ใน linux\n⊟ [2019/01/14] การใช้ pip เพื่อติดตั้งแพ็กเกจเสริมใน python\n⊟ [2019/01/18] การใช้ conda เพื่อติดตั้งแพ็กเกจและสร้างสภาพแวดล้อมแบ่งแยก\n⊟ [2019/01/21] การถอนการติดตั้ง anaconda\n⊟ [2019/07/05] การใช้คำสั่ง python รันโปรแกรมในคอมมานด์ไลน์\n⊟ [2019/07/14] การใช้ f-string เพื่อจัดรูปแบบสายอักขระใน python\n⊟ [2020/06/29] วิธีการพิมพ์อักษรกรีกหรืออักษรพิเศษเพิ่มเติมโดยใช้ ipython\nเกร็ดเล็กน้อย ⊟ [2016/04/30] สร้างแอตทริบิวต์ที่มีคุณสมบัติพิเศษในคลาสด้วย property\n⊟ [2018/05/31] ข้อควรระวังเมื่อใช้ try และ except แล้วต้องการหยุดโปรแกรมกลางคัน\n⊟ [2019/01/07] วิธีทำให้ import มอดูลที่ต้องการทุกครั้งเมื่อเริ่มโปรแกรม\n⊟ [2019/01/08] วิธีการรันไพธอนโดยตรงใน unix shell ใน mac และ linux\n⊟ [2019/01/12] ข้อควรระวังเมื่อมีการแก้ไขลิสต์ขณะใช้ for อาจทำให้เกิดการวนซ้ำไม่สิ้นสุดได้\n⊟ [2019/06/24] ทำความเข้าใจ and และ or ให้มากขึ้น\n⊟ [2019/07/13] เปรียบเทียบระหว่างการใช้ %, ใช้ format และใช้ f-string ใน python\nการประยุกต์ใช้ \u0026raquo; สารบัญแนะนำมอดูลต่างๆ \u0026raquo; สารบัญการเรียนรู้ของเครื่อง \u0026raquo; สารบัญโครงข่ายประสาทเทียม จิปาถะ ⊟ [2017/02/23] สร้างแฟร็กทัลอย่างง่าย\n⊟ [2018/03/26] ใช้ opencv (cv2) เพื่อค้นหาใบหน้าอนิเมะ\n⊟ [2018/03/29] ค้นหาภาพใบหน้าอนิเมะจากเว็บ safebooru\n⊟ [2018/07/14] สร้างเส้นโค้งฮิลแบร์ทสองมิติ\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/date-time/center/",
	"title": "Date &amp; Time tutorial",
	"tags": [],
	"description": "",
	"content": "Dealing with dates and times in Python can be a hassle. Thankfully, there’s a built-in way of making it easier: the Python datetime module.\ndatetime helps us identify and process time-related elements like dates, hours, minutes, seconds, days of the week, months, years, etc. It offers various services like managing time zones and daylight savings time. It can work with timestamp data. It can extract the day of the week, day of the month, and other date and time formats from strings.\nIn short, it’s a really powerful way of handling anything date and time related in Python. So let’s get into it!\nIn this tutorial, we’ll learn about python datetime functions in detail, including:\n  Creating Date Objects\n  Getting year and month from the date\n  Getting month day and Weekday from date\n  Getting hour and minutes from the date\n  Getting Week number of the year from date\n  Converting date object into timestamp\n  Converting UNIX timestamp string to date object\n  Handling timedelta objects\n  Getting the difference between two dates and times\n  Formatting dates: strftime() and strptime()\n  Handling timezones\n  Working with Pandas datetime objects\n Getting year, month, day, hour, and minute Getting weekday and day of year Converting date objects into a DataFrame index    As you work through this tutorial, we’d encourage you to run the code on your own machine. Alternatively, if you’d like to run code in your browser and learn in an interactive fashion with answer-checking to be sure you’re getting it right, our free Python intermediate course has a lesson on datetime in Python that we recommend. All it requires is signing up for a free user account.\nPython datetime Classes Before jumping into writing code, it’s worth looking at the five main object classes that are used in the datetime module. Depending on what we’re trying to do, we’ll likely need to make use of one or more of these distinct classes:\n  datetime – Allows us to manipulate times and dates together (month, day, year, hour, second, microsecond).\n  date – Allows us to manipulate dates independent of time (month, day, year).\n  time – Allows us to manipulate time independent of date (hour, minute, second, microsecond).\n  timedelta— A duration of time used for manipulating dates and measuring.\n  tzinfo— An abstract class for dealing with time zones.\n  If those distinctions don’t make sense yet, don’t worry! Let’s dive into datetime and start working with it to better understand how these are applied.\nCreating Date Objects First, let’s take a closer look at a datetime object. Since datetime is both a module and a class within that module, we’ll start by importing the datetime class from the datetime module.\nThen, we’ll print the current date and time to take a closer look at what’s contained in a datetime object. We can do this using datetime‘s .now() function. We’ll print our datetime object, and then also print its type using type() so we can take a closer look.\n# import datetime class from datetime module from datetime import datetime # get current date datetime_object = datetime.now() print(datetime_object) print(\u0026#39;Type :- \u0026#39;,type(datetime_object)) 2019-10-25 10:24:01.521881 Type :- \u0026lt;class \u0026#39;datetime.datetime\u0026#39;\u0026gt; We can see from the results above that datetime_object is indeed a datetime object of the datetime class. This includes the year, month, day, hour, minute, second, and microsecond.\nExtract Year and Month from the Date Now we’ve seen what makes up a datetime object, we can probably guess how date and time objects look, because we know that date objects are just like datetime without the time data, and time objects are just like datetime without the date data.\nWe can also antipate some problems. For example, in most data sets, date and time information is stored in string format! Also, we may not want all of this date and time data — if we’re doing something like a monthly sales analysis, breaking things down by microsecond isn’t going to be very useful.\nSo now, let’s start digging into a common task in data science: extracting only the elements that we actually want from a string using datetime.\nTo do this, we need to do a few things.\nHandling Date and Time Strings with strptime() and strftime() Thankfully, datetime includes two methods, strptime() and strftime(), for converting objects from strings to datetime objects and vice versa. strptime() can read strings with date and time information and convert them to datetime objects, and strftime() converts datetime objects back into strings.\nOf course, strptime() isn’t magic — it can’t turn any string into a date and time, and it will need a little help from us to interpret what it’s seeing! But it’s capable of reading most conventional string formats for date and time data (see the documentation for more details). Let’s give it a date string in YYYY-MM-DD format and see what it can do!\nmy_string = \u0026#39;2019-10-31\u0026#39; # Create date object in given time format yyyy-mm-dd my_date = datetime.strptime(my_string, \u0026#34;%Y-%m-%d\u0026#34;) print(my_date) print(\u0026#39;Type: \u0026#39;,type(my_date)) 2019-10-31 00:00:00 Type: \u0026lt;class \u0026#39;datetime.datetime\u0026#39;\u0026gt; Note that strptime() took two arguments: the string (my_string) and \u0026quot;%Y-%m-%d\u0026quot;, another string that tells strptime() how to interpret the input string my_string. %Y, for example, tells it to expect the first four characters of the string to be the year.\nA full list of these patterns is available in the documentation, and we’ll go into these methods in more depth later in this tutorial.\nYou may also have noticed that a time of 00:00:00 has been added to the date. That’s because we created a datetime object, which must include a date and a time. 00:00:00 is the default time that will be assigned if no time is designated in the string we’re inputting.\nAnyway, we were hoping to separate out specific elements of the date for our analysis. One way can do that using the built-in class attributes of a datetime object, like .month or .year:\nprint(\u0026#39;Month: \u0026#39;, my_date.month) # To Get month from date print(\u0026#39;Year: \u0026#39;, my_date.year) # To Get month from year Month: 10 Year: 2019 Getting Day of the Month and Day of the Week from a Date Let’s do some more extraction, because that’s a really common task. This time, we’ll try to get the day of the month and the day of the week from my_date. Datetime will give us the day of the week as a number using its .weekday() function, but we can convert this to a text format (i.e. Monday, Tuesday, Wednesday…) using the calendar module and a method called day_name.\nWe’ll start by importing calendar, and then using .day and .weekday() on my_date. From there, we can get the day of the week in text format like so:\n# import calendar module import calendar print(\u0026#39;Day of Month:\u0026#39;, my_date.day) # to get name of day(in number) from date print(\u0026#39;Day of Week (number): \u0026#39;, my_date.weekday()) # to get name of day from date print(\u0026#39;Day of Week (name): \u0026#39;, calendar.day_name[my_date.weekday()]) Day of Month: 31 Day of Week (number): 3 Day of Week (name): Thursday Wait a minute, that looks a bit odd! The third day of the week should be Wednesday, not Thursday, right?\nLet’s take a closer look at that day_name variable using a for loop:\nj = 0 for i in calendar.day_name: print(j,\u0026#39;-\u0026#39;,i) j+=1 0 - Monday 1 - Tuesday 2 - Wednesday 3 - Thursday 4 - Friday 5 - Saturday 6 - Sunday Now we can see that Python starts weeks on Monday and counts from the index 0 rather than starting at 1. So it makes sense that the number 3 is converted to “Thursday” as we saw above.\nGetting Hours and Minutes From a Python Datetime Object Now let’s dig into time and extract the hours and minutes from datetime object. Much like what we did above with month and year, we can use class attributes .hour and .minute to get the hours and minutes of the day.\nLet’s set a new date and time using the .now() function. As of this writing, it’s October 25, 2019 at 10:25 AM. You’ll get different results depending on when you choose to run this code, of course!\nfrom datetime import datetime todays_date = datetime.now() # to get hour from datetime print(\u0026#39;Hour: \u0026#39;, todays_date.hour) # to get minute from datetime print(\u0026#39;Minute: \u0026#39;, todays_date.minute) Hour: 10 Minute: 25 Getting Week of the Year from a Datetime Object We can also do fancier things with datetime. For example, what if we want to know what week of the year it is?\nWe can get the year, week of the year, and day of the week from a datetime object with the .isocalendar() function.\nSpecifically, isocalendar() returns a tuple with ISO year, week number and weekday. The ISO calendar is a widely-used standard calendar based on the Gregorian calendar. You can read about it in more detail at that link, but for our purposes, all we need to know is that it works as a regular calendar, starting each week on Monday.\n# Return a 3-tuple, (ISO year, ISO week number, ISO weekday). todays_date.isocalendar() (2019, 43, 5) Note that in the ISO calendar, the week starts counting from 1, so here 5 represents the correct day of the week: Friday.\nWe can see from the above that this is the 43rd week of the year, but if we wanted to isolate that number, we could do so with indexing just as we might for any other Python list or tuple:\ntodays_date.isocalendar()[1] 43 Converting a Date Object into Unix Timestamp and Vice Versa In programming, it’s not uncommon to encounter time and date data that’s stored as a timestamp, or to want to store your own data in Unix timestamp format.\nWe can do that using datetime’s built-in timestamp() function, which takes a datetime object as an argument and returns that date and time in timestamp format:\n#import datetime from datetime import datetime # get current date now = datetime.now() # convert current date into timestamp timestamp = datetime.timestamp(now) print(\u0026#34;Date and Time :\u0026#34;, now) print(\u0026#34;Timestamp:\u0026#34;, timestamp) Date and Time : 2019-10-25 10:36:32.827300 Timestamp: 1572014192.8273 Similarly, we can do the reverse conversion using fromtimestamp(). This is a datetime function that takes a timestamp (in float format) as an argument and returns a datetime object, as below:\n#import datetime from datetime import datetime timestamp = 1572014192.8273 #convert timestamp to datetime object dt_object = datetime.fromtimestamp(timestamp) print(\u0026#34;dt_object:\u0026#34;, dt_object) print(\u0026#34;type(dt_object): \u0026#34;, type(dt_object)) dt_object: 2019-10-25 10:36:32.827300 type(dt_object): \u0026lt;class \u0026#39;datetime.datetime\u0026#39;\u0026gt; Measuring Time Span with Timedelta Objects Often, we may want to measure a span of time, or a duration, using Python datetime. We can do this with its built-in timedelta class. A timedelta object represents the amount of time between two dates or times. We can use this to measure time spans, or manipulate dates or times by adding and subtracting from them, etc.\nBy default a timedelta object has all parameters set to zero. Let’s create a new timedelta object that’s two weeks long and see how that looks:\n#import datetime from datetime import timedelta # create timedelta object with difference of 2 weeks d = timedelta(weeks=2) print(d) print(type(d)) print(d.days) 14 days, 0:00:00 \u0026lt;class \u0026#39;datetime.timedelta\u0026#39;\u0026gt; 14 Note that we can get our time duration in days by using the timedelta class attribute .days. As we can see in its documentation, we can also get this time duration in seconds or microseconds.\nLet’s create another timedelta duration to get a bit more practice:\nyear = timedelta(days=365) print(year) 365 days, 0:00:00 Now let’s start doing using timedelta objects together with datetime objects to do some math! Specifically, let’s add a few diffeent time durations to the current time and date to see what date it will be after 15 days, what date it was two weeks ago.\nTo do this, we can use the + or - operators to add or subtract the timedelta object to/from a datetime object. The result will be the datetime object plus or minus the duration of time specified in our timedelta object. Cool, right?\n(Note: in the code below, it’s October 25 at 11:12 AM; your results will differ depending on when you run the code since we’re getting our datetime object using the .now() function).\n#import datetime from datetime import datetime, timedelta # get current time now = datetime.now() print (\u0026#34;Today\u0026#39;s date: \u0026#34;, str(now)) #add 15 days to current date future_date_after_15days = now + timedelta(days = 15) print(\u0026#39;Date after 15 days: \u0026#39;, future_date_after_15days) #subtract 2 weeks from current date two_weeks_ago = now - timedelta(weeks = 2) print(\u0026#39;Date two weeks ago: \u0026#39;, two_weeks_ago) print(\u0026#39;two_weeks_ago object type: \u0026#39;, type(two_weeks_ago)) Today\u0026#39;s date: 2019-10-25 11:12:24.863308 Date after 15 days: 2019-11-09 11:12:24.863308 Date two weeks ago: 2019-10-11 11:12:24.863308 two_weeks_ago object type: \u0026lt;class \u0026#39;datetime.datetime\u0026#39;\u0026gt; Note that the output of these mathematical operations is still a datetime object.\nFind the Difference Between Two Dates and Times Similar to what we did above, we can also subtract one date from another date to find the timespan between them using datetime.\nBecause the result of this math is a duration, the object produced when we subtract one date from another will be a timedelta object.\nHere, we’ll create two date objects (remeber, these work the same as datetime objects, they just don’t include time data) and subtract one from the other to find the duration:\n# import datetime from datetime import date # Create two dates date1 = date(2008, 8, 18) date2 = date(2008, 8, 10) # Difference between two dates delta = date2 - date1 print(\u0026#34;Difference: \u0026#34;, delta.days) print(\u0026#39;delta object type: \u0026#39;, type(delta)) Difference: -8 delta object type: \u0026lt;class \u0026#39;datetime.timedelta\u0026#39;\u0026gt; Above, we used only dates for the sake of clarity, but we can do the same thing with datetime objects to get a more precise measurement that includes hours, minutes, and seconds as well:\n# import datetime from datetime import datetime # create two dates with year, month, day, hour, minute, and second date1 = datetime(2017, 6, 21, 18, 25, 30) date2 = datetime(2017, 5, 16, 8, 21, 10) # Difference between two dates diff = date1-date2 print(\u0026#34;Difference: \u0026#34;, diff) Difference: 36 days, 10:04:20 Formatting Dates: More on strftime() and strptime() We touched briefly on strftime() and strptime() earlier, but let’s take a closer look at these methods, as they’re often important for data analysis work in Python.\nstrptime() is the method we used before, and you’ll recall that it can turn a date and time that’s formatted as a text string into a datetime object, in the following format:\ntime.strptime(string, format)\nNote that it takes two arguments:\n  string − the time in string format that we want to convert\n  format − the specific formatting of the time in the string, so that strptime() can parse it correctly\n  Let’s try converting a different kind of date string this time. This site is a really useful reference for finding the formatting codes needed to help strptime() interpret our string input.\n# import datetime from datetime import datetime date_string = \u0026#34;1 August, 2019\u0026#34; # format date date_object = datetime.strptime(date_string, \u0026#34;%d%B, %Y\u0026#34;) print(\u0026#34;date_object: \u0026#34;, date_object) date_object: 2019-08-01 00:00:00 Now let’s do something a bit more advanced to practice everything we’ve learned so far! We’ll start with a date in string format, convert it to a datetime object, and look at a couple different ways of formatting it (dd/mm and mm/dd).\nThen, sticking with the mm/dd formatting, we’ll convert it into a Unix timestamp. Then we’ll convert it back into a datetime object, and convert that back into strings using a few different strftime patterns to control the output:\n# import datetime from datetime import datetime dt_string = \u0026#34;12/11/2018 09:15:32\u0026#34; # Considering date is in dd/mm/yyyy format dt_object1 = datetime.strptime(dt_string, \u0026#34;%d/%m/%Y %H:%M:%S\u0026#34;) print(\u0026#34;dt_object1:\u0026#34;, dt_object1) # Considering date is in mm/dd/yyyy format dt_object2 = datetime.strptime(dt_string, \u0026#34;%m/%d/%Y %H:%M:%S\u0026#34;) print(\u0026#34;dt_object2:\u0026#34;, dt_object2) # Convert dt_object2 to Unix Timestamp timestamp = datetime.timestamp(dt_object2) print(\u0026#39;Unix Timestamp: \u0026#39;, timestamp) # Convert back into datetime date_time = datetime.fromtimestamp(timestamp) d = date_time.strftime(\u0026#34;%c\u0026#34;) print(\u0026#34;Output 1:\u0026#34;, d) d = date_time.strftime(\u0026#34;%x\u0026#34;) print(\u0026#34;Output 2:\u0026#34;, d) d = date_time.strftime(\u0026#34;%X\u0026#34;) print(\u0026#34;Output 3:\u0026#34;, d) dt_object1: 2018-11-12 09:15:32 dt_object2: 2018-12-11 09:15:32 Unix Timestamp: 1544537732.0 Output 1: Tue Dec 11 09:15:32 2018 Output 2: 12/11/18 Output 3: 09:15:32 Here’s an image you can save with a cheat sheet for common, useful strptime and strftime patterns:\nLet’s get a little more practice using these:\n# current date and time now = datetime.now() # get year from date year = now.strftime(\u0026#34;%Y\u0026#34;) print(\u0026#34;Year:\u0026#34;, year) # get month from date month = now.strftime(\u0026#34;%m\u0026#34;) print(\u0026#34;Month;\u0026#34;, month) # get day from date day = now.strftime(\u0026#34;%d\u0026#34;) print(\u0026#34;Day:\u0026#34;, day) # format time in HH:MM:SS time = now.strftime(\u0026#34;%H:%M:%S\u0026#34;) print(\u0026#34;Time:\u0026#34;, time) # format date date_time = now.strftime(\u0026#34;%m/%d/%Y, %H:%M:%S\u0026#34;) print(\u0026#34;Date and Time:\u0026#34;,date_time) Year: 2019 Month; 10 Day: 25 Time: 11:56:41 Date and Time: 10/25/2019, 11:56:41\nHandling Timezones Working with dates and times in Pythin can get even more complicated when timezones get involved. Thankfully, the pytz module exists to help us deal with cross-timezone conversions. It also handles the daylight savings time in locations that use that.\nWe can use the localize function to add a time zone location to a Python datetime object. Then we can use the function astimezone() to convert the existing local time zone into any other time zone we specify (it takes the time zone we want to convert into as an argument).\nFor example:\n# import timezone from pytz module from pytz import timezone # Create timezone US/Eastern east = timezone(\u0026#39;US/Eastern\u0026#39;) # Localize date loc_dt = east.localize(datetime(2011, 11, 2, 7, 27, 0)) print(loc_dt) # Convert localized date into Asia/Kolkata timezone kolkata = timezone(\u0026#34;Asia/Kolkata\u0026#34;) print(loc_dt.astimezone(kolkata)) # Convert localized date into Australia/Sydney timezone au_tz = timezone(\u0026#39;Australia/Sydney\u0026#39;) print(loc_dt.astimezone(au_tz)) 2011-11-02 07:27:00-04:00 2011-11-02 16:57:00+05:30 2011-11-02 22:27:00+11:00 This module can help make life simpler when working with data sets that include multiple different time zones.\nWorking with pandas Datetime Objects Data scientists love pandas for many reasons. One of them is that it contains extensive capabilities and features for working with time series data. Much like datetime itself, pandas has both datetime and timedelta objects for specifying dates and times and durations, respectively.\nWe can convert date, time, and duration text strings into pandas Datetime objects using these functions:\n to_datetime(): Converts string dates and times into Python datetime objects. to_timedelta(): Finds differences in times in terms of days, hours, minutes, and seconds.  And as we’ll see, these functions are actually quite good at converting strings to Python datetime objects by detecting their format automatically, without needing us to define it using strftime patterns.\nLet’s look at a quick example:\n# import pandas module as pd import pandas as pd # create date object using to_datetime() function date = pd.to_datetime(\u0026#34;8th of sep, 2019\u0026#34;) print(date) 2019-09-08 00:00:00 Note that even though we gave it a string with some complicating factors like a “th” and “sep” rather than “Sep.” or “September”, pandas was able to correctly parse the string and return a formatted date.\nWe can also use pandas (and some of its affiliated numpy functionality) to create date ranges automatically as pandas Series. Below, for example, we create a series of twelve dates starting from the day we defined above. Then we create a different series of dates starting from a predefined date using pd.date_range():\n# Create date series using numpy and to_timedelta() function date_series = date + pd.to_timedelta(np.arange(12), \u0026#39;D\u0026#39;) print(date_series) # Create date series using date_range() function date_series = pd.date_range(\u0026#39;08/10/2019\u0026#39;, periods = 12, freq =\u0026#39;D\u0026#39;) print(date_series) DatetimeIndex([\u0026#39;2019-09-08\u0026#39;, \u0026#39;2019-09-09\u0026#39;, \u0026#39;2019-09-10\u0026#39;, \u0026#39;2019-09-11\u0026#39;, \u0026#39;2019-09-12\u0026#39;, \u0026#39;2019-09-13\u0026#39;, \u0026#39;2019-09-14\u0026#39;, \u0026#39;2019-09-15\u0026#39;, \u0026#39;2019-09-16\u0026#39;, \u0026#39;2019-09-17\u0026#39;, \u0026#39;2019-09-18\u0026#39;, \u0026#39;2019-09-19\u0026#39;], dtype=\u0026#39;datetime64[ns]\u0026#39;, freq=None) DatetimeIndex([\u0026#39;2019-08-10\u0026#39;, \u0026#39;2019-08-11\u0026#39;, \u0026#39;2019-08-12\u0026#39;, \u0026#39;2019-08-13\u0026#39;, \u0026#39;2019-08-14\u0026#39;, \u0026#39;2019-08-15\u0026#39;, \u0026#39;2019-08-16\u0026#39;, \u0026#39;2019-08-17\u0026#39;, \u0026#39;2019-08-18\u0026#39;, \u0026#39;2019-08-19\u0026#39;, \u0026#39;2019-08-20\u0026#39;, \u0026#39;2019-08-21\u0026#39;], dtype=\u0026#39;datetime64[ns]\u0026#39;, freq=\u0026#39;D\u0026#39;) Get Year, Month, Day, Hour, Minute in pandas We can easily get year, month, day, hour, or minute from dates in a column of a pandas dataframe using dt attributes for all columns. For example, we can use df['date'].dt.year to extract only the year from a pandas column that includes the full date.\nTo explore this, let’s make a quick DataFrame using one of the Series we created above:\n# Create a DataFrame with one column date df = pd.DataFrame() df[\u0026#39;date\u0026#39;] = date_series df.head() date 0\t2019-08-10 1\t2019-08-11 2\t2019-08-12 3\t2019-08-13 4\t2019-08-14 Now, let’s create separate columns for each element of the date by using the relevant Python datetime (accessed with dt) attributes:\n# Extract year, month, day, hour, and minute. Assign all these date component to new column. df[\u0026#39;year\u0026#39;] = df[\u0026#39;date\u0026#39;].dt.year df[\u0026#39;month\u0026#39;] = df[\u0026#39;date\u0026#39;].dt.month df[\u0026#39;day\u0026#39;] = df[\u0026#39;date\u0026#39;].dt.day df[\u0026#39;hour\u0026#39;] = df[\u0026#39;date\u0026#39;].dt.hour df[\u0026#39;minute\u0026#39;] = df[\u0026#39;date\u0026#39;].dt.minute df.head()    date year month day hour minute     2019-08-10 2019 8 10 0 0   2019-08-11 2019 8 11 0 0   2019-08-12 2019 8 12 0 0   2019-08-13 2019 8 13 0 0   2019-08-14 2019 8 14 0 0    Get Weekday and Day of Year Pandas is also capable of getting other elements, like the day of the week and the day of the year, from its datetime objects. Again, we can use dt attributes to do this. Note that here, as in Python generally, the week starts on Monday at index 0, so day of the week 5 is Saturday.\n# get Weekday and Day of Year. Assign all these date component to new column. df[\u0026#39;weekday\u0026#39;] = df[\u0026#39;date\u0026#39;].dt.weekday df[\u0026#39;day_name\u0026#39;] = df[\u0026#39;date\u0026#39;].dt.weekday_name df[\u0026#39;dayofyear\u0026#39;] = df[\u0026#39;date\u0026#39;].dt.dayofyear df.head()    date year month day hour minute weekday day_name dayofyear     2019-08-10 2019 8 10 0 0 5 Saturday 222   2019-08-11 2019 8 11 0 0 6 Sunday 223   2019-08-12 2019 8 12 0 0 0 Monday 224   2019-08-13 2019 8 13 0 0 1 Tuesday 225   2019-08-14 2019 8 14 0 0 2 Wednesday 226    Convert Date Object into DataFrame Index We can also use pandas to make a datetime column into the index of our DataFrame. This can be very helpful for tasks like exploratory data visualization, because matplotlib will recognize that the DataFrame index is a time series and plot the data accordingly.\nTo do this, all we have to do is redefine df.index:\n# Assign date column to dataframe index df.index = df.date df.head()    date.1 year month day hour minute weekday day_name dayofyear     2019-08-10 2019 8 10 0 0 5 Saturday 222   2019-08-11 2019 8 11 0 0 6 Sunday 223   2019-08-12 2019 8 12 0 0 0 Monday 224   2019-08-13 2019 8 13 0 0 1 Tuesday 225   2019-08-14 2019 8 14 0 0 2 Wednesday 226    Conclusion In this tutorial, we’ve taken a deep dive into Python datetime, and also done some work with pandas and the calendar module. We’ve covered a lot, but remember: the best way to learn something is by actually writing code yourself! If you’d like to practice writing datetime code with interactive answer-checking, check out our free Python intermediate course for a lesson on datetime in Python with interative answer-checking and in-browser code-running.\n Source : .\n  Basic datetime objects usage:  Last update on November 09 2019 06:55:23\n The datetime module supplies classes for manipulating dates and times in both simple and complex ways.\nThe datetime module contains three primary types of objects - date, time, and datetime.\nDate:\nimport datetime today = datetime.date.today() new_year = datetime.date(2019, 1, 1) print(new_year) Output: # 2019-01-01 Time:\nimport datetime #Time object noon = datetime.time(12, 0, 0) print(noon) Output: # 12:00:00 Date Time:\nimport datetime # Current datetime now = datetime.datetime.now() print(now) Output: # 2019-11-01 06:16:18.526734 Date Time:\nimport datetime # Datetime object millenium_turn = datetime.datetime(2019, 1, 1, 0, 0, 0) print(millenium_turn) Output: # 2019-01-01 00:00:00 Iterate over dates: Print from a start date to some end date.\nimport datetime # The size of each step in days day_delta = datetime.timedelta(days=1) start_date = datetime.date.today() end_date = start_date + 7*day_delta for i in range((end_date - start_date).days): print(start_date + i*day_delta) Output: # 2019-11-01 # 2019-11-02 # 2019-11-03 # 2019-11-04 # 2019-11-05 # 2019-11-06 # 2019-11-07 Computing time differences: The timedelta module is used to compute differences between times:\nfrom datetime import datetime, timedelta now = datetime.now() then = datetime(2019, 5, 23) print(then) Output: # 2019-05-23 00:00:00 Specifying time is optional when creating a new datetime object\nfrom datetime import datetime, timedelta now = datetime.now() then = datetime(2019, 5, 23) delta = now-then print(delta) Output: # 162 days, 9:10:42.599772 delta is of type timedelta:\nfrom datetime import datetime, timedelta now = datetime.now() then = datetime(2019, 5, 23) delta = now-then print(delta.days) # 60 print(delta.seconds) # 40826 Output: # 162 # 33296 To get n day\u0026rsquo;s after and n day\u0026rsquo;s before date we could use:\nn day\u0026rsquo;s after date: from datetime import date, timedelta current_date = date.today().isoformat() days_after = (date.today()+timedelta(days=30)).isoformat() print(\u0026#34;\\nCurrent Date: \u0026#34;,current_date) print(\u0026#34;30 days after current date : \u0026#34;,days_after) Output: # Current Date: 2019-11-02 # 30 days after current date : 2019-12-02 n day\u0026rsquo;s before date: from datetime import date, timedelta current_date = date.today().isoformat() days_before = (date.today()-timedelta(days=30)).isoformat() print(\u0026#34;\\nCurrent Date: \u0026#34;,current_date) print(\u0026#34;30 days before current date: \u0026#34;,days_before) Output: # Current Date: 2019-11-02 # 30 days before current date: 2019-10-03 Converting timestamp to date time: The datetime module can convert a POSIX timestamp to a ITC datetime object.\nThe Epoch is January 1st, 1970 midnight.\nimport time from datetime import datetime seconds_since_epoch=time.time() #1469182681.709 utc_date=datetime.utcfromtimestamp(seconds_since_epoch) print(utc_date) Output: # 2019-11-01 09:53:20.657171 Simple date arithmetic: import datetime today = datetime.date.today() print(\u0026#39;Today:\u0026#39;, today) yesterday = today - datetime.timedelta(days=1) print(\u0026#39;Yesterday:\u0026#39;, yesterday) tomorrow = today + datetime.timedelta(days=1) print(\u0026#39;Tomorrow:\u0026#39;, tomorrow) print(\u0026#39;Time between tomorrow and yesterday:\u0026#39;, tomorrow - yesterday) Output: # Today: 2019-11-01 # Yesterday: 2019-10-31 # Tomorrow: 2019-11-02 # Time between tomorrow and yesterday: 2 days, 0:00:00 Subtracting months from a date: import calendar from datetime import date def monthdelta(date, delta): m, y = (date.month+delta) % 12, date.year + ((date.month)+delta-1) // 12 if not m: m = 12 d = min(date.day, calendar.monthrange(y, m)[1]) return date.replace(day=d,month=m, year=y) next_month = monthdelta(date.today(), 1) #datetime.date(2019, 10, 23) print(next_month) Output: # 2019-12-01 Using the dateutils module: import datetime import dateutil.relativedelta d = datetime.datetime.strptime(\u0026#34;2019-03-31\u0026#34;, \u0026#34;%Y-%m-%d\u0026#34;) d2 = d - dateutil.relativedelta.relativedelta(months=1) #datetime.datetime(2019, 2, 28, 0, 0) print(d2) Output: # 2019-02-28 00:00:00 Switching between time zones: To switch between time zones, we need datetime objects that are timezone-aware.\nfrom datetime import datetime from dateutil import tz utc = tz.tzutc() local = tz.tzlocal() utc_now = datetime.utcnow() utc_now # Not timezone-aware. utc_now = utc_now.replace(tzinfo=utc) utc_now # Timezone-aware. local_now = utc_now.astimezone(local) local_now # Converted to local time. print(local_now) Output: # 2019-11-01 10:10:09.685012+00:00 Fuzzy datetime parsing (extracting datetime out of a text): from dateutil.parser import parse dt = parse(\u0026#34;Today is January 1, 2019 at 8:21:00AM\u0026#34;, fuzzy=True) print(dt) Output: # 2019-01-01 08:21:00 Get an ISO 8601 timestamp:\nWithout timezone, with microseconds: from datetime import datetime print (datetime.now().isoformat()) Output: # 2019-11-01T10:42:00.720818 With timezone, with microseconds: from datetime import datetime from dateutil.tz import tzlocal print (datetime.now(tzlocal()).isoformat()) Output: # 2019-11-01T10:46:20.965506+00:00 With timezone, without microseconds: from datetime import datetime from dateutil.tz import tzlocal print (datetime.now(tzlocal()).replace(microsecond=0).isoformat()) Output: # 2019-11-01T10:49:58+00:00 Parsing a string with a short time zone name into a timr zone aware datetime object: from dateutil import tz from dateutil.parser import parse ET = tz.gettz(\u0026#39;US/Eastern\u0026#39;) CT = tz.gettz(\u0026#39;US/Central\u0026#39;) MT = tz.gettz(\u0026#39;US/Mountain\u0026#39;) PT = tz.gettz(\u0026#39;US/Pacific\u0026#39;) us_tzinfos = {\u0026#39;CST\u0026#39;: CT, \u0026#39;CDT\u0026#39;: CT, \u0026#39;EST\u0026#39;: ET, \u0026#39;EDT\u0026#39;: ET, \u0026#39;MST\u0026#39;: MT, \u0026#39;MDT\u0026#39;: MT, \u0026#39;PST\u0026#39;: PT, \u0026#39;PDT\u0026#39;: PT} dt_est = parse(\u0026#39;2018-1-2 04:00:00 EST\u0026#39;, tzinfos=us_tzinfos) dt_pst = parse(\u0026#39;2019-3-11 16:00:00 PST\u0026#39;, tzinfos=us_tzinfos) print (dt_est) print (dt_pst) Output: # 2018-01-02 04:00:00-05:00 # 2019-03-11 16:00:00-07:00 Parsing an arbitrary ISO 8601 timestamp with minimal libraries: Python has only limited support for parsing ISO 8601 timestamps and for strptime you need to know exactly what format it is in. The stringification of a datetime is an ISO 8601 timestamp, with space as a separator and 6 digit fraction:\nimport datetime print (str(datetime.datetime(2019, 7, 22, 9, 25, 59, 555555))) Output: # 2019-07-22 09:25:59.555555 but if the fraction is 0, no fractional part is output\nimport datetime print(str(datetime.datetime(2019, 7, 22, 9, 25, 59, 0))) Output: # 2019-07-22 09:25:59.555555 Parsing a string into a timezone aware datetime object: Python 3.2+ has support for %z format when parsing a string into a datetime object.\nUTC offset in the form +HHMM or -HHMM (empty string if the object is naive).\nimport datetime dt = datetime.datetime.strptime(\u0026#34;2019-04-15T08:27:18-0500\u0026#34;, \u0026#34;%Y-%m-%dT%H:%M:%S%z\u0026#34;) print(dt) Output: # 2019-04-15 08:27:18-05:00 Fixed Offset Time Zones\nfrom datetime import datetime, timedelta, timezone JST = timezone(timedelta(hours=+9)) dt = datetime(2019, 1, 1, 12, 0, 0, tzinfo=JST) print(dt) # 2019-01-01 12:00:00+09:00 print(dt.tzname()) # UTC+09:00 dt = datetime(2019, 1, 1, 12, 0, 0, tzinfo=timezone(timedelta(hours=9), \u0026#39;JST\u0026#39;)) print(dt.tzname) # \u0026#39;JST\u0026#39; Output: # 2019-01-01 12:00:00+09:00 # UTC+09:00 # \u0026lt;built-in method tzname of datetime.datetime object at 0x7f91a9437360\u0026gt; Zones with daylight savings time using third party library: Use the tz.gettz() method to get a time zone object, which can then be passed directly to the datetime constructor:\nfrom datetime import datetime from dateutil import tz local = tz.gettz() # Local time PT = tz.gettz(\u0026#39;US/Pacific\u0026#39;) # Pacific time dt_l = datetime(2019, 1, 1, 12, tzinfo=local) # I am in EST dt_pst = datetime(2019, 1, 1, 12, tzinfo=PT) dt_pdt = datetime(2019, 7, 1, 12, tzinfo=PT) # DST is handled automatically print(dt_l) # 2019-01-01 12:00:00-05:00 print(dt_pst) # 2019-01-01 12:00:00-08:00 print(dt_pdt) # 2019-07-01 12:00:00-07:00 Output: # 2019-01-01 12:00:00+00:00 # 2019-01-01 12:00:00-08:00 # 2019-07-01 12:00:00-07:00 List of the Date format codes:    Directive Meaning Example Notes     %a Weekday as locale’s abbreviated name. Sun, Mon, …, Sat (en_US); So, Mo, …, Sa (de_DE) (1)   %A Weekday as locale’s full name. Sunday, Monday, …, Saturday (en_US); Sonntag, Montag, …, Samstag (de_DE) (1)   %w Weekday as a decimal number, where 0 is Sunday and 6 is Saturday. 0, 1, …, 6    %d Day of the month as a zero-padded decimal number. 01, 02, …, 31 (9)   %b Month as locale’s abbreviated name. Jan, Feb, …, Dec (en_US); Jan, Feb, …, Dez (de_DE) (1)   %B Month as locale’s full name. January, February, …, December (en_US); Januar, Februar, …, Dezember (de_DE) (1)   %m Month as a zero-padded decimal number. 01, 02, …, 12 (9)   %y Year without century as a zero-padded decimal number. 00, 01, …, 99 (9)   %Y Year with century as a decimal number. 0001, 0002, …, 2013, 2014, …, 9998, 9999 (2)   %H Hour (24-hour clock) as a zero-padded decimal number. 00, 01, …, 23 (9)   %I Hour (12-hour clock) as a zero-padded decimal number. 01, 02, …, 12 (9)   %p Locale’s equivalent of either AM or PM. AM, PM (en_US); am, pm (de_DE) (1), (3)   %M Minute as a zero-padded decimal number. 00, 01, …, 59 (9)   %S Second as a zero-padded decimal number. 00, 01, …, 59 (4), (9)   %f Microsecond as a decimal number, zero-padded on the left. 000000, 000001, …, 999999 (5)   %z UTC offset in the form ±HHMM[SS[.ffffff]] (empty string if the object is naive). (empty), +0000, -0400, +1030, +063415, -030712.345216 (6)   %Z Time zone name (empty string if the object is naive). (empty), UTC, EST, CST    %j Day of the year as a zero-padded decimal number. 001, 002, …, 366 (9)   %U Week number of the year (Sunday as the first day of the week) as a zero padded decimal number. All days in a new year preceding the first Sunday are considered to be in week 0. 00, 01, …, 53 (7), (9)   %W Week number of the year (Monday as the first day of the week) as a decimal number. All days in a new year preceding the first Monday are considered to be in week 0. 00, 01, …, 53 (7), (9)   %c Locale’s appropriate date and time representation. Tue Aug 16 21:30:00 1988 (en_US); Di 16 Aug 21:30:00 1988 (de_DE) (1)   %x Locale’s appropriate date representation. 08/16/88 (None); 08/16/1988 (en_US); 16.08.1988 (de_DE) (1)   %X Locale’s appropriate time representation. 21:30:00 (en_US); 21:30:00 (de_DE) (1)   %% A literal \u0026lsquo;%\u0026rsquo; character. %       Python: Tips of the Day Python: Merge dictionaries\ndict1 = { \u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2 } dict2 = { \u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4 } dict3 = { \u0026#39;c\u0026#39;: 5, \u0026#39;d\u0026#39;: 6 } merged = { **dict1, **dict2, **dict3 } print (merged) Output: # {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 5, \u0026#39;d\u0026#39;: 6}  Inviting useful, relevant, well-written and unique guest posts\n  New Content published on w3resource : Python Numpy exercises Python GeoPy Package exercises Python Pandas exercises Python nltk exercises Python BeautifulSoup exercises Form Template Composer - PHP Package Manager PHPUnit - PHP Testing Laravel - PHP Framework Angular - JavaScript Framework React - JavaScript Library Vue - JavaScript Framework Jest - JavaScript Testing Framework   Source : .\n  Time intervals A Python program can handle date and time in several ways. Converting between date formats is a common chore for computers. Python\u0026rsquo;s time and calendar modules help track dates and times.\nWhat is Tick? Time intervals are floating-point numbers in units of seconds. Particular instants in time are expressed in seconds since 12:00am, January 1, 1970(epoch).\nThere is a popular time module available in Python which provides functions for working with times, and for converting between representations. The function time.time() returns the current system time in ticks since 12:00am, January 1, 1970(epoch).\nExample #!/usr/bin/python  import time; # This is required to include time module.  ticks = time.time() print \u0026#34;Number of ticks since 12:00am, January 1, 1970:\u0026#34;, ticks This would produce a result something as follows −\nNumber of ticks since 12:00am, January 1, 1970: 7186862.73399 Date arithmetic is easy to do with ticks. However, dates before the epoch cannot be represented in this form. Dates in the far future also cannot be represented this way - the cutoff point is sometime in 2038 for UNIX and Windows.\nWhat is TimeTuple? Many of Python\u0026rsquo;s time functions handle time as a tuple of 9 numbers, as shown below −\n   Index Field Values     0 4-digit year 2008   1 Month 1 to 12   2 Day 1 to 31   3 Hour 0 to 23   4 Minute 0 to 59   5 Second 0 to 61 (60 or 61 are leap-seconds)   6 Day of Week 0 to 6 (0 is Monday)   7 Day of year 1 to 366 (Julian day)   8 Daylight savings -1, 0, 1, -1 means library determines DST    The above tuple is equivalent to struct_time structure. This structure has following attributes −\n   Index Attributes Values     0 tm_year 2008   1 tm_mon 1 to 12   2 tm_mday 1 to 31   3 tm_hour 0 to 23   4 tm_min 0 to 59   5 tm_sec 0 to 61 (60 or 61 are leap-seconds)   6 tm_wday 0 to 6 (0 is Monday)   7 tm_yday 1 to 366 (Julian day)   8 tm_isdst -1, 0, 1, -1 means library determines DST    Getting current time To translate a time instant from a seconds since the epoch floating-point value into a time-tuple, pass the floating-point value to a function (e.g., localtime) that returns a time-tuple with all nine items valid.\n#!/usr/bin/python  import time; localtime = time.localtime(time.time()) print \u0026#34;Local current time :\u0026#34;, localtime This would produce the following result, which could be formatted in any other presentable form −\nLocal current time : time.struct_time(tm_year=2013, tm_mon=7, tm_mday=17, tm_hour=21, tm_min=26, tm_sec=3, tm_wday=2, tm_yday=198, tm_isdst=0) Getting formatted time You can format any time as per your requirement, but simple method to get time in readable format is asctime() −\n#!/usr/bin/python  import time; localtime = time.asctime( time.localtime(time.time()) ) print \u0026#34;Local current time :\u0026#34;, localtime This would produce the following result −\nLocal current time : Tue Jan 13 10:17:09 2009 Getting calendar for a month The calendar module gives a wide range of methods to play with yearly and monthly calendars. Here, we print a calendar for a given month ( Jan 2008 ) −\n#!/usr/bin/python import calendar cal = calendar.month(2008, 1) print \u0026#34;Here is the calendar:\u0026#34; print cal This would produce the following result −\nHere is the calendar: January 2008 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 The time Module There is a popular time module available in Python which provides functions for working with times and for converting between representations. Here is the list of all available methods −\n   Sr.No. Function with Description     1 time.altzone The offset of the local DST timezone, in seconds west of UTC, if one is defined. This is negative if the local DST timezone is east of UTC (as in Western Europe, including the UK). Only use this if daylight is nonzero.   2 time.asctime([tupletime]) Accepts a time-tuple and returns a readable 24-character string such as \u0026lsquo;Tue Dec 11 18:07:14 2008\u0026rsquo;.   3 time.clock( ) Returns the current CPU time as a floating-point number of seconds. To measure computational costs of different approaches, the value of time.clock is more useful than that of time.time().   4 time.ctime([secs]) Like asctime(localtime(secs)) and without arguments is like asctime( )   5 time.gmtime([secs]) Accepts an instant expressed in seconds since the epoch and returns a time-tuple t with the UTC time. Note : t.tm_isdst is always 0   6 time.localtime([secs]) Accepts an instant expressed in seconds since the epoch and returns a time-tuple t with the local time (t.tm_isdst is 0 or 1, depending on whether DST applies to instant secs by local rules).   7 time.mktime(tupletime) Accepts an instant expressed as a time-tuple in local time and returns a floating-point value with the instant expressed in seconds since the epoch.   8 time.sleep(secs) Suspends the calling thread for secs seconds.   9 time.strftime(fmt[,tupletime]) Accepts an instant expressed as a time-tuple in local time and returns a string representing the instant as specified by string fmt.   10 time.strptime(str,fmt=\u0026rsquo;%a %b %d %H:%M:%S %Y\u0026rsquo;) Parses str according to format string fmt and returns the instant in time-tuple format.   11 time.time( ) Returns the current time instant, a floating-point number of seconds since the epoch.   12 time.tzset() Resets the time conversion rules used by the library routines. The environment variable TZ specifies how this is done.    Let us go through the functions briefly −\nThere are following two important attributes available with time module −\n   Sr.No. Attribute with Description     1 time.timezone Attribute time.timezone is the offset in seconds of the local time zone (without DST) from UTC (\u0026gt;0 in the Americas; \u0026lt;=0 in most of Europe, Asia, Africa).   2 time.tzname Attribute time.tzname is a pair of locale-dependent strings, which are the names of the local time zone without and with DST, respectively.    The calendar Module The calendar module supplies calendar-related functions, including functions to print a text calendar for a given month or year.\nBy default, calendar takes Monday as the first day of the week and Sunday as the last one. To change this, call calendar.setfirstweekday() function.\nHere is a list of functions available with the calendar module −\n   Sr.No. Function with Description     1 calendar.calendar(year,w=2,l=1,c=6) Returns a multiline string with a calendar for year year formatted into three columns separated by c spaces. w is the width in characters of each date; each line has length 21w+18+2c. l is the number of lines for each week.   2 calendar.firstweekday( ) Returns the current setting for the weekday that starts each week. By default, when calendar is first imported, this is 0, meaning Monday.   3 calendar.isleap(year) Returns True if year is a leap year; otherwise, False.   4 calendar.leapdays(y1,y2) Returns the total number of leap days in the years within range(y1,y2).   5 calendar.month(year,month,w=2,l=1) Returns a multiline string with a calendar for month month of year year, one line per week plus two header lines. w is the width in characters of each date; each line has length 7*w+6. l is the number of lines for each week.   6 calendar.monthcalendar(year,month) Returns a list of lists of ints. Each sublist denotes a week. Days outside month month of year year are set to 0; days within the month are set to their day-of-month, 1 and up.   7 calendar.monthrange(year,month) Returns two integers. The first one is the code of the weekday for the first day of the month month in year year; the second one is the number of days in the month. Weekday codes are 0 (Monday) to 6 (Sunday); month numbers are 1 to 12.   8 calendar.prcal(year,w=2,l=1,c=6) Like print calendar.calendar(year,w,l,c).   9 calendar.prmonth(year,month,w=2,l=1) Like print calendar.month(year,month,w,l).   10 calendar.setfirstweekday(weekday) Sets the first day of each week to weekday code weekday. Weekday codes are 0 (Monday) to 6 (Sunday).   11 calendar.timegm(tupletime) The inverse of time.gmtime: accepts a time instant in time-tuple form and returns the same instant as a floating-point number of seconds since the epoch.   12 calendar.weekday(year,month,day) Returns the weekday code for the given date. Weekday codes are 0 (Monday) to 6 (Sunday); month numbers are 1 (January) to 12 (December).    Other Modules \u0026amp; Functions If you are interested, then here you would find a list of other important modules and functions to play with date \u0026amp; time in Python −\n  The datetime Module\n  The pytz Module\n  The dateutil Module\n   Source : .\n  Source : .\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/tutorial-geeksforgeeks/selection/extracting-rows-using-loc/",
	"title": "Extracting rows using .loc[]",
	"tags": [],
	"description": "",
	"content": "Pandas Extracting rows using .loc[]\nPython is a great language for doing data analysis, primarily because of the fantastic ecosystem of data-centric Python packages. Pandas is one of those packages and makes importing and analyzing data much easier.\nPandas provide a unique method to retrieve rows from a Data frame. DataFrame.loc[] method is a method that takes only index labels and returns row or dataframe if the index label exists in the caller data frame.\n Syntax: pandas.DataFrame.loc[]\nParameters:\nIndex label: String or list of string of index label of rows\nReturn type: Data frame or Series depending on parameters\n To download the CSV used in code, click here.\nExample #1: Extracting single Row\nIn this example, Name column is made as the index column and then two single rows are extracted one by one in the form of series using index label of rows.\n# importing pandas package  import pandas as pd # making data frame from csv file  data = pd.read_csv(\u0026#34;nba.csv\u0026#34;, index_col =\u0026#34;Name\u0026#34;) # retrieving row by loc method  first = data.loc[\u0026#34;Avery Bradley\u0026#34;] second = data.loc[\u0026#34;R.J. Hunter\u0026#34;] print(first, \u0026#34;\\n\\n\\n\u0026#34;, second) Output:\nAs shown in the output image, two series were returned since there was only one parameter both of the times.\nExample #2: Multiple parameters\nIn this example, Name column is made as the index column and then two single rows are extracted at the same time by passing a list as parameter.\n# importing pandas package  import pandas as pd # making data frame from csv file  data = pd.read_csv(\u0026#34;nba.csv\u0026#34;, index_col =\u0026#34;Name\u0026#34;) # retrieving rows by loc method  rows = data.loc[[\u0026#34;Avery Bradley\u0026#34;, \u0026#34;R.J. Hunter\u0026#34;]] # checking data type of rows  print(type(rows)) # display  rows Output:\nAs shown in the output image, this time the data type of returned value is a data frame. Both of the rows were extracted and displayed like a new data frame.\nExample #3: Extracting multiple rows with same index\nIn this example, Team name is made as the index column and one team name is passed to .loc method to check if all values with same team name have been returned or not.\n# importing pandas package  import pandas as pd # making data frame from csv file  data = pd.read_csv(\u0026#34;nba.csv\u0026#34;, index_col =\u0026#34;Team\u0026#34;) # retrieving rows by loc method  rows = data.loc[\u0026#34;Utah Jazz\u0026#34;] # checking data type of rows  print(type(rows)) # display  rows Output:\nAs shown in the output image, All rows with team name “Utah Jazz” were returned in the form of a data frame.\nExample #4: Extracting rows between two index labels\nIn this example, two index label of rows are passed and all the rows that fall between those two index label have been returned (Both index labels Inclusive).\n# importing pandas package  import pandas as pd # making data frame from csv file  data = pd.read_csv(\u0026#34;nba.csv\u0026#34;, index_col =\u0026#34;Name\u0026#34;) # retrieving rows by loc method  rows = data.loc[\u0026#34;Avery Bradley\u0026#34;:\u0026#34;Isaiah Thomas\u0026#34;] # checking data type of rows  print(type(rows)) # display  rows Output:\nAs shown in the output image, all the rows that fall between passed two index labels are returned in the form of a data frame.\nRecommended Posts:  Select Rows \u0026amp; Columns by Name or Index in Pandas DataFrame using , loc \u0026amp; iloc Python | Extracting rows using Pandas .iloc[] Python | Pandas Series.loc Python | Pandas DataFrame.loc[] Difference between loc() and iloc() in Pandas DataFrame Python | Delete rows/columns from DataFrame using Pandas.drop() Select first or last N rows in a Dataframe using head() and tail() method in Python-Pandas How to skip rows while reading csv file using Pandas? Concatenate strings from several rows using Pandas groupby Limited rows selection with given column in Pandas | Python How to randomly select rows from Pandas DataFrame How to get rows/index names in Pandas dataframe Get all rows in a Pandas DataFrame containing given substring Different ways to iterate over rows in Pandas Dataframe Selecting rows in pandas DataFrame based on conditions How to iterate over rows in Pandas Dataframe Sorting rows in pandas DataFrame Dealing with Rows and Columns in Pandas DataFrame Iterating over rows and columns in Pandas DataFrame Grouping Rows in pandas   Reference : https://www.geeksforgeeks.org/python-pandas-extracting-rows-using-loc/?ref=lbp\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/advance_topic/generators/",
	"title": "Generators",
	"tags": [],
	"description": "",
	"content": "In this tutorial, you\u0026rsquo;ll learn how to create iterations easily using Python generators, how it is different from iterators and normal functions, and why you should use it.\n Source : https://www.programiz.com/python-programming/generator\n Generators in Python There is a lot of work in building an iterator in Python. We have to implement a class with __iter__() and __next__() method, keep track of internal states, and raise StopIteration when there are no values to be returned.\nGenerators in Python There is a lot of work in building an iterator in Python. We have to implement a class with __iter__() and __next__() method, keep track of internal states, and raise StopIteration when there are no values to be returned.\nThis is both lengthy and counterintuitive. Generator comes to the rescue in such situations.\nPython generators are a simple way of creating iterators. All the work we mentioned above are automatically handled by generators in Python.\nSimply speaking, a generator is a function that returns an object (iterator) which we can iterate over (one value at a time).\n Create Generators in Python It is fairly simple to create a generator in Python. It is as easy as defining a normal function, but with a yield statement instead of a return statement.\nIf a function contains at least one yield statement (it may contain other yield or return statements), it becomes a generator function. Both yield and return will return some value from a function.\nThe difference is that while a return statement terminates a function entirely, yield statement pauses the function saving all its states and later continues from there on successive calls.\n Differences between Generator function and Normal function Here is how a generator function differs from a normal function.\n Generator function contains one or more yield statements. When called, it returns an object (iterator) but does not start execution immediately. Methods like __iter__() and __next__() are implemented automatically. So we can iterate through the items using next(). Once the function yields, the function is paused and the control is transferred to the caller. Local variables and their states are remembered between successive calls. Finally, when the function terminates, StopIteration is raised automatically on further calls.  Here is an example to illustrate all of the points stated above. We have a generator function named my_gen() with several yield statements.\n# A simple generator function def my_gen(): n = 1 print(\u0026#39;This is printed first\u0026#39;) # Generator function contains yield statements yield n n += 1 print(\u0026#39;This is printed second\u0026#39;) yield n n += 1 print(\u0026#39;This is printed at last\u0026#39;) yield n An interactive run in the interpreter is given below. Run these in the Python shell to see the output.\n\u0026gt;\u0026gt;\u0026gt; # It returns an object but does not start execution immediately. \u0026gt;\u0026gt;\u0026gt; a = my_gen() \u0026gt;\u0026gt;\u0026gt; # We can iterate through the items using next(). \u0026gt;\u0026gt;\u0026gt; next(a) This is printed first 1 \u0026gt;\u0026gt;\u0026gt; # Once the function yields, the function is paused and the control is transferred to the caller. \u0026gt;\u0026gt;\u0026gt; # Local variables and theirs states are remembered between successive calls. \u0026gt;\u0026gt;\u0026gt; next(a) This is printed second 2 \u0026gt;\u0026gt;\u0026gt; next(a) This is printed at last 3 \u0026gt;\u0026gt;\u0026gt; # Finally, when the function terminates, StopIteration is raised automatically on further calls. \u0026gt;\u0026gt;\u0026gt; next(a) Traceback (most recent call last): ... StopIteration \u0026gt;\u0026gt;\u0026gt; next(a) Traceback (most recent call last): ... StopIteration One interesting thing to note in the above example is that the value of variable n is remembered between each call.\nUnlike normal functions, the local variables are not destroyed when the function yields. Furthermore, the generator object can be iterated only once.\nTo restart the process we need to create another generator object using something like a = my_gen().\nOne final thing to note is that we can use generators with for loops directly.\nThis is because a for loop takes an iterator and iterates over it using next() function. It automatically ends when StopIteration is raised. Check here to know how a for loop is actually implemented in Python.\n# A simple generator function def my_gen(): n = 1 print(\u0026#39;This is printed first\u0026#39;) # Generator function contains yield statements yield n n += 1 print(\u0026#39;This is printed second\u0026#39;) yield n n += 1 print(\u0026#39;This is printed at last\u0026#39;) yield n # Using for loop for item in my_gen(): print(item) When you run the program, the output will be:\nThis is printed first 1 This is printed second 2 This is printed at last 3  Python Generators with a Loop The above example is of less use and we studied it just to get an idea of what was happening in the background.\nNormally, generator functions are implemented with a loop having a suitable terminating condition.\nLet\u0026rsquo;s take an example of a generator that reverses a string.\ndef rev_str(my_str): length = len(my_str) for i in range(length - 1, -1, -1): yield my_str[i] # For loop to reverse the string for char in rev_str(\u0026#34;hello\u0026#34;): print(char) Output\no l l e h In this example, we have used the range() function to get the index in reverse order using the for loop.\nNote: This generator function not only works with strings, but also with other kinds of iterables like list, tuple, etc.\n Python Generator Expression Simple generators can be easily created on the fly using generator expressions. It makes building generators easy.\nSimilar to the lambda functions which create anonymous functions, generator expressions create anonymous generator functions.\nThe syntax for generator expression is similar to that of a list comprehension in Python. But the square brackets are replaced with round parentheses.\nThe major difference between a list comprehension and a generator expression is that a list comprehension produces the entire list while the generator expression produces one item at a time.\nThey have lazy execution ( producing items only when asked for ). For this reason, a generator expression is much more memory efficient than an equivalent list comprehension.\n# Initialize the list my_list = [1, 3, 6, 10] # square each term using list comprehension list_ = [x**2 for x in my_list] # same thing can be done using a generator expression # generator expressions are surrounded by parenthesis () generator = (x**2 for x in my_list) print(list_) print(generator) Output\n[1, 9, 36, 100] \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x7f5d4eb4bf50\u0026gt; We can see above that the generator expression did not produce the required result immediately. Instead, it returned a generator object, which produces items only on demand.\nHere is how we can start getting items from the generator:\n# Initialize the list my_list = [1, 3, 6, 10] a = (x**2 for x in my_list) print(next(a)) print(next(a)) print(next(a)) print(next(a)) next(a) When we run the above program, we get the following output:\n1 9 36 100 Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 15, in \u0026lt;module\u0026gt; StopIteration Generator expressions can be used as function arguments. When used in such a way, the round parentheses can be dropped.\n\u0026gt;\u0026gt;\u0026gt; sum(x**2 for x in my_list) 146 \u0026gt;\u0026gt;\u0026gt; max(x**2 for x in my_list) 100  Use of Python Generators There are several reasons that make generators a powerful implementation.\n1. Easy to Implement Generators can be implemented in a clear and concise way as compared to their iterator class counterpart. Following is an example to implement a sequence of power of 2 using an iterator class.\nclass PowTwo: def __init__(self, max=0): self.n = 0 self.max = max def __iter__(self): return self def __next__(self): if self.n \u0026gt; self.max: raise StopIteration result = 2 ** self.n self.n += 1 return result The above program was lengthy and confusing. Now, let\u0026rsquo;s do the same using a generator function.\ndef PowTwoGen(max=0): n = 0 while n \u0026lt; max: yield 2 ** n n += 1 Since generators keep track of details automatically, the implementation was concise and much cleaner.\n2. Memory Efficient A normal function to return a sequence will create the entire sequence in memory before returning the result. This is an overkill, if the number of items in the sequence is very large.\nGenerator implementation of such sequences is memory friendly and is preferred since it only produces one item at a time.\n3. Represent Infinite Stream Generators are excellent mediums to represent an infinite stream of data. Infinite streams cannot be stored in memory, and since generators produce only one item at a time, they can represent an infinite stream of data.\nThe following generator function can generate all the even numbers (at least in theory).\ndef all_even(): n = 0 while True: yield n n += 2 4. Pipelining Generators Multiple generators can be used to pipeline a series of operations. This is best illustrated using an example.\nSuppose we have a generator that produces the numbers in the Fibonacci series. And we have another generator for squaring numbers.\nIf we want to find out the sum of squares of numbers in the Fibonacci series, we can do it in the following way by pipelining the output of generator functions together.\ndef fibonacci_numbers(nums): x, y = 0, 1 for _ in range(nums): x, y = y, x+y yield x def square(nums): for num in nums: yield num**2 print(sum(square(fibonacci_numbers(10)))) Output\n4895 This pipelining is efficient and easy to read (and yes, a lot cooler!).\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/list/",
	"title": "List",
	"tags": [],
	"description": "Python List",
	"content": " Last update on February 28 2020 12:07:32 (UTC/GMT +8 hours)\n List A list is a container which holds comma-separated values (items or elements) between square brackets where items or elements need not all have the same type.\nIn general, we can define a list as an object that contains multiple data items (elements). The contents of a list can be changed during program execution. The size of a list can also change during execution, as elements are added or removed from it.\nNote: There are much programming languages which allow us to create arrays, which are objects similar to lists. Lists serve the same purpose as arrays and have many more built-in capabilities. Traditional arrays can not be created in Python.\nExamples of lists:\n numbers = [10, 20, 30, 40, 50] names = [\u0026ldquo;Sara\u0026rdquo;, \u0026ldquo;David\u0026rdquo;, \u0026ldquo;Warner\u0026rdquo;, \u0026ldquo;Sandy\u0026rdquo;] student_info = [\u0026ldquo;Sara\u0026rdquo;, 1, \u0026ldquo;Chemistry\u0026rdquo;]  Contents:\n List commands Create a Python list List indices Add an item to the end of the list Insert an item at a given position Modify an element by using the index of the element Remove an item from the list Remove all items from the list Slice Elements from a List Remove the item at the given position in the list, and return it Return the index in the list of the first item whose value is x Return the number of times \u0026lsquo;x\u0026rsquo; appear in the list Sort the items of the list in place Reverse the elements of the list in place Return a shallow copy of the list Search the Lists and find elements Lists are mutable Convert a list to a tuple in python How to use the double colon [ : : ]? Find largest and the smallest items in a list Compare two lists in Python? Nested lists in Python How can I get the index of an element contained in the list? Using Lists as Stacks Using Lists as Queues Python Code Editor Python List Exercises  Lists: Commands\n\u0026lt;list\u0026gt; = \u0026lt;list\u0026gt;[from_inclusive : to_exclusive : ±step_size] \u0026lt;list\u0026gt;.append(\u0026lt;el\u0026gt;) # Or: \u0026lt;list\u0026gt; += [\u0026lt;el\u0026gt;] \u0026lt;list\u0026gt;.extend(\u0026lt;collection\u0026gt;) # Or: \u0026lt;list\u0026gt; += \u0026lt;collection\u0026gt;  \u0026lt;list\u0026gt;.sort() \u0026lt;list\u0026gt;.reverse() \u0026lt;list\u0026gt; = sorted(\u0026lt;collection\u0026gt;) \u0026lt;iter\u0026gt; = reversed(\u0026lt;list\u0026gt;) sum_of_elements = sum(\u0026lt;collection\u0026gt;) elementwise_sum = [sum(pair) for pair in zip(list_a, list_b)] sorted_by_second = sorted(\u0026lt;collection\u0026gt;, key=lambda el: el[1]) sorted_by_both = sorted(\u0026lt;collection\u0026gt;, key=lambda el: (el[1], el[0])) flatter_list = list(itertools.chain.from_iterable(\u0026lt;list\u0026gt;)) product_of_elems = functools.reduce(lambda out, x: out * x, \u0026lt;collection\u0026gt;) list_of_chars = list(\u0026lt;str\u0026gt;) # Returns number of occurrences. Also works on strings. \u0026lt;int\u0026gt; = \u0026lt;list\u0026gt;.count(\u0026lt;el\u0026gt;) # Returns index of first occurrence or raises ValueError. index = \u0026lt;list\u0026gt;.index(\u0026lt;el\u0026gt;) # Inserts item at index and moves the rest to the right. \u0026lt;list\u0026gt;.insert(index, \u0026lt;el\u0026gt;) # Removes and returns item at index or from the end.  \u0026lt;el\u0026gt; = \u0026lt;list\u0026gt;.pop([index]) # Removes first occurrence of item or raises ValueError.  \u0026lt;list\u0026gt;.remove(\u0026lt;el\u0026gt;) # Removes all items. Also works on dictionary and set.  \u0026lt;list\u0026gt;.clear() Create a Python list Following list contains all integer values:\nmy_list1 = [5, 12, 13, 14] # the list contains all integer values print(my_list1) [5, 12, 13, 14] Following list contains all string:\nmy_list2 = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;black\u0026#39;, \u0026#39;white\u0026#39;] # the list contains all string # values print(my_list2) [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;black\u0026#39;, \u0026#39;white\u0026#39;] Following list contains a string, an integer and a float values:\nmy_list3 = [\u0026#39;red\u0026#39;, 12, 112.12] # the list contains a string, an integer and # a float values print(my_list3) # [\u0026#39;red\u0026#39;, 12, 112.12] A list without any element is called an empty list. See the following statements.\nmy_list=[] print(my_list) # [] Use + operator to create a new list that is a concatenation of two lists and use * operator to repeat a list. See the following statements.\ncolor_list1 = [\u0026#34;White\u0026#34;, \u0026#34;Yellow\u0026#34;] color_list2 = [\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;] color_list3 = [\u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] color_list = color_list1 + color_list2 + color_list3 print(color_list) # [\u0026#39;White\u0026#39;, \u0026#39;Yellow\u0026#39;, \u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] number = [1,2,3] print(number[0]*4) # 4 print(number*4) # [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] List indices List indices work the same way as string indices, list indices start at 0. If an index has a positive value it counts from the beginning and similarly it counts backward if the index has a negative value. As positive integers are used to index from the left end and negative integers are used to index from the right end, so every item of a list gives two alternatives indices. Let create a list called color_list with four items.\ncolor_list=[\u0026#34;RED\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;]    Item RED Blue Green Black     Index (from left) 0 1 2 3   Index (from right) -4 -3 -2 -1    If you give any index value which is out of range then interpreter creates an error message. See the following statements.\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] # The list have four elements # indices start at 0 and end at 3 color_list[0] # Return the First Element # \u0026#39;Red\u0026#39; print(color_list[0],color_list[3]) # Print First and Last Elements # Red Black color_list[-1] # Return Last Element # \u0026#39;Black\u0026#39; print(color_list[4]) # Creates Error as the indices is out of range # Traceback (most recent call last): # File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; # IndexError: list index out of range Add an item to the end of the list See the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.append(\u0026#34;Yellow\u0026#34;) print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;Yellow\u0026#39;] Insert an item at a given position See the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.insert(2, \u0026#34;White\u0026#34;) #Insert an item at third position print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;White\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] Modify an element by using the index of the element See the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list[2]=\u0026#34;Yellow\u0026#34; #Change the third color print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Yellow\u0026#39;, \u0026#39;Black\u0026#39;] Remove an item from the list See the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.remove(\u0026#34;Black\u0026#34;) print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;] Remove all items from the list See the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.clear() print(color_list) # [] List Slices Lists can be sliced like strings and other sequences.\nSyntax:\nsliced_list = List_Name[startIndex:endIndex]\nThis refers to the items of a list starting at index startIndex and stopping just before index endIndex. The default values for list are 0 (startIndex) and the end (endIndex) of the list. If you omit both indices, the slice makes a copy of the original list.\nCut first two items from a list:\nSee the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] # The list have four elements  # indices start at 0 and end at 3 print(color_list[0:2]) # cut first two items # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;] Cut second item from a list:\nSee the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] # The list have four elements  # indices start at 0 and end at 3 print(color_list[1:2]) # [\u0026#39;Blue\u0026#39;] print(color_list[1:-2]) # [\u0026#39;Blue\u0026#39;] Cut second and third elements from a list:\nSee the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] # The list have four elements  # indices start at 0 and end at 3 print(color_list[1:-1]) # [\u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;] Cut first three items from a list:\nSee the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] # The list have four elements  # indices start at 0 and end at 3 print(color_list[:3]) # cut first three items # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;] Creates copy of original list:\nSee the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] # The list have four elements  # indices start at 0 and end at 3 print(color_list[:]) # Creates copy of original list # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] Remove the item at the given position in the list, and return it See the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.pop(2) # Remove second item and return it # \u0026#39;Green\u0026#39; print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Black\u0026#39;] Return the index in the list of the first item whose value is x See the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.index(\u0026#34;Red\u0026#34;) # 0 color_list.index(\u0026#34;Black\u0026#34;) # 3 Return the number of times \u0026lsquo;x\u0026rsquo; appear in the list See the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;, \u0026#34;Blue\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;Blue\u0026#39;] color_list.count(\u0026#34;Blue\u0026#34;) # 2 Sort the items of the list in place See the following statements:\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.sort(key=None, reverse=False) print(color_list) # [\u0026#39;Black\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Red\u0026#39;] Reverse the elements of the list in place color_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] # \u0026gt;\u0026gt; color_list.reverse() print(color_list) # [\u0026#39;Black\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Red\u0026#39;] Return a shallow copy of the list color_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.copy() # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] Search the Lists and find Elements color_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.index(\u0026#34;Green\u0026#34;) # 2 Lists are Mutable Items in the list are mutable i.e. after creating a list you can change any item in the list. See the following statements.\ncolor_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list[0]) # Red color_list[0]=\u0026#34;White\u0026#34; # Change the value of first item \u0026#34;Red\u0026#34; to \u0026#34;White\u0026#34; print(color_list) # [\u0026#39;White\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] print(color_list[0]) # White Convert a list to a tuple in Python listx = [1, 2, 3, 4] print(listx) # [1, 2, 3, 4]  tuplex = tuple(listx) print(tuplex) # (1, 2, 3, 4)  How to use the double colon [ : : ]? listx=[1, 5, 7, 3, 2, 4, 6] print(listx) # [1, 5, 7, 3, 2, 4, 6] sublist=listx[2:7:2] #list[start:stop:step], #step specify an increment # between the elements to cut of the list. print(sublist) # [7, 2, 6] sublist=listx[::3] #returns a list with a jump every 2 times. print(sublist) # [1, 3, 6] sublist=listx[6:2:-2] #when step is negative the jump is made back print(sublist) # [6, 2] Find the largest and the smallest item in a list listx=[5, 10, 3, 25, 7, 4, 15] print(listx) # [5, 10, 3, 25, 7, 4, 15] print(max(listx))\t# the max() function of built-in allows to know the highest value in the list. # 25 print(min(listx)) #the min() function of built-in allows to know the lowest value in the list. # 3 Compare two lists in Python listx1, listx2=[3, 5, 7, 9], [3, 5, 7, 9] print (listx1 == listx2) # True listx1, listx2=[9, 7, 5, 3], [3, 5, 7, 9]\t#create two lists equal, but unsorted. print(listx1 == listx2) # False listx1, listx2 =[2, 3, 5, 7], [3, 5, 7, 9]\t#create two different list print(listx1 == listx2) # False print(listx1.sort() == listx2.sort())\t#order and compare # True Nested lists in Python listx = [[\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;], [0, 1, 2, 3, 4, 5]] print(listx) # [[\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;], [0, 1, 2, 3, 4, 5]] listx = [[\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;], [0, 1, 2, 3, 3, 5]] print(listx) # [[\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;], [0, 1, 2, 3, 3, 5]] print(listx[0][1])\t#The first [] indicates the index of the outer list. # World print(listx[1][3])\t#the second [] indicates the index nested lists. # 3 listx.append([True, False])\t#add new items print(listx) # [[\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;], [0, 1, 2, 3, 3, 5], [True, False]]\t listx[1][2]=4 print(listx) # [[\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;], [0, 1, 4, 3, 3, 5], [True, False]]\t#update value items How can I get the index of an element contained in the list? listy = list(\u0026#34;HELLO WORLD\u0026#34;) print(listy) # [\u0026#39;H\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;D\u0026#39;] index = listy.index(\u0026#34;L\u0026#34;)\t#get index of the first item whose value is passed as parameter print(index) # 2 index = listy.index(\u0026#34;L\u0026#34;, 4)\t#define the index from which you want to search print(index) # 9 index = listy.index(\u0026#34;O\u0026#34;, 3, 5)\t#define the segment of the list to be searched print(index) # 4 Using Lists as Stacks color_list=[\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;] print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;] color_list.append(\u0026#34;White\u0026#34;) color_list.append(\u0026#34;Yellow\u0026#34;) print(color_list) # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;White\u0026#39;, \u0026#39;Yellow\u0026#39;] color_list.pop() # \u0026#39;Yellow\u0026#39; color_list.pop() # \u0026#39;White\u0026#39; color_list.pop() # Black\u0026#39; color_list # [\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;] Using Lists as Queues from collections import deque color_list = deque([\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Black\u0026#34;]) color_list.append(\u0026#34;White\u0026#34;) # White arrive print(color_list) # deque([\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;White\u0026#39;]) color_list.append(\u0026#34;Yellow\u0026#34;) # Yellow arrive print(color_list) # deque([\u0026#39;Red\u0026#39;, \u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;White\u0026#39;, \u0026#39;Yellow\u0026#39;]) color_list.popleft() # The first to arrive now leaves # \u0026#39;Red\u0026#39; print(color_list) # deque([\u0026#39;Blue\u0026#39;, \u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;White\u0026#39;, \u0026#39;Yellow\u0026#39;]) color_list.popleft() # The second to arrive now leaves # \u0026#39;Blue\u0026#39; print(color_list) # deque([\u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;White\u0026#39;, \u0026#39;Yellow\u0026#39;]) print(color_list) # Remaining queue in order of arrival # deque([\u0026#39;Green\u0026#39;, \u0026#39;Black\u0026#39;, \u0026#39;White\u0026#39;, \u0026#39;Yellow\u0026#39;])  Source : .\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/dictionary/merge-two-dictionaries/",
	"title": "Merge two Dictionaries",
	"tags": [],
	"description": "",
	"content": "How to Merge Two Dictionaries in Python: Dictionary Comprehensions and Unpacking POSTED ON JUNE 7, 2019 BY JEREMY GRIFSKI\nWhen I’m trying to find a topic for this series, I either decide to write about something I just learned, or I choose to write about something I found from the list of top Python questions on Stack Overflow. Today, I’m hitting both by covering how to merge two dictionaries in Python.\nTable of Contents  Table of Contents Problem Introduction Solutions  Merge Two Dictionaries with Brute Force Merge Two Dictionaries with a Dictionary Comprehension Merge Two Dictionaries with Copy and Update Merge Two Dictionaries with Dictionary Unpacking   Performance A Little Recap  Problem Introduction Earlier in this series, I covered a similar problem where I wanted to convert two lists into a dictionary. In that article, I covered various methods for mapping one list onto the other. This time around I want to convert two dictionaries into a single dictionary like so:\n1. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;} 2. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;} 4. # Insert merge code here 6. powers = { 7. \u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;, 8. \u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34; 9. } Here, we have two dictionaries: yusuke_power and hiei_power. Each dictionary maps a YuYu Hakasho character to one of their abilities. In this case, I chose Yusuke and his Spirit Gun as well as Hiei and his Jagan Eye. Ultimately, we want to be able to merge these dictionaries, so we have a collection of characters and their powers. Let’s see if we can accomplish that below.\nSolutions As always, I like to list off a few possible ways to solve the problem. To start, we’ll try a brute force solution, then we’ll dig into some more sophisticated solutions.\nMerge Two Dictionaries with Brute Force As is tradition in this series, I always like to kick things off with a roll-your-own solution. In this case, we’re looking to iterate over one dictionary and add its items to the other dictionary:\n1. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;} 2. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;} 4. for key, value in hiei_power.items(): 5. yusuke_power[key] = value Naturally, this solution leaves a lot to be desired, but it gets the job done. At the end of the day, yusuke_power should look like the powers dictionary we want.\nTo accomplish something closer to what we want, we would have to iterate over both dictionaries separately:\n1. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;} 2. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;} 3. powers = dict() 5. for dictionary in (yusuke_power, hiei_power): 6. for key, value in dictionary.items(): 7. powers[key] = value Unfortunately, this solution doesn’t scale very well. That said, there are better ways to solve this problem.\nMerge Two Dictionaries with a Dictionary Comprehension Since I’m a big fan of comprehensions, I think it’s worth mentioning that the solution above can be written in a single line with a dictionary comprehension:\n1. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;} 2. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;} 4. powers = {key: value for d in (yusuke_power, hiei_power) for key, value in d.items()} Here, we have written a dictionary comprehension that iterates over both dictionaries and copies each item into a new dictionary. Naturally, it works just like the brute force solution.\nMerge Two Dictionaries with Copy and Update As with many of the collections in Python, they have a builtin copy function associated with them. As a result, we can leverage that copy function to generate a new dictionary which includes all the items of the original dictionary. In addition, dictionaries have an update function which can be used to add all the items from one dictionary into another:\n1. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;} 2. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;} 4. powers = yusuke_power.copy() 5. powers.update(hiei_power) With this solution, we’re able to generate that powers dictionary which contains all the items from the original two dictionaries. As an added benefit, copy and update are backwards compatible, so Python 2 users won’t feel left out.\nIt’s worth noting that we can extend this solution to merge any number of dictionaries with a custom function:\n1. def merge_dicts(*dicts: dict): 2. merged_dict = dict() 3. for dictionary in dicts: 4. merge_dict.update(dictionary) 5. return merged_dict Now, we can generate a new dictionary which contains all the items in any number of dictionaries.\nMerge Two Dictionaries with Dictionary Unpacking When Python 3.5 rolled out, it introduced a dictionary unpacking syntax which allows us to merge dictionaries with a new operator:\n1. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;} 2. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;} 4. powers = {**yusuke_power, **hiei_power} Naturally, this solution scales for any number of arguments:\n1. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;} 2. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;} 4. powers = {**yusuke_power, **hiei_power, \u0026#34;Yoko Kurama\u0026#34;: \u0026#34;Rose Whip\u0026#34;} Of course, the drawback is backwards compatibility. If you’re still rocking Python 2 or even older versions of Python 3, this feature may not be available to you. Regardless, I think it’s a pretty clever piece of syntax, and I like how it looks.\nPerformance For the first time in this series, I thought it would be beneficial to take a look at the performance of each of the methods above (if you’re lucky, I might update the old articles to include performance as well). To do that, I’m going to use the builtin timeit library.\nTo use the timeit library, we have to set up some strings for testing:\n1. setup = \u0026#34;\u0026#34;\u0026#34;\\ 2. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;}; 3. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;}; 4. powers = dict() 5. \u0026#34;\u0026#34;\u0026#34; 7. brute_force = \u0026#34;\u0026#34;\u0026#34;\\ 8. for dictionary in (yusuke_power, hiei_power): 9. for key, value in dictionary.items(): 10. powers[key] = value 11. \u0026#34;\u0026#34;\u0026#34; 13. dict_comprehension = \u0026#34;\u0026#34;\u0026#34;\\ 14. powers = {key: value for d in (yusuke_power, hiei_power) for key, value in d.items()} 15. \u0026#34;\u0026#34;\u0026#34; 17. copy_and_update = \u0026#34;\u0026#34;\u0026#34;\\ 18. powers = yusuke_power.copy() 19. powers.update(hiei_power) 20. \u0026#34;\u0026#34;\u0026#34; 22. dict_unpacking = \u0026#34;\u0026#34;\u0026#34;\\ 23. powers = {**yusuke_power, **hiei_power} 24. \u0026#34;\u0026#34;\u0026#34; With our strings setup, we can begin our performance test:\n1. \u0026gt;\u0026gt;\u0026gt; import timeit 2. \u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=brute_force, setup=setup) 3. 1.517404469999974 4. \u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=dict_comprehension, setup=setup) 5. 1.6243454339999062 6. \u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=copy_and_update, setup=setup) 7. 0.7273476979999032 8. \u0026gt;\u0026gt;\u0026gt; timeit.timeit(stmt=dict_unpacking, setup=setup) 9. 0.2897768919999635 As it turns out, dictionary unpacking is very fast. For reference, I performed the testing on a Surface Go with Windows 10 and Python 3.7.1.\nA Little Recap Well, that’s all I have in terms of typical solutions. All that said, be aware that all of these solutions will overwrite duplicate values. In other words, if two dictionaries contain the same key, the last dictionary to be merged will overwrite the previous dictionary’s value.\nAlso, it’s worth noting that all of these solutions perform a shallow copy of the dictionaries. As a result, dictionaries that may be nested or store objects will only have their references copied, not the actual values. If that’s a constraint in your application, you may need to write your own recursive copy function.\nAt any rate, here are all the solutions:\n1. yusuke_power = {\u0026#34;Yusuke Urameshi\u0026#34;: \u0026#34;Spirit Gun\u0026#34;} 2. hiei_power = {\u0026#34;Hiei\u0026#34;: \u0026#34;Jagan Eye\u0026#34;} 3. powers = dict() 5. # Brute force 6. for dictionary in (yusuke_power, hiei_power): 7. for key, value in dictionary.items(): 8. powers[key] = value 10. # Dictionary Comprehension 11. powers = {key: value for d in (yusuke_power, hiei_power) for key, value in d.items()} 13. # Copy and update 14. powers = yusuke_power.copy() 15. powers.update(hiei_power) 17. # Dictionary unpacking (Python 3.5+) 18. powers = {**yusuke_power, **hiei_power} 20. # Backwards compatible function for any number of dicts 21. def merge_dicts(*dicts: dict): 22. merged_dict = dict() 23. for dictionary in dicts: 24. merge_dict.update(dictionary) 25. return merged_dict And, that’s it! As always, I appreciate the support. If you liked this article, do me a favor and share it with someone. For those feeling extra generous, consider becoming a member of The Renegade Coder. If you’re not convinced, check out some of these other Python articles:\n Rock Paper Scissors Using Modular Arithmetic How to Write a List Comprehension in Python The Coolest Programming Language Features  Once again, thanks for the support! Before you go, share your recommendation for a topic you’d like to see in the comments.\n Source : .\n   "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/objects_class/class/",
	"title": "Objects and Classes",
	"tags": [],
	"description": "",
	"content": "Python Objects and Classes Python is an object oriented programming language. Unlike procedure oriented programming, where the main emphasis is on functions, object oriented programming stresses on objects.\nAn object is simply a collection of data (variables) and methods (functions) that act on those data. Similarly, a class is a blueprint for that object.\nWe can think of class as a sketch (prototype) of a house. It contains all the details about the floors, doors, windows etc. Based on these descriptions we build the house. House is the object.\nAs many houses can be made from a house\u0026rsquo;s blueprint, we can create many objects from a class. An object is also called an instance of a class and the process of creating this object is called instantiation.\n Defining a Class in Python Like function definitions begin with the def keyword in Python, class definitions begin with a class keyword.\nThe first string inside the class is called docstring and has a brief description about the class. Although not mandatory, this is highly recommended.\nHere is a simple class definition.\nclass MyNewClass: \u0026#39;\u0026#39;\u0026#39;This is a docstring. I have created a new class\u0026#39;\u0026#39;\u0026#39; pass A class creates a new local namespace where all its attributes are defined. Attributes may be data or functions.\nThere are also special attributes in it that begins with double underscores __. For example, __doc__ gives us the docstring of that class.\nAs soon as we define a class, a new class object is created with the same name. This class object allows us to access the different attributes as well as to instantiate new objects of that class.\nclass Person: \u0026#34;This is a person class\u0026#34; age = 10 def greet(self): print(\u0026#39;Hello\u0026#39;) # Output: 10 print(Person.age) # Output: \u0026lt;function Person.greet\u0026gt; print(Person.greet) # Output: \u0026#39;This is my second class\u0026#39; print(Person.__doc__) Output\n10 \u0026lt;function Person.greet at 0x7fc78c6e8160\u0026gt; This is a person class  Creating an Object in Python We saw that the class object could be used to access different attributes.\nIt can also be used to create new object instances (instantiation) of that class. The procedure to create an object is similar to a function call.\nharry = Person() This will create a new object instance named harry. We can access the attributes of objects using the object name prefix.\nAttributes may be data or method. Methods of an object are corresponding functions of that class.\nThis means to say, since Person.greet is a function object (attribute of class), Person.greet will be a method object.\nclass Person: \u0026#34;This is a person class\u0026#34; age = 10 def greet(self): print(\u0026#39;Hello\u0026#39;) # create a new object of Person class harry = Person() # Output: \u0026lt;function Person.greet\u0026gt; print(Person.greet) # Output: \u0026lt;bound method Person.greet of \u0026lt;__main__.Person object\u0026gt;\u0026gt; print(harry.greet) # Calling object\u0026#39;s greet() method # Output: Hello harry.greet() Output\n\u0026lt;function Person.greet at 0x7fd288e4e160\u0026gt; \u0026lt;bound method Person.greet of \u0026lt;__main__.Person object at 0x7fd288e9fa30\u0026gt;\u0026gt; Hello You may have noticed the self parameter in function definition inside the class but we called the method simply as harry.greet() without any arguments. It still worked.\nThis is because, whenever an object calls its method, the object itself is passed as the first argument. So, harry.greet() translates into Person.greet(harry).\nIn general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method\u0026rsquo;s object before the first argument.\nFor these reasons, the first argument of the function in class must be the object itself. This is conventionally called self. It can be named otherwise but we highly recommend to follow the convention.\nNow you must be familiar with class object, instance object, function object, method object and their differences.\n Constructors in Python Class functions that begin with double underscore __ are called special functions as they have special meaning.\nOf one particular interest is the __init__() function. This special function gets called whenever a new object of that class is instantiated.\nThis type of function is also called constructors in Object Oriented Programming (OOP). We normally use it to initialize all the variables.\nclass ComplexNumber: def __init__(self, r=0, i=0): self.real = r self.imag = i def get_data(self): print(f\u0026#39;{self.real}+{self.imag}j\u0026#39;) # Create a new ComplexNumber object num1 = ComplexNumber(2, 3) # Call get_data() method # Output: 2+3j num1.get_data() # Create another ComplexNumber object # and create a new attribute \u0026#39;attr\u0026#39; num2 = ComplexNumber(5) num2.attr = 10 # Output: (5, 0, 10) print((num2.real, num2.imag, num2.attr)) # but c1 object doesn\u0026#39;t have attribute \u0026#39;attr\u0026#39; # AttributeError: \u0026#39;ComplexNumber\u0026#39; object has no attribute \u0026#39;attr\u0026#39; print(num1.attr) Output\n2+3j (5, 0, 10) Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 27, in \u0026lt;module\u0026gt; print(num1.attr) AttributeError: \u0026#39;ComplexNumber\u0026#39; object has no attribute \u0026#39;attr\u0026#39; In the above example, we defined a new class to represent complex numbers. It has two functions, __init__() to initialize the variables (defaults to zero) and get_data() to display the number properly.\nAn interesting thing to note in the above step is that attributes of an object can be created on the fly. We created a new attribute attr for object num2 and read it as well. But this does not create that attribute for object num1.\n Deleting Attributes and Objects Any attribute of an object can be deleted anytime, using the del statement. Try the following on the Python shell to see the output.\nnum1 = ComplexNumber(2,3) del num1.imag num1.get_data() Traceback (most recent call last):\nAttributeError: \u0026lsquo;ComplexNumber\u0026rsquo; object has no attribute \u0026lsquo;imag\u0026rsquo;\ndel ComplexNumber.get_data num1.get_data() Traceback (most recent call last): \u0026hellip; AttributeError: \u0026lsquo;ComplexNumber\u0026rsquo; object has no attribute \u0026lsquo;get_data\u0026rsquo; We can even delete the object itself, using the del statement.\nc1 = ComplexNumber(1,3) del c1 c1 Traceback (most recent call last): \u0026hellip; NameError: name \u0026lsquo;c1\u0026rsquo; is not defined\nActually, it is more complicated than that. When we do c1 = ComplexNumber(1,3), a new instance object is created in memory and the name c1 binds with it.\nOn the command del c1, this binding is removed and the name c1 is deleted from the corresponding namespace. The object however continues to exist in memory and if no other name is bound to it, it is later automatically destroyed.\nThis automatic destruction of unreferenced objects in Python is also called garbage collection.\nDeleting objects in Python removes the name binding\n Source : https://www.programiz.com/python-programming/class\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/",
	"title": "Pandas",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/files/directory/",
	"title": "Python: Directory",
	"tags": [],
	"description": "",
	"content": "In this tutorial you will learn to create, format, modify and delete strings in Python. Also, you will be introduced to various string operations and functions.\nWhat is String in Python? A string is a sequence of characters.\nA character is simply a symbol. For example, the English language has 26 characters.\nComputers do not deal with characters, they deal with numbers (binary). Even though you may see characters on your screen, internally it is stored and manipulated as a combination of 0s and 1s.\nThis conversion of character to a number is called encoding, and the reverse process is decoding. ASCII and Unicode are some of the popular encodings used.\nIn Python, a string is a sequence of Unicode characters. Unicode was introduced to include every character in all languages and bring uniformity in encoding. You can learn about Unicode from Python Unicode.\n How to create a string in Python? Strings can be created by enclosing characters inside a single quote or double-quotes. Even triple quotes can be used in Python but generally used to represent multiline strings and docstrings.\n# defining strings in Python # all of the following are equivalent my_string = \u0026#39;Hello\u0026#39; print(my_string) my_string = \u0026#34;Hello\u0026#34; print(my_string) my_string = \u0026#39;\u0026#39;\u0026#39;Hello\u0026#39;\u0026#39;\u0026#39; print(my_string) # triple quotes string can extend multiple lines my_string = \u0026#34;\u0026#34;\u0026#34;Hello, welcome to the world of Python\u0026#34;\u0026#34;\u0026#34; print(my_string) When you run the program, the output will be:\nHello Hello Hello Hello, welcome to the world of Python  How to access characters in a string? We can access individual characters using indexing and a range of characters using slicing. Index starts from 0. Trying to access a character out of index range will raise an IndexError. The index must be an integer. We can\u0026rsquo;t use floats or other types, this will result into TypeError.\nPython allows negative indexing for its sequences.\nThe index of -1 refers to the last item, -2 to the second last item and so on. We can access a range of items in a string by using the slicing operator :(colon).\n#Accessing string characters in Python str = \u0026#39;programiz\u0026#39; print(\u0026#39;str = \u0026#39;, str) #first character print(\u0026#39;str[0] = \u0026#39;, str[0]) #last character print(\u0026#39;str[-1] = \u0026#39;, str[-1]) #slicing 2nd to 5th character print(\u0026#39;str[1:5] = \u0026#39;, str[1:5]) #slicing 6th to 2nd last character print(\u0026#39;str[5:-2] = \u0026#39;, str[5:-2]) When we run the above program, we get the following output:\nstr = programiz str[0] = p str[-1] = z str[1:5] = rogr str[5:-2] = am If we try to access an index out of the range or use numbers other than an integer, we will get errors.\n# index must be in range my_string[15] ... IndexError: string index out of range # index must be an integer my_string[1.5] ... TypeError: string indices must be integers Slicing can be best visualized by considering the index to be between the elements as shown below.\nIf we want to access a range, we need the index that will slice the portion from the string.\nString Slicing in Python\n How to change or delete a string? Strings are immutable. This means that elements of a string cannot be changed once they have been assigned. We can simply reassign different strings to the same name.\nmy_string = \u0026#39;programiz\u0026#39; my_string[5] = \u0026#39;a\u0026#39; ... TypeError: \u0026#39;str\u0026#39; object does not support item assignment my_string = \u0026#39;Python\u0026#39; my_string \u0026#39;Python\u0026#39; We cannot delete or remove characters from a string. But deleting the string entirely is possible using the del keyword.\ndel my_string[1] ... TypeError: \u0026#39;str\u0026#39; object doesn\u0026#39;t support item deletion del my_string my_string ... NameError: name \u0026#39;my_string\u0026#39; is not defined  Python String Operations There are many operations that can be performed with strings which makes it one of the most used data types in Python.\nTo learn more about the data types available in Python visit: Python Data Types\nConcatenation of Two or More Strings Joining of two or more strings into a single one is called concatenation.\nThe + operator does this in Python. Simply writing two string literals together also concatenates them.\nThe ***** operator can be used to repeat the string for a given number of times.\n# Python String Operations str1 = \u0026#39;Hello\u0026#39; str2 =\u0026#39;World!\u0026#39; # using + print(\u0026#39;str1 + str2 = \u0026#39;, str1 + str2) # using * print(\u0026#39;str1 * 3 =\u0026#39;, str1 * 3) When we run the above program, we get the following output:\nstr1 + str2 = HelloWorld! str1 * 3 = HelloHelloHello Writing two string literals together also concatenates them like + operator.\nIf we want to concatenate strings in different lines, we can use parentheses.\n# two string literals together \u0026#39;Hello \u0026#39;\u0026#39;World!\u0026#39; \u0026#39;Hello World!\u0026#39; # using parentheses s = (\u0026#39;Hello \u0026#39; ... \u0026#39;World\u0026#39;) s \u0026#39;Hello World\u0026#39;  Iterating Through a string We can iterate through a string using a for loop. Here is an example to count the number of \u0026lsquo;l\u0026rsquo;s in a string.\n# Iterating through a string count = 0 for letter in \u0026#39;Hello World\u0026#39;: if(letter == \u0026#39;l\u0026#39;): count += 1 print(count,\u0026#39;letters found\u0026#39;) When we run the above program, we get the following output:\n3 letters found  String Membership Test We can test if a substring exists within a string or not, using the keyword in.\n\u0026#39;a\u0026#39; in \u0026#39;program\u0026#39; True \u0026#39;at\u0026#39; not in \u0026#39;battle\u0026#39; False  Built-in functions to Work with Python Various built-in functions that work with sequence work with strings as well.\nSome of the commonly used ones are enumerate() and len(). The enumerate() function returns an enumerate object. It contains the index and value of all the items in the string as pairs. This can be useful for iteration.\nSimilarly, len() returns the length (number of characters) of the string.\nstr = \u0026#39;cold\u0026#39; # enumerate() list_enumerate = list(enumerate(str)) print(\u0026#39;list(enumerate(str) = \u0026#39;, list_enumerate) #character count print(\u0026#39;len(str) = \u0026#39;, len(str)) When we run the above program, we get the following output:\nlist(enumerate(str) = [(0, \u0026#39;c\u0026#39;), (1, \u0026#39;o\u0026#39;), (2, \u0026#39;l\u0026#39;), (3, \u0026#39;d\u0026#39;)] len(str) = 4  Python String Formatting Escape Sequence If we want to print a text like He said, \u0026ldquo;What\u0026rsquo;s there?\u0026rdquo;, we can neither use single quotes nor double quotes. This will result in a SyntaxError as the text itself contains both single and double quotes.\nprint(\u0026#34;He said, \u0026#34;What\u0026#39;s there?\u0026#34;\u0026#34;) ... SyntaxError: invalid syntax print(\u0026#39;He said, \u0026#34;What\u0026#39;s there?\u0026#34;\u0026#39;) ... SyntaxError: invalid syntax One way to get around this problem is to use triple quotes. Alternatively, we can use escape sequences.\nAn escape sequence starts with a backslash and is interpreted differently. If we use a single quote to represent a string, all the single quotes inside the string must be escaped. Similar is the case with double quotes. Here is how it can be done to represent the above text.\n# using triple quotes print(\u0026#39;\u0026#39;\u0026#39;He said, \u0026#34;What\u0026#39;s there?\u0026#34;\u0026#39;\u0026#39;\u0026#39;) # escaping single quotes print(\u0026#39;He said, \u0026#34;What\\\u0026#39;s there?\u0026#34;\u0026#39;) # escaping double quotes print(\u0026#34;He said, \\\u0026#34;What\u0026#39;s there?\\\u0026#34;\u0026#34;) When we run the above program, we get the following output:\nHe said, \u0026#34;What\u0026#39;s there?\u0026#34; He said, \u0026#34;What\u0026#39;s there?\u0026#34; He said, \u0026#34;What\u0026#39;s there?\u0026#34; Here is a list of all the escape sequences supported by Python.\n   Escape Sequence Description     \\newline Backslash and newline ignored   \\ Backslash   ' Single quote   \u0026quot; Double quote   \\a ASCII Bell   \\b ASCII Backspace   \\f ASCII Formfeed   \\n ASCII Linefeed   \\r ASCII Carriage Return   \\t ASCII Horizontal Tab   \\v ASCII Vertical Tab   \\ooo Character with octal value ooo   \\xHH Character with hexadecimal value HH    Here are some examples\nprint(\u0026#34;C:\\\\Python32\\\\Lib\u0026#34;) # C:\\Python32\\Lib print(\u0026#34;This is printed\\nin two lines\u0026#34;) #This is printed # in two lines print(\u0026#34;This is \\x48\\x45\\x58representation\u0026#34;) # This is HEX representation  Raw String to ignore escape sequence Sometimes we may wish to ignore the escape sequences inside a string. To do this we can place r or R in front of the string. This will imply that it is a raw string and any escape sequence inside it will be ignored.\nprint(\u0026#34;This is \\x61\\ngood example\u0026#34;) This is a good example print(r\u0026#34;This is \\x61 \\ngood example\u0026#34;) This is \\x61 \\ngood example  The format() Method for Formatting Strings The format() method that is available with the string object is very versatile and powerful in formatting strings. Format strings contain curly braces {} as placeholders or replacement fields which get replaced.\nWe can use positional arguments or keyword arguments to specify the order.\n# Python string format() method # default(implicit) order default_order = \u0026#34;{}, {} and {}\u0026#34;.format(\u0026#39;John\u0026#39;,\u0026#39;Bill\u0026#39;,\u0026#39;Sean\u0026#39;) print(\u0026#39;\\n--- Default Order ---\u0026#39;) print(default_order) # order using positional argument positional_order = \u0026#34;{1}, {0} and {2}\u0026#34;.format(\u0026#39;John\u0026#39;,\u0026#39;Bill\u0026#39;,\u0026#39;Sean\u0026#39;) print(\u0026#39;\\n--- Positional Order ---\u0026#39;) print(positional_order) # order using keyword argument keyword_order = \u0026#34;{s}, {b} and {j}\u0026#34;.format(j=\u0026#39;John\u0026#39;,b=\u0026#39;Bill\u0026#39;,s=\u0026#39;Sean\u0026#39;) print(\u0026#39;\\n--- Keyword Order ---\u0026#39;) print(keyword_order) When we run the above program, we get the following output:\n--- Default Order --- John, Bill and Sean --- Positional Order --- Bill, John and Sean --- Keyword Order --- Sean, Bill and John The format() method can have optional format specifications. They are separated from the field name using colon. For example, we can left-justify \u0026lt;, right-justify \u0026gt; or center ^ a string in the given space.\nWe can also format integers as binary, hexadecimal, etc. and floats can be rounded or displayed in the exponent format. There are tons of formatting you can use. Visit here for all the string formatting available with the [format()](https://www.programiz.com/python-programming/methods/string/format) method.\n# formatting integers \u0026#34;Binary representation of {0} is {0:b}\u0026#34;.format(12) \u0026#39;Binary representation of 12 is 1100\u0026#39; # formatting floats \u0026#34;Exponent representation: {0:e}\u0026#34;.format(1566.345) \u0026#39;Exponent representation: 1.566345e+03\u0026#39; # round off \u0026#34;One third is: {0:.3f}\u0026#34;.format(1/3) \u0026#39;One third is: 0.333\u0026#39; # string alignment \u0026#34;|{:\u0026lt;10}|{:^10}|{:\u0026gt;10}|\u0026#34;.format(\u0026#39;butter\u0026#39;,\u0026#39;bread\u0026#39;,\u0026#39;ham\u0026#39;) \u0026#39;|butter | bread | ham|\u0026#39;  Old style formatting We can even format strings like the old sprintf() style used in C programming language. We use the % operator to accomplish this.\nx = 12.3456789 print(\u0026#39;The value of x is %3.2f\u0026#39; %x) The value of x is 12.35 print(\u0026#39;The value of x is %3.4f\u0026#39; %x) The value of x is 12.3457  Common Python String Methods There are numerous methods available with the string object. The format() method that we mentioned above is one of them. Some of the commonly used methods are lower(), upper(), join(), split(), find(), replace() etc. Here is a complete list of all the built-in methods to work with strings in Python.\n\u0026#34;PrOgRaMiZ\u0026#34;.lower() \u0026#39;programiz\u0026#39; \u0026#34;PrOgRaMiZ\u0026#34;.upper() \u0026#39;PROGRAMIZ\u0026#39; \u0026#34;This will split all words into a list\u0026#34;.split() [\u0026#39;This\u0026#39;, \u0026#39;will\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;all\u0026#39;, \u0026#39;words\u0026#39;, \u0026#39;into\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;list\u0026#39;] \u0026#39; \u0026#39;.join([\u0026#39;This\u0026#39;, \u0026#39;will\u0026#39;, \u0026#39;join\u0026#39;, \u0026#39;all\u0026#39;, \u0026#39;words\u0026#39;, \u0026#39;into\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;string\u0026#39;]) \u0026#39;This will join all words into a string\u0026#39; \u0026#39;Happy New Year\u0026#39;.find(\u0026#39;ew\u0026#39;) 7 \u0026#39;Happy New Year\u0026#39;.replace(\u0026#39;Happy\u0026#39;,\u0026#39;Brilliant\u0026#39;) \u0026#39;Brilliant New Year\u0026#39;  Source : https://www.programiz.com/python-programming/string\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/datetime/strftime/",
	"title": "strftime()",
	"tags": [],
	"description": "",
	"content": "In this article, you will learn to convert date, time and datetime objects to its equivalent string (with the help of examples)\nThe strftime() method returns a string representing date and time using date, time or datetime object.\n Example 1: datetime to string using strftime() The program below converts a datetime object containing current date and time to different string formats.\nfrom datetime import datetime now = datetime.now() # current date and time year = now.strftime(\u0026#34;%Y\u0026#34;) print(\u0026#34;year:\u0026#34;, year) month = now.strftime(\u0026#34;%m\u0026#34;) print(\u0026#34;month:\u0026#34;, month) day = now.strftime(\u0026#34;%d\u0026#34;) print(\u0026#34;day:\u0026#34;, day) time = now.strftime(\u0026#34;%H:%M:%S\u0026#34;) print(\u0026#34;time:\u0026#34;, time) date_time = now.strftime(\u0026#34;%m/%d/%Y, %H:%M:%S\u0026#34;) print(\u0026#34;date and time:\u0026#34;,date_time)\tWhen you run the program, the output will something like be:\nyear: 2018 month: 12 day: 24 time: 04:59:31 date and time: 12/24/2018, 04:59:31 Here, year, day, time and date_time are strings, whereas now is a datetime object.\n How strftime() works? In the above program, %Y, %m, %d etc. are format codes. The strftime() method takes one or more format codes as an argument and returns a formatted string based on it.\n  We imported datetime class from the datetime module. It\u0026rsquo;s because the object of datetime class can access strftime() method.\n  The datetime object containing current date and time is stored in now variable.\n  The strftime() method can be used to create formatted strings.\n  The string you pass to the strftime() method may contain more than one format codes.\n   Example 2: Creating string from a timestamp from datetime import datetime timestamp = 1528797322 date_time = datetime.fromtimestamp(timestamp) print(\u0026#34;Date time object:\u0026#34;, date_time) d = date_time.strftime(\u0026#34;%m/%d/%Y, %H:%M:%S\u0026#34;) print(\u0026#34;Output 2:\u0026#34;, d)\td = date_time.strftime(\u0026#34;%d%b, %Y\u0026#34;) print(\u0026#34;Output 3:\u0026#34;, d) d = date_time.strftime(\u0026#34;%d%B, %Y\u0026#34;) print(\u0026#34;Output 4:\u0026#34;, d) d = date_time.strftime(\u0026#34;%I%p\u0026#34;) print(\u0026#34;Output 5:\u0026#34;, d) When you run the program, the output will be:\nDate time object: 2018-06-12 09:55:22 Output 2: 06/12/2018, 09:55:22 Output 3: 12 Jun, 2018 Output 4: 12 June, 2018 Output 5: 09AM  Format Code List The table below shows all the codes that you can pass to the strftime() method.\n   Directive Meaning Example     %a Abbreviated weekday name. Sun, Mon, \u0026hellip;   %A Full weekday name. Sunday, Monday, \u0026hellip;   %w Weekday as a decimal number. 0, 1, \u0026hellip;, 6   %d Day of the month as a zero-padded decimal. 01, 02, \u0026hellip;, 31   %-d Day of the month as a decimal number. 1, 2, \u0026hellip;, 30   %b Abbreviated month name. Jan, Feb, \u0026hellip;, Dec   %B Full month name. January, February, \u0026hellip;   %m Month as a zero-padded decimal number. 01, 02, \u0026hellip;, 12   %-m Month as a decimal number. 1, 2, \u0026hellip;, 12   %y Year without century as a zero-padded decimal number. 00, 01, \u0026hellip;, 99   %-y Year without century as a decimal number. 0, 1, \u0026hellip;, 99   %Y Year with century as a decimal number. 2013, 2019 etc.   %H Hour (24-hour clock) as a zero-padded decimal number. 00, 01, \u0026hellip;, 23   %-H Hour (24-hour clock) as a decimal number. 0, 1, \u0026hellip;, 23   %I Hour (12-hour clock) as a zero-padded decimal number. 01, 02, \u0026hellip;, 12   %-I Hour (12-hour clock) as a decimal number. 1, 2, \u0026hellip; 12   %p Locale’s AM or PM. AM, PM   %M Minute as a zero-padded decimal number. 00, 01, \u0026hellip;, 59   %-M Minute as a decimal number. 0, 1, \u0026hellip;, 59   %S Second as a zero-padded decimal number. 00, 01, \u0026hellip;, 59   %-S Second as a decimal number. 0, 1, \u0026hellip;, 59   %f Microsecond as a decimal number, zero-padded on the left. 000000 - 999999   %z UTC offset in the form +HHMM or -HHMM. nan   %Z Time zone name. nan   %j Day of the year as a zero-padded decimal number. 001, 002, \u0026hellip;, 366   %-j Day of the year as a decimal number. 1, 2, \u0026hellip;, 366   %U Week number of the year (Sunday as the first day of the week). All days in a new year preceding the first Sunday are considered to be in week 0. 00, 01, \u0026hellip;, 53   %W Week number of the year (Monday as the first day of the week). All days in a new year preceding the first Monday are considered to be in week 0. 00, 01, \u0026hellip;, 53   %c Locale’s appropriate date and time representation. Mon Sep 30 07:06:05 2013   %x Locale’s appropriate date representation. 09/30/13   %X Locale’s appropriate time representation. 7:06:05   %% A literal \u0026lsquo;%\u0026rsquo; character. %     Example 3: Locale\u0026rsquo;s appropriate date and time from datetime import datetime timestamp = 1528797322 date_time = datetime.fromtimestamp(timestamp) d = date_time.strftime(\u0026#34;%c\u0026#34;) print(\u0026#34;Output 1:\u0026#34;, d)\td = date_time.strftime(\u0026#34;%x\u0026#34;) print(\u0026#34;Output 2:\u0026#34;, d) d = date_time.strftime(\u0026#34;%X\u0026#34;) print(\u0026#34;Output 3:\u0026#34;, d) When you run the program, the output will be:\nOutput 1: Tue Jun 12 09:55:22 2018 Output 2: 06/12/18 Output 3: 09:55:22 Format codes %c, %x and %X are used for locale\u0026rsquo;s appropriate date and time representation.\n We also recommend you to check Python strptime(). The strptime() method creates a datetime object from a string.\n Reference : https://www.programiz.com/python-programming/datetime/strftime\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/intermediate/",
	"title": "ระดับกลาง(Intermediate)",
	"tags": [],
	"description": "",
	"content": "บทที่ ๑๗: การอ่านข้อมูลจากไฟล์\n※ open close read readlines readline seek tell with\nบทที่ ๑๘: การเขียนข้อมูลลงไฟล์\n※ write writelines shutil\nบทที่ ๑๙: การสร้างฟังก์ชัน\n※ def return global\nบทที่ ๒๐: ฟังก์ชันเวียนเกิด\n※\nบทที่ ๒๑: คำสั่งพิเศษบางตัวที่เกี่ยวข้องกับฟังก์ชัน\n※ lambda map filter any all\nบทที่ ๒๒: การสร้างคลาส\n※ class init\nบทที่ ๒๓: การรับทอด\n※ super\nบทที่ ๒๔: เมธอดและแอตทริบิวต์พิเศษของคลาส\n※ len str bool isinstance issubclass setattr getattr hasattr delattr\nบทที่ ๒๕: การจัดการกับข้อยกเว้น\n※ raise try except\nเกร็ดเล็กน้อย ⊟ [2016/04/30] สร้างแอตทริบิวต์ที่มีคุณสมบัติพิเศษในคลาสด้วย property\n⊟ [2018/05/31] ข้อควรระวังเมื่อใช้ try และ except แล้วต้องการหยุดโปรแกรมกลางคัน\n⊟ [2019/01/07] วิธีทำให้ import มอดูลที่ต้องการทุกครั้งเมื่อเริ่มโปรแกรม\n⊟ [2019/01/08] วิธีการรันไพธอนโดยตรงใน unix shell ใน mac และ linux\n⊟ [2019/01/12] ข้อควรระวังเมื่อมีการแก้ไขลิสต์ขณะใช้ for อาจทำให้เกิดการวนซ้ำไม่สิ้นสุดได้\n⊟ [2019/06/24] ทำความเข้าใจ and และ or ให้มากขึ้น\n⊟ [2019/07/13] เปรียบเทียบระหว่างการใช้ %, ใช้ format และใช้ f-string ใน python\nการประยุกต์ใช้ \u0026raquo; สารบัญแนะนำมอดูลต่างๆ \u0026raquo; สารบัญการเรียนรู้ของเครื่อง \u0026raquo; สารบัญโครงข่ายประสาทเทียม จิปาถะ ⊟ [2017/02/23] สร้างแฟร็กทัลอย่างง่าย\n⊟ [2018/03/26] ใช้ opencv (cv2) เพื่อค้นหาใบหน้าอนิเมะ\n⊟ [2018/03/29] ค้นหาภาพใบหน้าอนิเมะจากเว็บ safebooru\n⊟ [2018/07/14] สร้างเส้นโค้งฮิลแบร์ทสองมิติ\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/dictionary/",
	"title": "Dictionary",
	"tags": [],
	"description": "Python - Dictionary",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/tutorial-geeksforgeeks/selection/extracting-rows-using-pandas-iloc/",
	"title": "Extracting rows using .iloc[]",
	"tags": [],
	"description": "",
	"content": "Python is a great language for doing data analysis, primarily because of the fantastic ecosystem of data-centric Python packages. Pandas is one of those packages and makes importing and analyzing data much easier.\nPandas provide a unique method to retrieve rows from a Data frame. Dataframe.iloc[] method is used when the index label of a data frame is something other than numeric series of 0, 1, 2, 3….n or in case the user doesn’t know the index label. Rows can be extracted using an imaginary index position which isn’t visible in the data frame.\n Syntax: pandas.DataFrame.iloc[]\nParameters:\nIndex Position: Index position of rows in integer or list of integer.\nReturn type: Data frame or Series depending on parameters\n To download the CSV used in code, click here.\nExample 1: Extracting single row and comparing with .loc[]\nIn this example, same index number row is extracted by both .iloc[] and.loc[] method and compared. Since the index column by default is numeric, hence the index label will also be integers.\n# importing pandas package  import pandas as pd # making data frame from csv file  data = pd.read_csv(\u0026#34;nba.csv\u0026#34;) # retrieving rows by loc method  row1 = data.loc[3] # retrieving rows by iloc method  row2 = data.iloc[3] # checking if values are equal  row1 == row2 Output:\nAs shown in the output image, the results returned by both the methods are same.\nExample #2: Extracting multiple rows with index\nIn this example, multiple rows are extracted first by passing a list and then by passing integers to extract rows between that range. After that, both the values are compared.\n# importing pandas package  import pandas as pd # making data frame from csv file  data = pd.read_csv(\u0026#34;nba.csv\u0026#34;) # retrieving rows by loc method  row1 = data.iloc[[4, 5, 6, 7]] # retrieving rows by loc method  row2 = data.iloc[4:8] # comparing values  row1 == row2 Output:\nAs shown in the output image, the results returned by both the methods are same. All values are True except values in college column since those were NaN values.\nRecommended Posts:  Select Rows \u0026amp; Columns by Name or Index in Pandas DataFrame using , loc \u0026amp; iloc Python | Pandas Extracting rows using .loc[] Select any row from a Dataframe using iloc[] and iat[] in Pandas Python | Pandas Series.iloc Difference between loc() and iloc() in Pandas DataFrame Python | Delete rows/columns from DataFrame using Pandas.drop() Select first or last N rows in a Dataframe using head() and tail() method in Python-Pandas How to skip rows while reading csv file using Pandas? Concatenate strings from several rows using Pandas groupby Limited rows selection with given column in Pandas | Python How to randomly select rows from Pandas DataFrame How to get rows/index names in Pandas dataframe Get all rows in a Pandas DataFrame containing given substring Different ways to iterate over rows in Pandas Dataframe Selecting rows in pandas DataFrame based on conditions How to iterate over rows in Pandas Dataframe Sorting rows in pandas DataFrame Dealing with Rows and Columns in Pandas DataFrame Iterating over rows and columns in Pandas DataFrame Grouping Rows in pandas   Reference : https://www.geeksforgeeks.org/python-extracting-rows-using-pandas-iloc/\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/function/",
	"title": "Function",
	"tags": [],
	"description": "",
	"content": "In this article, you\u0026rsquo;ll learn about functions, what a function is, the syntax, components, and types of functions. Also, you\u0026rsquo;ll learn to create a function in Python.\nWhat is a function in Python? In Python, a function is a group of related statements that performs a specific task.\nFunctions help break our program into smaller and modular chunks. As our program grows larger and larger, functions make it more organized and manageable.\nFurthermore, it avoids repetition and makes the code reusable.\nSyntax of Function def function_name(parameters): \u0026#34;\u0026#34;\u0026#34;docstring\u0026#34;\u0026#34;\u0026#34; statement(s) Above shown is a function definition that consists of the following components.\n Keyword def that marks the start of the function header. A function name to uniquely identify the function. Function naming follows the same rules of writing identifiers in Python. Parameters (arguments) through which we pass values to a function. They are optional. A colon (:) to mark the end of the function header. Optional documentation string (docstring) to describe what the function does. One or more valid python statements that make up the function body. Statements must have the same indentation level (usually 4 spaces). An optional return statement to return a value from the function.  Example of a function def greet(name): \u0026#34;\u0026#34;\u0026#34; This function greets to the person passed in as a parameter \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Hello, \u0026#34; + name + \u0026#34;. Good morning!\u0026#34;) How to call a function in python? Once we have defined a function, we can call it from another function, program or even the Python prompt. To call a function we simply type the function name with appropriate parameters.\n\u0026gt;\u0026gt;\u0026gt; greet(\u0026#39;Paul\u0026#39;) Hello, Paul. Good morning! Note: Try running the above code in the Python program with the function definition to see the output.\ndef greet(name): \u0026#34;\u0026#34;\u0026#34; This function greets to the person passed in as a parameter \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Hello, \u0026#34; + name + \u0026#34;. Good morning!\u0026#34;) greet(\u0026#39;Paul\u0026#39;)  Docstrings The first string after the function header is called the docstring and is short for documentation string. It is briefly used to explain what a function does.\nAlthough optional, documentation is a good programming practice. Unless you can remember what you had for dinner last week, always document your code.\nIn the above example, we have a docstring immediately below the function header. We generally use triple quotes so that docstring can extend up to multiple lines. This string is available to us as the __doc__ attribute of the function.\nFor example:\nTry running the following into the Python shell to see the output.\n\u0026gt;\u0026gt;\u0026gt; print(greet.__doc__) This function greets to the person passed in as a parameter To learn more about docstrings in Python, visit Python Docstrings.\n The return statement The return statement is used to exit a function and go back to the place from where it was called.\nSyntax of return return [expression_list]\nThis statement can contain an expression that gets evaluated and the value is returned. If there is no expression in the statement or the return statement itself is not present inside a function, then the function will return the None object.\nFor example:\n\u0026gt;\u0026gt;\u0026gt; print(greet(\u0026#34;May\u0026#34;)) Hello, May. Good morning! None Here, None is the returned value since greet() directly prints the name and no return statement is used.\n Example of return def absolute_value(num): \u0026#34;\u0026#34;\u0026#34;This function returns the absolute value of the entered number\u0026#34;\u0026#34;\u0026#34; if num \u0026gt;= 0: return num else: return -num print(absolute_value(2)) print(absolute_value(-4)) Output\n2 4  How Function works in Python? Working of functions in Python\n Scope and Lifetime of variables Scope of a variable is the portion of a program where the variable is recognized. Parameters and variables defined inside a function are not visible from outside the function. Hence, they have a local scope.\nThe lifetime of a variable is the period throughout which the variable exits in the memory. The lifetime of variables inside a function is as long as the function executes.\nThey are destroyed once we return from the function. Hence, a function does not remember the value of a variable from its previous calls.\nHere is an example to illustrate the scope of a variable inside a function.\ndef my_func(): x = 10 print(\u0026#34;Value inside function:\u0026#34;,x) x = 20 my_func() print(\u0026#34;Value outside function:\u0026#34;,x) Output\nValue inside function: 10 Value outside function: 20 Here, we can see that the value of x is 20 initially. Even though the function my_func() changed the value of x to 10, it did not affect the value outside the function.\nThis is because the variable x inside the function is different (local to the function) from the one outside. Although they have the same names, they are two different variables with different scopes.\nOn the other hand, variables outside of the function are visible from inside. They have a global scope.\nWe can read these values from inside the function but cannot change (write) them. In order to modify the value of variables outside the function, they must be declared as global variables using the keyword global.\n Types of Functions Basically, we can divide functions into the following two types:\n Built-in functions - Functions that are built into Python. User-defined functions - Functions defined by the users themselves.   Source : https://www.programiz.com/python-programming/anonymous-function\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/files/exceptions/",
	"title": "Python Exceptions",
	"tags": [],
	"description": "",
	"content": "Python Errors and Built-in Exceptions In this tutorial, you will learn about different types of errors and exceptions that are built-in to Python. They are raised whenever the Python interpreter encounters errors. We can make certain mistakes while writing a program that lead to errors when we try to run it. A python program terminates as soon as it encounters an unhandled error. These errors can be broadly classified into two classes:\n Syntax errors Logical errors (Exceptions)   Python Syntax Errors Error caused by not following the proper structure (syntax) of the language is called syntax error or parsing error.\nLet\u0026rsquo;s look at one example:\nif a \u0026lt; 3 File \u0026#34;\u0026lt;interactive input\u0026gt;\u0026#34;, line 1 if a \u0026lt; 3 ^ SyntaxError: invalid syntax As shown in the example, an arrow indicates where the parser ran into the syntax error.\nWe can notice here that a colon : is missing in the if statement.\n Python Logical Errors (Exceptions) Errors that occur at runtime (after passing the syntax test) are called exceptions or logical errors.\nFor instance, they occur when we try to open a file(for reading) that does not exist (FileNotFoundError), try to divide a number by zero (ZeroDivisionError), or try to import a module that does not exist (ImportError).\nWhenever these types of runtime errors occur, Python creates an exception object. If not handled properly, it prints a traceback to that error along with some details about why that error occurred.\nLet\u0026rsquo;s look at how Python treats these errors:\n1 / 0 Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 301, in runcode File \u0026#34;\u0026lt;interactive input\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ZeroDivisionError: division by zero open(\u0026#34;imaginary.txt\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 301, in runcode File \u0026#34;\u0026lt;interactive input\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; FileNotFoundError: [Errno 2] No such file or directory: \u0026#39;imaginary.txt\u0026#39;  Python Built-in Exceptions Illegal operations can raise exceptions. There are plenty of built-in exceptions in Python that are raised when corresponding errors occur. We can view all the built-in exceptions using the built-in local() function as follows:\nprint(dir(locals()[\u0026#39;__builtins__\u0026#39;])) locals()['__builtins__'] will return a module of built-in exceptions, functions, and attributes. dir allows us to list these attributes as strings.\nSome of the common built-in exceptions in Python programming along with the error that cause them are listed below:\n   Exception Cause of Error     AssertionError Raised when an assert statement fails.   AttributeError Raised when attribute assignment or reference fails.   EOFError Raised when the input() function hits end-of-file condition.   FloatingPointError Raised when a floating point operation fails.   GeneratorExit Raise when a generator\u0026rsquo;s close() method is called.   ImportError Raised when the imported module is not found.   IndexError Raised when the index of a sequence is out of range.   KeyError Raised when a key is not found in a dictionary.   KeyboardInterrupt Raised when the user hits the interrupt key (Ctrl+C or Delete).   MemoryError Raised when an operation runs out of memory.   NameError Raised when a variable is not found in local or global scope.   NotImplementedError Raised by abstract methods.   OSError Raised when system operation causes system related error.   OverflowError Raised when the result of an arithmetic operation is too large to be represented.   ReferenceError Raised when a weak reference proxy is used to access a garbage collected referent.   RuntimeError Raised when an error does not fall under any other category.   StopIteration Raised by next() function to indicate that there is no further item to be returned by iterator.   SyntaxError Raised by parser when syntax error is encountered.   IndentationError Raised when there is incorrect indentation.   TabError Raised when indentation consists of inconsistent tabs and spaces.   SystemError Raised when interpreter detects internal error.   SystemExit Raised by sys.exit() function.   TypeError Raised when a function or operation is applied to an object of incorrect type.   UnboundLocalError Raised when a reference is made to a local variable in a function or method, but no value has been bound to that variable.   UnicodeError Raised when a Unicode-related encoding or decoding error occurs.   UnicodeEncodeError Raised when a Unicode-related error occurs during encoding.   UnicodeDecodeError Raised when a Unicode-related error occurs during decoding.   UnicodeTranslateError Raised when a Unicode-related error occurs during translating.   ValueError Raised when a function gets an argument of correct type but improper value.   ZeroDivisionError Raised when the second operand of division or modulo operation is zero.    If required, we can also define our own exceptions in Python. To learn more about them, visit Python User-defined Exceptions.\nWe can handle these built-in and user-defined exceptions in Python using try, except and finally statements. To learn more about them, visit Python try, except and finally statements.\n Source : https://www.programiz.com/python-programming/exceptions\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/objects_class/inheritance/",
	"title": "Python Inheritance",
	"tags": [],
	"description": "",
	"content": "It refers to defining a new class with little or no modification to an existing class. The new class is called derived (or child) class and the one from which it inherits is called the base (or parent) class.\n Python Inheritance Syntax class BaseClass: Body of base class class DerivedClass(BaseClass): Body of derived class Derived class inherits features from the base class where new features can be added to it. This results in re-usability of code.\n Example of Inheritance in Python To demonstrate the use of inheritance, let us take an example.\nA polygon is a closed figure with 3 or more sides. Say, we have a class called Polygon defined as follows.\nclass Polygon: def __init__(self, no_of_sides): self.n = no_of_sides self.sides = [0 for i in range(no_of_sides)] def inputSides(self): self.sides = [float(input(\u0026#34;Enter side \u0026#34;+str(i+1)+\u0026#34; : \u0026#34;)) for i in range(self.n)] def dispSides(self): for i in range(self.n): print(\u0026#34;Side\u0026#34;,i+1,\u0026#34;is\u0026#34;,self.sides[i]) This class has data attributes to store the number of sides n and magnitude of each side as a list called sides.\nThe inputSides() method takes in the magnitude of each side and dispSides() displays these side lengths.\nA triangle is a polygon with 3 sides. So, we can create a class called Triangle which inherits from Polygon. This makes all the attributes of Polygon class available to the Triangle class.\nWe don\u0026rsquo;t need to define them again (code reusability). Triangle can be defined as follows.\nclass Triangle(Polygon): def __init__(self): Polygon.__init__(self,3) def findArea(self): a, b, c = self.sides # calculate the semi-perimeter s = (a + b + c) / 2 area = (s*(s-a)*(s-b)*(s-c)) ** 0.5 print(\u0026#39;The area of the triangle is %0.2f\u0026#39; %area) However, class Triangle has a new method findArea() to find and print the area of the triangle. Here is a sample run.\n\u0026gt;\u0026gt;\u0026gt; t = Triangle() \u0026gt;\u0026gt;\u0026gt; t.inputSides() Enter side 1 : 3 Enter side 2 : 5 Enter side 3 : 4 \u0026gt;\u0026gt;\u0026gt; t.dispSides() Side 1 is 3.0 Side 2 is 5.0 Side 3 is 4.0 \u0026gt;\u0026gt;\u0026gt; t.findArea() The area of the triangle is 6.00 We can see that even though we did not define methods like inputSides() or dispSides() for class Triangle separately, we were able to use them.\nIf an attribute is not found in the class itself, the search continues to the base class. This repeats recursively, if the base class is itself derived from other classes.\n Method Overriding in Python In the above example, notice that __init__() method was defined in both classes, Triangle as well Polygon. When this happens, the method in the derived class overrides that in the base class. This is to say, __init__() in Triangle gets preference over the __init__ in Polygon.\nGenerally when overriding a base method, we tend to extend the definition rather than simply replace it. The same is being done by calling the method in base class from the one in derived class (calling Polygon.__init__() from __init__() in Triangle).\nA better option would be to use the built-in function super(). So, super().__init__(3) is equivalent to Polygon.__init__(self,3) and is preferred. To learn more about the super() function in Python, visit Python super() function.\nTwo built-in functions isinstance() and issubclass() are used to check inheritances.\nThe function isinstance() returns True if the object is an instance of the class or other classes derived from it. Each and every class in Python inherits from the base class object.\n\u0026gt;\u0026gt;\u0026gt; isinstance(t,Triangle) True \u0026gt;\u0026gt;\u0026gt; isinstance(t,Polygon) True \u0026gt;\u0026gt;\u0026gt; isinstance(t,int) False \u0026gt;\u0026gt;\u0026gt; isinstance(t,object) True Similarly, issubclass() is used to check for class inheritance.\n\u0026gt;\u0026gt;\u0026gt; issubclass(Polygon,Triangle) False \u0026gt;\u0026gt;\u0026gt; issubclass(Triangle,Polygon) True \u0026gt;\u0026gt;\u0026gt; issubclass(bool,int) True  Reference : https://www.programiz.com/python-programming/inheritance\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/data_type/list/",
	"title": "Python: List",
	"tags": [],
	"description": "",
	"content": "In this article, we\u0026rsquo;ll learn everything about Python lists, how they are created, slicing of a list, adding or removing elements from them and so on.\nPython offers a range of compound data types often referred to as sequences. List is one of the most frequently used and very versatile data types used in Python.\n How to create a list? In Python programming, a list is created by placing all the items (elements) inside square brackets [], separated by commas.\nIt can have any number of items and they may be of different types (integer, float, string etc.).\n# empty list my_list = [] # list of integers my_list = [1, 2, 3] # list with mixed data types my_list = [1, \u0026#34;Hello\u0026#34;, 3.4] A list can also have another list as an item. This is called a nested list.\n# nested list my_list = [\u0026#34;mouse\u0026#34;, [8, 4, 6], [\u0026#39;a\u0026#39;]]  How to access elements from a list? There are various ways in which we can access the elements of a list.\nList Index We can use the index operator [] to access an item in a list. In Python, indices start at 0. So, a list having 5 elements will have an index from 0 to 4.\nTrying to access indexes other than these will raise an IndexError. The index must be an integer. We can\u0026rsquo;t use float or other types, this will result in TypeError.\nNested lists are accessed using nested indexing.\n# List indexing my_list = [\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;e\u0026#39;] # Output: p print(my_list[0]) # Output: o print(my_list[2]) # Output: e print(my_list[4]) # Nested List n_list = [\u0026#34;Happy\u0026#34;, [2, 0, 1, 5]] # Nested indexing print(n_list[0][1]) print(n_list[1][3]) # Error! Only integer can be used for indexing print(my_list[4.0]) Output\np o e a 5 Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 21, in \u0026lt;module\u0026gt; TypeError: list indices must be integers or slices, not float  Negative indexing Python allows negative indexing for its sequences. The index of -1 refers to the last item, -2 to the second last item and so on.\n# Negative indexing in lists my_list = [\u0026#39;p\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;e\u0026#39;] print(my_list[-1]) print(my_list[-5]) When we run the above program, we will get the following output:\ne p List indexing in Python\n How to slice lists in Python? We can access a range of items in a list by using the slicing operator :(colon).\n# List slicing in Python my_list = [\u0026#39;p\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;z\u0026#39;] # elements 3rd to 5th print(my_list[2:5]) # elements beginning to 4th print(my_list[:-5]) # elements 6th to end print(my_list[5:]) # elements beginning to end print(my_list[:]) Output\n[\u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;] [\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;] [\u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;] [\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;] Slicing can be best visualized by considering the index to be between the elements as shown below. So if we want to access a range, we need two indices that will slice that portion from the list.\nElement Slicing from a list in Python\n How to change or add elements to a list? Lists are mutable, meaning their elements can be changed unlike string or tuple.\nWe can use the assignment operator (=) to change an item or a range of items.\n# Correcting mistake values in a list odd = [2, 4, 6, 8] # change the 1st item  odd[0] = 1 print(odd) # change 2nd to 4th items odd[1:4] = [3, 5, 7] print(odd) Output\n[1, 4, 6, 8] [1, 3, 5, 7] We can add one item to a list using the append() method or add several items using extend() method.\n# Appending and Extending lists in Python odd = [1, 3, 5] odd.append(7) print(odd) odd.extend([9, 11, 13]) print(odd) Output\n[1, 3, 5, 7] [1, 3, 5, 7, 9, 11, 13] We can also use + operator to combine two lists. This is also called concatenation.\nThe * operator repeats a list for the given number of times.\n# Concatenating and repeating lists odd = [1, 3, 5] print(odd + [9, 7, 5]) print([\u0026#34;re\u0026#34;] * 3) Output\n[1, 3, 5, 9, 7, 5] [\u0026#39;re\u0026#39;, \u0026#39;re\u0026#39;, \u0026#39;re\u0026#39;] Furthermore, we can insert one item at a desired location by using the method insert() or insert multiple items by squeezing it into an empty slice of a list.\n# Demonstration of list insert() method odd = [1, 9] odd.insert(1,3) print(odd) odd[2:2] = [5, 7] print(odd) Output\n[1, 3, 9] [1, 3, 5, 7, 9]  How to delete or remove elements from a list? We can delete one or more items from a list using the keyword del. It can even delete the list entirely.\n# Deleting list items my_list = [\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;] # delete one item del my_list[2] print(my_list) # delete multiple items del my_list[1:5] print(my_list) # delete entire list del my_list # Error: List not defined print(my_list) Output\n[\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;] [\u0026#39;p\u0026#39;, \u0026#39;m\u0026#39;] Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 18, in \u0026lt;module\u0026gt; NameError: name \u0026#39;my_list\u0026#39; is not defined We can use remove() method to remove the given item or pop() method to remove an item at the given index.\nThe pop() method removes and returns the last item if the index is not provided. This helps us implement lists as stacks (first in, last out data structure).\nWe can also use the clear() method to empty a list.\nmy_list = [\u0026#39;p\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;m\u0026#39;] my_list.remove(\u0026#39;p\u0026#39;) # Output: [\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;] print(my_list) # Output: \u0026#39;o\u0026#39; print(my_list.pop(1)) # Output: [\u0026#39;r\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;] print(my_list) # Output: \u0026#39;m\u0026#39; print(my_list.pop()) # Output: [\u0026#39;r\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;] print(my_list) my_list.clear() # Output: [] print(my_list) Output\n[\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;] o [\u0026#39;r\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;] m [\u0026#39;r\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;] [] Finally, we can also delete items in a list by assigning an empty list to a slice of elements.\n\u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#39;p\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;m\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list[2:3] = [] \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list[2:5] = [] \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;m\u0026#39;]  Python List Methods Methods that are available with list objects in Python programming are tabulated below.\nThey are accessed as list.method(). Some of the methods have already been used above.\nPython List Methods\nappend() - Add an element to the end of the list\nextend() - Add all elements of a list to the another list\ninsert() - Insert an item at the defined index\nremove() - Removes an item from the list\npop() - Removes and returns an element at the given index\nclear() - Removes all items from the list\nindex() - Returns the index of the first matched item\ncount() - Returns the count of the number of items passed as an argument\nsort() - Sort items in a list in ascending order\nreverse() - Reverse the order of items in the list\ncopy() - Returns a shallow copy of the list\nSome examples of Python list methods:\n# Python list methods my_list = [3, 8, 1, 6, 0, 8, 4] # Output: 1 print(my_list.index(8)) # Output: 2 print(my_list.count(8)) my_list.sort() # Output: [0, 1, 3, 4, 6, 8, 8] print(my_list) my_list.reverse() # Output: [8, 8, 6, 4, 3, 1, 0] print(my_list) Output\n1 2 [0, 1, 3, 4, 6, 8, 8] [8, 8, 6, 4, 3, 1, 0]  List Comprehension: Elegant way to create new List List comprehension is an elegant and concise way to create a new list from an existing list in Python.\nA list comprehension consists of an expression followed by for statement inside square brackets.\nHere is an example to make a list with each item being increasing power of 2.\npow2 = [2 ** x for x in range(10)] print(pow2) Output\n[1, 2, 4, 8, 16, 32, 64, 128, 256, 512] This code is equivalent to:\npow2 = [] for x in range(10): pow2.append(2 ** x) A list comprehension can optionally contain more for or if statements. An optional if statement can filter out items for the new list. Here are some examples.\n\u0026gt;\u0026gt;\u0026gt; pow2 = [2 ** x for x in range(10) if x \u0026gt; 5] \u0026gt;\u0026gt;\u0026gt; pow2 [64, 128, 256, 512] \u0026gt;\u0026gt;\u0026gt; odd = [x for x in range(20) if x % 2 == 1] \u0026gt;\u0026gt;\u0026gt; odd [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] \u0026gt;\u0026gt;\u0026gt; [x+y for x in [\u0026#39;Python \u0026#39;,\u0026#39;C \u0026#39;] for y in [\u0026#39;Language\u0026#39;,\u0026#39;Programming\u0026#39;]] [\u0026#39;Python Language\u0026#39;, \u0026#39;Python Programming\u0026#39;, \u0026#39;C Language\u0026#39;, \u0026#39;C Programming\u0026#39;]  Other List Operations in Python List Membership Test We can test if an item exists in a list or not, using the keyword in.\nmy_list = [\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;] # Output: True print(\u0026#39;p\u0026#39; in my_list) # Output: False print(\u0026#39;a\u0026#39; in my_list) # Output: True print(\u0026#39;c\u0026#39; not in my_list) Output\nTrue False True  Iterating Through a List Using a for loop we can iterate through each item in a list.\nfor fruit in [\u0026#39;apple\u0026#39;,\u0026#39;banana\u0026#39;,\u0026#39;mango\u0026#39;]: print(\u0026#34;I like\u0026#34;,fruit) Output\nI like apple I like banana I like mango \n Source : https://www.programiz.com/python-programming/list\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/data_type/tuble/",
	"title": "Python: Tuble",
	"tags": [],
	"description": "",
	"content": "In this article, you\u0026rsquo;ll learn everything about Python tuples. More specifically, what are tuples, how to create them, when to use them and various methods you should be familiar with.\nA tuple in Python is similar to a list. The difference between the two is that we cannot change the elements of a tuple once it is assigned whereas we can change the elements of a list.\n Creating a Tuple A tuple is created by placing all the items (elements) inside parentheses (), separated by commas. The parentheses are optional, however, it is a good practice to use them.\nA tuple can have any number of items and they may be of different types (integer, float, list, string, etc.).\n# Different types of tuples # Empty tuple my_tuple = () print(my_tuple) # Tuple having integers my_tuple = (1, 2, 3) print(my_tuple) # tuple with mixed datatypes my_tuple = (1, \u0026#34;Hello\u0026#34;, 3.4) print(my_tuple) # nested tuple my_tuple = (\u0026#34;mouse\u0026#34;, [8, 4, 6], (1, 2, 3)) print(my_tuple) Output\n() (1, 2, 3) (1, \u0026#39;Hello\u0026#39;, 3.4) (\u0026#39;mouse\u0026#39;, [8, 4, 6], (1, 2, 3)) A tuple can also be created without using parentheses. This is known as tuple packing.\nmy_tuple = 3, 4.6, \u0026#34;dog\u0026#34; print(my_tuple) # tuple unpacking is also possible a, b, c = my_tuple print(a) # 3 print(b) # 4.6 print(c) # dog Output\n(3, 4.6, \u0026#39;dog\u0026#39;) 3 4.6 dog Creating a tuple with one element is a bit tricky.\nHaving one element within parentheses is not enough. We will need a trailing comma to indicate that it is, in fact, a tuple.\nmy_tuple = (\u0026#34;hello\u0026#34;) print(type(my_tuple)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; # Creating a tuple having one element my_tuple = (\u0026#34;hello\u0026#34;,) print(type(my_tuple)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # Parentheses is optional my_tuple = \u0026#34;hello\u0026#34;, print(type(my_tuple)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; Output\n\u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt;  Access Tuple Elements There are various ways in which we can access the elements of a tuple.\n1. Indexing We can use the index operator [] to access an item in a tuple, where the index starts from 0.\nSo, a tuple having 6 elements will have indices from 0 to 5. Trying to access an index outside of the tuple index range(6,7,\u0026hellip; in this example) will raise an IndexError.\nThe index must be an integer, so we cannot use float or other types. This will result in TypeError.\nLikewise, nested tuples are accessed using nested indexing, as shown in the example below.\n# Accessing tuple elements using indexing my_tuple = (\u0026#39;p\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;t\u0026#39;) print(my_tuple[0]) # \u0026#39;p\u0026#39;  print(my_tuple[5]) # \u0026#39;t\u0026#39; # IndexError: list index out of range # print(my_tuple[6]) # Index must be an integer # TypeError: list indices must be integers, not float # my_tuple[2.0] # nested tuple n_tuple = (\u0026#34;mouse\u0026#34;, [8, 4, 6], (1, 2, 3)) # nested index print(n_tuple[0][3]) # \u0026#39;s\u0026#39; print(n_tuple[1][1]) # 4 Output\np t s 4  2. Negative Indexing Python allows negative indexing for its sequences.\nThe index of -1 refers to the last item, -2 to the second last item and so on.\n# Negative indexing for accessing tuple elements my_tuple = (\u0026#39;p\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;t\u0026#39;) # Output: \u0026#39;t\u0026#39; print(my_tuple[-1]) # Output: \u0026#39;p\u0026#39; print(my_tuple[-6]) Output\nt p  3. Slicing We can access a range of items in a tuple by using the slicing operator colon :.\n# Accessing tuple elements using slicing my_tuple = (\u0026#39;p\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;z\u0026#39;) # elements 2nd to 4th # Output: (\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;) print(my_tuple[1:4]) # elements beginning to 2nd # Output: (\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;) print(my_tuple[:-7]) # elements 8th to end # Output: (\u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;) print(my_tuple[7:]) # elements beginning to end # Output: (\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;) print(my_tuple[:]) Output\n(\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;) (\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;) (\u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;) (\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;) Slicing can be best visualized by considering the index to be between the elements as shown below. So if we want to access a range, we need the index that will slice the portion from the tuple.\nElement Slicing in Python\n Changing a Tuple Unlike lists, tuples are immutable.\nThis means that elements of a tuple cannot be changed once they have been assigned. But, if the element is itself a mutable data type like list, its nested items can be changed.\nWe can also assign a tuple to different values (reassignment).\n# Changing tuple values my_tuple = (4, 2, 3, [6, 5]) # TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment # my_tuple[1] = 9 # However, item of mutable element can be changed my_tuple[3][0] = 9 # Output: (4, 2, 3, [9, 5]) print(my_tuple) # Tuples can be reassigned my_tuple = (\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;) # Output: (\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;) print(my_tuple) Output\n(4, 2, 3, [9, 5]) (\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;) We can use + operator to combine two tuples. This is called concatenation.\nWe can also repeat the elements in a tuple for a given number of times using the * operator.\nBoth + and * operations result in a new tuple.\n# Concatenation # Output: (1, 2, 3, 4, 5, 6) print((1, 2, 3) + (4, 5, 6)) # Repeat # Output: (\u0026#39;Repeat\u0026#39;, \u0026#39;Repeat\u0026#39;, \u0026#39;Repeat\u0026#39;) print((\u0026#34;Repeat\u0026#34;,) * 3) Output\n(1, 2, 3, 4, 5, 6) (\u0026#39;Repeat\u0026#39;, \u0026#39;Repeat\u0026#39;, \u0026#39;Repeat\u0026#39;)  Deleting a Tuple As discussed above, we cannot change the elements in a tuple. It means that we cannot delete or remove items from a tuple.\nDeleting a tuple entirely, however, is possible using the keyword del.\n# Deleting tuples my_tuple = (\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;z\u0026#39;) # can\u0026#39;t delete items # TypeError: \u0026#39;tuple\u0026#39; object doesn\u0026#39;t support item deletion # del my_tuple[3] # Can delete an entire tuple del my_tuple # NameError: name \u0026#39;my_tuple\u0026#39; is not defined print(my_tuple) Output\nTraceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 12, in \u0026lt;module\u0026gt; NameError: name \u0026#39;my_tuple\u0026#39; is not defined  Tuple Methods Methods that add items or remove items are not available with tuple. Only the following two methods are available.\nSome examples of Python tuple methods:\nmy_tuple = (\u0026#39;a\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;,) print(my_tuple.count(\u0026#39;p\u0026#39;)) # Output: 2 print(my_tuple.index(\u0026#39;l\u0026#39;)) # Output: 3 Output\n2 3  Other Tuple Operations 1. Tuple Membership Test We can test if an item exists in a tuple or not, using the keyword in.\n# Membership test in tuple my_tuple = (\u0026#39;a\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;,) # In operation print(\u0026#39;a\u0026#39; in my_tuple) print(\u0026#39;b\u0026#39; in my_tuple) # Not in operation print(\u0026#39;g\u0026#39; not in my_tuple) Output\nTrue False True  2. Iterating Through a Tuple We can use a for loop to iterate through each item in a tuple.\n# Using a for loop to iterate through a tuple for name in (\u0026#39;John\u0026#39;, \u0026#39;Kate\u0026#39;): print(\u0026#34;Hello\u0026#34;, name) Output\nHello John Hello Kate  Advantages of Tuple over List Since tuples are quite similar to lists, both of them are used in similar situations. However, there are certain advantages of implementing a tuple over a list. Below listed are some of the main advantages:\n We generally use tuples for heterogeneous (different) data types and lists for homogeneous (similar) data types. Since tuples are immutable, iterating through a tuple is faster than with list. So there is a slight performance boost. Tuples that contain immutable elements can be used as a key for a dictionary. With lists, this is not possible. If you have data that doesn\u0026rsquo;t change, implementing it as tuple will guarantee that it remains write-protected.   Source : https://www.programiz.com/python-programming/tuple\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/datetime/strptime/",
	"title": "strptime()",
	"tags": [],
	"description": "",
	"content": "In this article, you will learn to create a datetime object from a string (with the help of examples).\nThe strptime() method creates a datetime object from the given string.\nNote: You cannot create datetime object from every string. The string needs to be in a certain format.\n Example 1: string to datetime object from datetime import datetime date_string = \u0026#34;21 June, 2018\u0026#34; print(\u0026#34;date_string =\u0026#34;, date_string) print(\u0026#34;type of date_string =\u0026#34;, type(date_string)) date_object = datetime.strptime(date_string, \u0026#34;%d%B, %Y\u0026#34;) print(\u0026#34;date_object =\u0026#34;, date_object) print(\u0026#34;type of date_object =\u0026#34;, type(date_object)) When you run the program, the output will be:\ndate_string = 21 June, 2018 type of date_string = \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; date_object = 2018-06-21 00:00:00 type of date_object = \u0026lt;class \u0026#39;datetime.datetime\u0026#39;\u0026gt;  How strptime() works? The strptime() class method takes two arguments:\n string (that be converted to datetime) format code  Based on the string and format code used, the method returns its equivalent datetime object.\nIn the above example:\nHere,\n %d - Represents the day of the month. Example: 01, 02, \u0026hellip;, 31 %B - Month\u0026rsquo;s name in full. Example: January, February etc. %Y - Year in four digits. Example: 2018, 2019 etc.   Example 2: string to datetime object from datetime import datetime dt_string = \u0026#34;12/11/2018 09:15:32\u0026#34; # Considering date is in dd/mm/yyyy format dt_object1 = datetime.strptime(dt_string, \u0026#34;%d/%m/%Y %H:%M:%S\u0026#34;) print(\u0026#34;dt_object1 =\u0026#34;, dt_object1) # Considering date is in mm/dd/yyyy format dt_object2 = datetime.strptime(dt_string, \u0026#34;%m/%d/%Y %H:%M:%S\u0026#34;) print(\u0026#34;dt_object2 =\u0026#34;, dt_object2) When you run the program, the output will be:\ndt_object1 = 2018-11-12 09:15:32 dt_object2 = 2018-12-11 09:15:32  Format Code List The table below shows all the format codes that you can use.\n   Directive Meaning Example     %a Abbreviated weekday name. Sun, Mon, \u0026hellip;   %A Full weekday name. Sunday, Monday, \u0026hellip;   %w Weekday as a decimal number. 0, 1, \u0026hellip;, 6   %d Day of the month as a zero-padded decimal. 01, 02, \u0026hellip;, 31   %-d Day of the month as a decimal number. 1, 2, \u0026hellip;, 30   %b Abbreviated month name. Jan, Feb, \u0026hellip;, Dec   %B Full month name. January, February, \u0026hellip;   %m Month as a zero-padded decimal number. 01, 02, \u0026hellip;, 12   %-m Month as a decimal number. 1, 2, \u0026hellip;, 12   %y Year without century as a zero-padded decimal number. 00, 01, \u0026hellip;, 99   %-y Year without century as a decimal number. 0, 1, \u0026hellip;, 99   %Y Year with century as a decimal number. 2013, 2019 etc.   %H Hour (24-hour clock) as a zero-padded decimal number. 00, 01, \u0026hellip;, 23   %-H Hour (24-hour clock) as a decimal number. 0, 1, \u0026hellip;, 23   %I Hour (12-hour clock) as a zero-padded decimal number. 01, 02, \u0026hellip;, 12   %-I Hour (12-hour clock) as a decimal number. 1, 2, \u0026hellip; 12   %p Locale’s AM or PM. AM, PM   %M Minute as a zero-padded decimal number. 00, 01, \u0026hellip;, 59   %-M Minute as a decimal number. 0, 1, \u0026hellip;, 59   %S Second as a zero-padded decimal number. 00, 01, \u0026hellip;, 59   %-S Second as a decimal number. 0, 1, \u0026hellip;, 59   %f Microsecond as a decimal number, zero-padded on the left. 000000 - 999999   %z UTC offset in the form +HHMM or -HHMM. nan   %Z Time zone name. nan   %j Day of the year as a zero-padded decimal number. 001, 002, \u0026hellip;, 366   %-j Day of the year as a decimal number. 1, 2, \u0026hellip;, 366   %U Week number of the year (Sunday as the first day of the week). All days in a new year preceding the first Sunday are considered to be in week 0. 00, 01, \u0026hellip;, 53   %W Week number of the year (Monday as the first day of the week). All days in a new year preceding the first Monday are considered to be in week 0. 00, 01, \u0026hellip;, 53   %c Locale’s appropriate date and time representation. Mon Sep 30 07:06:05 2013   %x Locale’s appropriate date representation. 09/30/13   %X Locale’s appropriate time representation. 7:06:05   %% A literal \u0026lsquo;%\u0026rsquo; character. %     ValueError in strptime() If the string (first argument) and the format code (second argument) passed to the strptime() doesn\u0026rsquo;t match, you will get ValueError. For example:\nfrom datetime import datetime date_string = \u0026#34;12/11/2018\u0026#34; date_object = datetime.strptime(date_string, \u0026#34;%d%m %Y\u0026#34;) print(\u0026#34;date_object =\u0026#34;, date_object) If you run this program, you will get an error.\nValueError: time data \u0026#39;12/11/2018\u0026#39; does not match format \u0026#39;%d %m %Y\u0026#39;  Recommended Readings: Python strftime()\n Reference : https://www.programiz.com/python-programming/datetime/strptime\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/date-time/time-delta-striftime/",
	"title": "TimeDelta, Strftime(Format)",
	"tags": [],
	"description": "",
	"content": "In Python, date, time and datetime classes provides a number of function to deal with dates, times and time intervals. Date and datetime are an object in Python, so when you manipulate them, you are actually manipulating objects and not string or timestamps. Whenever you manipulate dates or time, you need to import datetime function.\nThe datetime classes in Python are categorized into main 5 classes.\n date – Manipulate just date ( Month, day, year) time – Time independent of the day (Hour, minute, second, microsecond) datetime – Combination of time and date (Month, day, year, hour, second, microsecond) timedelta— A duration of time used for manipulating dates tzinfo— An abstract class for dealing with time zones  In this tutorial, we will learn-\n How to Use Date \u0026amp; DateTime Class Print Date using date.today() Python Current Date and Time: now() today() How to Format Date and Time Output with Strftime() How to use Timedelta Objects  How to Use Date \u0026amp; DateTime Class Step 1) Before you run the code for datetime, it is important that you import the date time modules as shown in the screenshot below.\n\nThese import statements are pre-defined pieces of functionality in the Python library that let you manipulates dates and times, without writing any code.\nConsider the following points before executing the datetime code\nfrom datetime import date This line tells the Python interpreter that from the datetime module import the date class We are not writing the code for this date functionality alas just importing it for our use\nStep 2) Next, we create an instance of the date object.\n\nStep 3) Next, we print the date and run the code.\n\nThe output is as expected.\nPrint Date using date.today() date.today function has several properties associated with it. We can print individual day/month/year and many other things\nLet\u0026rsquo;s see an example\n\nToday\u0026rsquo;s Weekday Number The date.today() function also gives you the weekday number. Here is the Weekday Table which start with Monday as 0 and Sunday as 6\n   Day WeekDay Number     Monday 0   Tuesday 1   Wednesday 2   Thursday 3   Friday 4   Saturday 5   Sunday 6   Weekday Number is useful for arrays whose index is dependent on the Day of the week.     \nPython Current Date and Time: now() today() Step 1) Like Date Objects, we can also use \u0026ldquo;DATETIME OBJECTS\u0026rdquo; in Python. It gives date along with time in hours, minutes, seconds and milliseconds.\n\nWhen we execute the code for datetime, it gives the output with current date and time.\nStep 2) With \u0026ldquo;DATETIME OBJECT\u0026rdquo;, you can also call time class.\nSuppose we want to print just the current time without the date.\nt = datetime.time(datetime.now())  We had imported the time class. We will be assigning it the current value of time using datetime.now() We are assigning the value of the current time to the variable t.  And this will give me just the time. So let\u0026rsquo;s run this program.\n\nOkay, so you can see that here I got the date and time. And then the next line, I\u0026rsquo;ve got just the time by itself\nStep 3) We will apply our weekday indexer to our weekday\u0026rsquo;s arrayList to know which day is today\n Weekdays operator (wd) is assigned the number from (0-6) number depending on what the current weekday is. Here we declared the array of the list for days (Mon, Tue, Wed…Sun). Use that index value to know which day it is. In our case, it is #2, and it represents Wednesday, so in the output it will print out \u0026ldquo;Which is a Wednesday.\u0026rdquo;  \nHere is the complete code to get current date and time using datetime now\nHere is the complete code to get current date and time using datetime now\nfrom datetime import date from datetime import time from datetime import datetime def main(): ##DATETIME OBJECTS #Get today\u0026#39;s date from datetime class today=datetime.now() #print (today) # Get the current time #t = datetime.time(datetime.now()) #print \u0026#34;The current time is\u0026#34;, t #weekday returns 0 (monday) through 6 (sunday) wd=date.weekday(today) #Days start at 0 for monday days= [\u0026#34;monday\u0026#34;,\u0026#34;tuesday\u0026#34;,\u0026#34;wednesday\u0026#34;,\u0026#34;thursday\u0026#34;,\u0026#34;friday\u0026#34;,\u0026#34;saturday\u0026#34;,\u0026#34;sunday\u0026#34;] print(\u0026#34;Today is day number %d\u0026#34; % wd) print(\u0026#34;which is a \u0026#34; + days[wd]) if __name__== \u0026#34;__main__\u0026#34;: main() How to Format Date and Time Output with Strftime() As of now we have learned, how to use datetime and date object in Python. We will advance a step further and learn how to use a formatting function to format Time and Date.\nStep 1) First we will see a simple step of how to format the year. It is better to understand with an example.\n\n We used the \u0026ldquo;strftime function\u0026rdquo; for formatting. This function uses different control code to give an output. Each control code resembles different parameters like year,month, weekday and date [(%y/%Y – Year), (%a/%A- weekday), (%b/%B- month), (%d - day of month)] . In our case, it is (\u0026quot;%Y\u0026rdquo;) which resembles year, it prints out the full year with the century (e.g., 2018).  Step 2) Now if you replace (\u0026quot;%Y\u0026rdquo;) with lowercase, i.e., ( \u0026ldquo;%y) and execute the code the output will display only (18) and not (2018). The century of the year will not display as shown in the screenshot below\n\nStep 3) Strf function can declare the date, day, month and year separately. Also with small changes in the control code in strftime function you can format the style of the text.\n\nInside the strftime function if you replace (%a) with capital A, i.e., (%A) the output will print out as \u0026ldquo;Firday\u0026rdquo; instead of just an abbreviation \u0026ldquo;Fri\u0026rdquo;.\n\nStep 4) With the help of \u0026ldquo;Strftime\u0026rdquo; function we can also retrieve local system time, date or both.\n %C- indicates the local date and time %x- indicates the local date %X- indicates the local time  \nIn the output, you can see the result as expected\nStep 5) The \u0026ldquo;strftime function\u0026rdquo; allows you to call the time in any format 24 hours or 12 hours.\n\nJust by defining control code like %I/H for hour, % M for minute, %S for second, one can call time for different formats\n12 hours time is declared [print now.strftime(\u0026quot;%I:%M:%S %P) ]\n24 hours time is declared [print now.strftime(\u0026quot;%H:%M\u0026rdquo;)]\nHere is the complete code to convert datetime to String object.\n# #Example file for formatting time and date output # from datetime import datetime def main(): #Times and dates can be formatted using a set of predefined string #Control codes now= datetime.now() #get the current date and time #%c - local date and time, %x-local\u0026#39;s date, %X- local\u0026#39;s time print(now.strftime(\u0026#34;%c\u0026#34;)) print(now.strftime(\u0026#34;%x\u0026#34;)) print(now.strftime(\u0026#34;%X\u0026#34;)) ##### Time Formatting #### #%I/%H - 12/24 Hour, %M - minute, %S - second, %p - local\u0026#39;s AM/PM print(now.strftime(\u0026#34;%I:%M:%S %p\u0026#34;)) # 12-Hour:Minute:Second:AM print(now.strftime(\u0026#34;%H:%M\u0026#34;)) # 24-Hour:Minute if __name__== \u0026#34;__main__\u0026#34;: main() How to use Timedelta Objects With timedelta objects, you can estimate the time for both future and the past. In other words, it is a timespan to predict any special day, date or time.\nRemember this function is not for printing out the time or date, but something to CALCULATE about the future or past. Let\u0026rsquo;s see an example to understand it better.\nStep 1) To run Timedelta Objects, you need to declare the import statement first and then execute the code\n\n Write import statement for timedelta Now write the code to print out object from time delta as shown in screen shot Run the code. The timedelta represents a span of 365 days, 8 hrs and 15 minutes and prints the same  Confusing? Next step will help-\nStep 2) Let\u0026rsquo;s get today\u0026rsquo;s date and time to check whether our import statement is working well. When code is executed, it prints out today\u0026rsquo;s date which means our import statement is working well\n\nStep 3) We will see how we can retrieve date a year from now through delta objects. When we run the code, it gives the output as expected.\n\nStep 4) Another example of how time delta can be used to calculate future date from current date and time\n\nStep 5) Let\u0026rsquo;s look into a more complex example. I would like to determine how many days past the New Year. Here is how we will proceed\n Using today= date.today() we will get todays date We know the newyear is always on 1-Jan, but the year could be different. Using nyd= date(today.year,1,1) we store the new year in variable nyd if nyd \u0026lt; today: compares whether the current date is greater than the new year. If yes, it enters the while loop ((today-nyd).days) gives the difference between a current date and new year in DAYS  \nThe output shows that \u0026ldquo;New Year Day already went by 11 days ago.\u0026rdquo;\nHere is the complete working code\n# # Example file for working with timedelta objects # from datetime import date from datetime import time from datetime import datetime from datetime import timedelta # construct a basic timedelta and print it print (timedelta(days=365, hours=8, minutes=15)) # print today\u0026#39;s date print (\u0026#34;today is: \u0026#34; + str(datetime.now())) # print today\u0026#39;s date one year from now print (\u0026#34;one year from now it will be:\u0026#34; + str(datetime.now() + timedelta(days=365))) # create a timedelta that uses more than one argument # print (in one week and 4 days it will be \u0026#34; + str(datetime.now() + timedelta(weeks=1, days=4))) # How many days until New Year\u0026#39;s Day? today = date.today() # get todays date nyd = date(today.year, 1, 1) # get New Year Day for the same year # use date comparison to see if New Year Day has already gone for this year # if it has, use the replace() function to get the date for next year if nyd \u0026lt; today: print (\u0026#34;New Year day is already went by %ddays ago\u0026#34; % ((today - nyd).days)) Python 2 Example from datetime import date from datetime import time from datetime import datetime def main(): ##DATETIME OBJECTS #Get today\u0026#39;s date from datetime class today=datetime.now() #print today # Get the current time #t = datetime.time(datetime.now()) #print \u0026#34;The current time is\u0026#34;, t #weekday returns 0 (monday) through 6 (sunday) wd = date.weekday(today) #Days start at 0 for monday days= [\u0026#34;monday\u0026#34;,\u0026#34;tuesday\u0026#34;,\u0026#34;wednesday\u0026#34;,\u0026#34;thursday\u0026#34;,\u0026#34;friday\u0026#34;,\u0026#34;saturday\u0026#34;,\u0026#34;sunday\u0026#34;] print \u0026#34;Today is day number %d\u0026#34; % wd print \u0026#34;which is a \u0026#34; + days[wd] if __name__== \u0026#34;__main__\u0026#34;: main() # #Example file for formatting time and date output # from datetime import datetime def main(): #Times and dates can be formatted using a set of predefined string #Control codes now= datetime.now() #get the current date and time #%c - local date and time, %x-local\u0026#39;s date, %X- local\u0026#39;s time print now.strftime(\u0026#34;%c\u0026#34;) print now.strftime(\u0026#34;%x\u0026#34;) print now.strftime(\u0026#34;%X\u0026#34;) ##### Time Formatting ####  #%I/%H - 12/24 Hour, %M - minute, %S - second, %p - local\u0026#39;s AM/PM print now.strftime(\u0026#34;%I:%M:%S %p\u0026#34;) # 12-Hour:Minute:Second:AM print now.strftime(\u0026#34;%H:%M\u0026#34;) # 24-Hour:Minute  if __name__== \u0026#34;__main__\u0026#34;: main() # # Example file for working with timedelta objects # from datetime import date from datetime import time from datetime import datetime from datetime import timedelta # construct a basic timedelta and print it print timedelta(days=365, hours=8, minutes=15) # print today\u0026#39;s date print \u0026#34;today is: \u0026#34; + str(datetime.now()) # print today\u0026#39;s date one year from now print \u0026#34;one year from now it will be:\u0026#34; + str(datetime.now() + timedelta(days=365)) # create a timedelta that uses more than one argument # print \u0026#34;in one week and 4 days it will be \u0026#34; + str(datetime.now() + timedelta(weeks=1, days=4)) # How many days until New Year\u0026#39;s Day? today = date.today() # get todays date nyd = date(today.year, 1, 1) # get New Year Day for the same year # use date comparison to see if New Year Day has already gone for this year # if it has, use the replace() function to get the date for next year if nyd \u0026lt; today: print \u0026#34;New Year day is already went by %ddays ago\u0026#34; % ((today - nyd).days) Summary For manipulating dates and times in both simple and complex ways datetime module supplies different classes or categories like\n date – Manipulate just date ( Month, day, year) time – Time independent of the day (Hour, minute, second, microsecond) datetime – Combination of time and date (Month, day, year, hour, second, microsecond) timedelta— A duration of time used for manipulating dates tzinfo— An abstract class for dealing with timezones  Using datetime objects\n Importing datetime objects before executing the code is mandatory Using date.today function for printing individual date/month/year as well as indexing the day Using date.time object to get time in hours, minutes, seconds and milliseconds  Formatting Time-Out with \u0026ldquo;str f time function\u0026rdquo;\n Use \u0026ldquo;str f time function\u0026rdquo; to change the format of the year Print day, date, month and year separately, Call out time for any format 12 hrs or 24 hrs  Timedelta Objects\n With timedelta objects, you can estimate the time for both future and the past Calculate the total days left for the special day(birthday) from the current time Calculate the total days passed for special day(birthday) from the current time   Source : .\n   "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/advance/",
	"title": "ระดับสูง(Advance)",
	"tags": [],
	"description": "",
	"content": "บทที่ ๒๖: อิเทอเรเตอร์และเจเนอเรเตอร์\n※ yield next\nบทที่ ๒๗: การสร้างคลาสของอิเทอเรเตอร์\n※ iter iter next reversed\nบทที่ ๒๘: ฟังก์ชันบางส่วนที่เกี่ยวข้องกับอิเทอเรเตอร์\n※ zip enumerate itertools\nบทที่ ๒๙: การสร้างฟังก์ชันที่มีความซับซ้อน\n※\nบทที่ ๓๐: รู้จักกับเดคอเรเตอร์\n※ @\nบทที่ ๓๑: ทำความเข้าใจเดคอเรเตอร์มากยิ่งขึ้น\n※ functools.wraps functools.update_wrapper\nบทที่ ๓๒: การตกแต่งคลาสด้วยเดคอเรเตอร์\n※\nบทที่ ๓๓: เมธอดของคลาสและเมธอดสถิต\n※ classmethod staticmethod\nบทที่ ๓๔: การสร้างมอดูล\n※ imp.reload exec eval\nบทที่ ๓๕: การทำมอดูลเป็นแพ็กเกจ\n※\nบทที่ ๓๖: บทส่งท้าย\n※\nเกร็ดเล็กน้อย ⊟ [2016/04/30] สร้างแอตทริบิวต์ที่มีคุณสมบัติพิเศษในคลาสด้วย property\n⊟ [2018/05/31] ข้อควรระวังเมื่อใช้ try และ except แล้วต้องการหยุดโปรแกรมกลางคัน\n⊟ [2019/01/07] วิธีทำให้ import มอดูลที่ต้องการทุกครั้งเมื่อเริ่มโปรแกรม\n⊟ [2019/01/08] วิธีการรันไพธอนโดยตรงใน unix shell ใน mac และ linux\n⊟ [2019/01/12] ข้อควรระวังเมื่อมีการแก้ไขลิสต์ขณะใช้ for อาจทำให้เกิดการวนซ้ำไม่สิ้นสุดได้\n⊟ [2019/06/24] ทำความเข้าใจ and และ or ให้มากขึ้น\n⊟ [2019/07/13] เปรียบเทียบระหว่างการใช้ %, ใช้ format และใช้ f-string ใน python\nการประยุกต์ใช้ \u0026raquo; สารบัญแนะนำมอดูลต่างๆ \u0026raquo; สารบัญการเรียนรู้ของเครื่อง \u0026raquo; สารบัญโครงข่ายประสาทเทียม จิปาถะ ⊟ [2017/02/23] สร้างแฟร็กทัลอย่างง่าย\n⊟ [2018/03/26] ใช้ opencv (cv2) เพื่อค้นหาใบหน้าอนิเมะ\n⊟ [2018/03/29] ค้นหาภาพใบหน้าอนิเมะจากเว็บ safebooru\n⊟ [2018/07/14] สร้างเส้นโค้งฮิลแบร์ทสองมิติ\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/function/lambda_functions/",
	"title": "Anonymous/Lambda Function",
	"tags": [],
	"description": "",
	"content": "In this article, you\u0026rsquo;ll learn about the anonymous function, also known as lambda functions. You\u0026rsquo;ll learn what they are, their syntax and how to use them (with examples).\nWhat are lambda functions in Python? In Python, an anonymous function is a function that is defined without a name.\nWhile normal functions are defined using the def keyword in Python, anonymous functions are defined using the lambda keyword.\nHence, anonymous functions are also called lambda functions.\n How to use lambda Functions in Python? A lambda function in python has the following syntax.\nSyntax of Lambda Function in python lambda arguments: expression\nLambda functions can have any number of arguments but only one expression. The expression is evaluated and returned. Lambda functions can be used wherever function objects are required.\n Example of Lambda Function in python Here is an example of lambda function that doubles the input value.\n# Program to show the use of lambda functions double = lambda x: x * 2 print(double(5)) Output\n10 In the above program, lambda x: x * 2 is the lambda function. Here x is the argument and x * 2 is the expression that gets evaluated and returned.\nThis function has no name. It returns a function object which is assigned to the identifier double. We can now call it as a normal function. The statement\ndouble = lambda x: x * 2 is nearly the same as: def double(x): return x * 2  Use of Lambda Function in python We use lambda functions when we require a nameless function for a short period of time.\nIn Python, we generally use it as an argument to a higher-order function (a function that takes in other functions as arguments). Lambda functions are used along with built-in functions like filter(), map() etc.\nExample use with filter() The filter() function in Python takes in a function and a list as arguments.\nThe function is called with all the items in the list and a new list is returned which contains items for which the function evaluates to True.\nHere is an example use of filter() function to filter out only even numbers from a list.\n# Program to filter out only the even items from a list my_list = [1, 5, 4, 6, 8, 11, 3, 12] new_list = list(filter(lambda x: (x%2 == 0) , my_list)) print(new_list) Output\n[4, 6, 8, 12] Example use with map() The map() function in Python takes in a function and a list.\nThe function is called with all the items in the list and a new list is returned which contains items returned by that function for each item.\nHere is an example use of map() function to double all the items in a list.\n# Program to double each item in a list using map() my_list = [1, 5, 4, 6, 8, 11, 3, 12] new_list = list(map(lambda x: x * 2 , my_list)) print(new_list) Output\n[2, 10, 8, 12, 16, 22, 6, 24]  Reference : https://www.programiz.com/python-programming/anonymous-function\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/data_type/",
	"title": "Data Type",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/datetime/current-datetime/",
	"title": "Get Current Date and Time",
	"tags": [],
	"description": "",
	"content": "In this article, you will learn to get today\u0026rsquo;s date and current date and time in Python. We will also format the date and time in different formats using strftime() method.\nThere are a number of ways you can take to get the current date. We will use the date class of the datetime module to accomplish this task.\n Example 1: Python get today\u0026rsquo;s date from datetime import date today = date.today() print(\u0026#34;Today\u0026#39;s date:\u0026#34;, today) Here, we imported the date class from the datetime module. Then, we used the date.today() method to get the current local date.\nBy the way, date.today() returns a date object, which is assigned to the today variable in the above program. Now, you can use the strftime() method to create a string representing date in different formats.\n Example 2: Current date in different formats from datetime import date today = date.today() # dd/mm/YY d1 = today.strftime(\u0026#34;%d/%m/%Y\u0026#34;) print(\u0026#34;d1 =\u0026#34;, d1) # Textual month, day and year\t d2 = today.strftime(\u0026#34;%B %d, %Y\u0026#34;) print(\u0026#34;d2 =\u0026#34;, d2) # mm/dd/y d3 = today.strftime(\u0026#34;%m/%d/%y\u0026#34;) print(\u0026#34;d3 =\u0026#34;, d3) # Month abbreviation, day and year\t d4 = today.strftime(\u0026#34;%b-%d-%Y\u0026#34;) print(\u0026#34;d4 =\u0026#34;, d4) When you run the program, the output will be something like:\nd1 = 16/09/2019 d2 = September 16, 2019 d3 = 09/16/19 d4 = Sep-16-2019  If you need to get the current date and time, you can use datetime class of the datetime module.\nExample 3: Get the current date and time from datetime import datetime # datetime object containing current date and time now = datetime.now() print(\u0026#34;now =\u0026#34;, now) # dd/mm/YY H:M:S dt_string = now.strftime(\u0026#34;%d/%m/%Y %H:%M:%S\u0026#34;) print(\u0026#34;date and time =\u0026#34;, dt_string)\tHere, we have used datetime.now() to get the current date and time. Then, we used strftime() to create a string representing date and time in another format.\n Reference : https://www.programiz.com/python-programming/datetime/current-datetime\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/beginner/",
	"title": "Python for beginners",
	"tags": [],
	"description": "",
	"content": "Welcome to our Python Tutorial. We’ll cover the basics here and link to more in depth resources along the way. We hope you enjoy the tutorial and walk away with a better understanding of the Python programming language. Let’s get started with our introduction to Python for beginners!\n Download and Install Python Variables Functions Comments Docstrings Escape Characters Numbers Keywords Strings Style Rules Booleans Loops Lists Operators Conditional Statements Exception Handling Dictionaries Modules Taking Input From The User  Download and Install Python Python is a interpreted language which means that the code is translated (interpreted) to binary code while the program runs. That is different from compiled languages (C++ etc.) where the code is first compiled to binary code.\nTo run Python code you need to have a Python interpreter. There are different versions of Python, either Python 2 or Python 3. To see that the difference are and to decide which one to use, please see this wiki page at python.org.\nInstalling Python Python is available on most operating system, (Linux, Unix, Mac OS X and Windows).\nInstalling it on your computer is very easy, and on some systems it’s already there.\nTo see if it’s already installed, open up a terminal and run this command below.\nIf you see a response from a Python interpreter it will include a version number in its initialdisplay.\n\u0026gt;\u0026gt; python Python 2.7.2 (default, Jun 20 2012, 16:23:33) If you don’t have Python installed, you can take a look at this link on how to install it on the platform that you use.\nhttp://www.diveintopython.net/installing_python/index.html\nHow do I run my code? There are two ways to run the programs in Python. Either you type in the code directly in\nthe Python shell. When doing that you will see the result of every command that you type\nin. This works best for very short programs or for testing purpose. The other way to run\nthe code is within a script.\nAdditional Resources\nRecommended Course: Intro to Python\nPython Shell When you are in the Python Shell, the python interpreter will translate all code for you.\nTo leave the help mode and return to the interpreter, we use the quit command.\nThe help command provides some help about Python.\n\u0026gt;\u0026gt;\u0026gt; help Type help() for interactive help, or help(object) for help about object. \u0026gt;\u0026gt;\u0026gt; You can also use the Python Shell for doing math\n(please see my earlier post about using math in Python)\n\u0026gt;\u0026gt;\u0026gt; 2 + 4 6 \u0026gt;\u0026gt;\u0026gt; 5 * 56 280 \u0026gt;\u0026gt;\u0026gt; 5 - 45 -40 \u0026gt;\u0026gt;\u0026gt; To exit the Python Shell, press Ctrl+d.\nPython Script To run the program as script, open an text editor (vi, pico, nano etc.) and put in the\nfollowing code:\n#!/usr/bin/python  print \u0026#34;hello world\u0026#34; Save the file as hello.py and exit the editor.\n# To execute the program, type python and the file name in the shell.  $python hello.py The output should be: hello world Python scripts can be made directly executable, like shell scripts, by putting the shebang\nat the beginning of the script and give the file an executable mode. The shebang is meant\nfor the script to recognize the interpretor type when you want to execute the script from\nthe shell.\n# The script can be given an executable mode, or permission, using the chmod command: $ chmod +x hello.py Now you can execute the script directly by its name.\nLearn More About Installing Python\nVariables In Python, variables are a storage placeholder for texts and numbers.\nIt must have a name so that you are able to find it again.\nThe variable is always assigned with the equal sign, followed by the value of the\nvariable.\nPython is dynamically typed, which means that you don’t have to declare what\ntype each variable is.\nThe variables are being referred in the program to get the value of it.\nThe value of the variable can be changed later on.\nStore the value 10 in a variable named foo\nfoo = 10\nStore the value of foo+10 in a variable named bar\nbar = foo + 10\n#List of some different variable types: x = 123 # integer x = 123L # long integer x = 3.14 # double float x = \u0026#34;hello\u0026#34; # string x = [0,1,2] # list x = (0,1,2) # tuple x = open(‘hello.py’, ‘r’) # file #You can also assign a single value to several variables simultaneously. # variable a,b and c are assigned to the same memory location,with the value of 1 a = b = c = 1 Get Area using Python Variables length = 1.10 width = 2.20 area = length * width print \u0026#34;The area is: \u0026#34; , area This will print out:\nThe area is: 2.42 Learn More About Variables\nFunctions A function is something you can call (possibly with some parameters, the things you put in the parentheses), which performs an action and returns a value.\nFunctions are useful because:\n Reuse code Easy to debug Smaller unit of code(relatively speaking)  Function syntax A function must be defined before it is called. To define a function, use the following syntax:\ndef myFunction(): The above function has no parameters, meaning no values are being passed into the function. To name parameters, use the following syntax.\ndef myFunction(name,age): Now we have a function call that passes in a few parameters. We’ll move onto the body of the function and use those parameters.\ndef myFunction(name,age): print \u0026#39;Name: \u0026#39; + name print \u0026#39;Age: \u0026#39; + age With our function body, the code MUST be indented. The method, when called, would print the name and age passed into it.\nInstead of printing a value, a function can return that value to the program.\ndef myFunction(name,age): return \u0026#39;My name is \u0026#39; + name + \u0026#39; and I am \u0026#39; + age + \u0026#39; years old\u0026#39; \u0026gt;\u0026gt;\u0026gt; myFunction(\u0026#39;John\u0026#39;,\u0026#39;44\u0026#39;): \u0026#39;My name is John and I am 44 years old\u0026#39; Return is the common conclusion of a function as the calling program will typical store its contents into a variable or act on the return value in a conditional statement.\nLearn More About Functions\nComments Comments in Python are used to explain what the code does.\nThey are meant as documentation for anyone reading the code.\nPython is automatically ignoring all text that comes after the “#”\nComments can be in the beginning of the line or at the end of one.\nMultiline comments are possible and are enclosed by triple quotes.\n# First comment print \u0026#34;Hello, Python!\u0026#34;; # second comment #this is a comment in Python \u0026#34;\u0026#34;\u0026#34; This is an example of a multiline comment that spans multiple lines ... \u0026#34;\u0026#34;\u0026#34; Learn More About Comments\nDocstrings Python documentation strings (or docstrings) provide a convenient way of\nassociating documentation with Python modules, functions, classes, and methods.\nAn object’s docsting is defined by including a string constant as the first\nstatement in the object’s definition.\nIt’s specified in source code that is used, like a comment, to document a\nspecific segment of code.\nUnlike conventional source code comments the docstring should describe what the\nfunction does, not how.\nAll functions should have a docstring\nThis allows the program to inspect these comments at run time, for instance as an interactive help system, or as metadata.\nDocstrings can be accessed by the doc attribute on objects.\nHow should a Docstring look like? The doc string line should begin with a capital letter and end with a period.\nThe first line should be a short description.\nDon’t write the name of the object.\nIf there are more lines in the documentation string, the second line should be\nblank, visually separating the summary from the rest of the description.\nThe following lines should be one or more paragraphs describing the object’s\ncalling conventions, its side effects, etc.\nDocstring Example Here is an example of a multi-line docstring:\ndef my_function(): ... \u0026#34;\u0026#34;\u0026#34;Do nothing, but document it. ... ... No, really, it doesn\u0026#39;t do anything. ... \u0026#34;\u0026#34;\u0026#34; ... pass ... Now that we have created our Docstring in the my_function() method, let’s see how it can be useful. Let’s say I’m a new developer in a project and I want to know what my_function() does. See below using the print function.\n\u0026gt;\u0026gt;\u0026gt; print my_function.__doc__ Do nothing, but document it. No, really, it doesn\u0026#39;t do anything. Multiple Docstrings In One Source File The following Python file shows the declaration of docstrings within a python\nsource file. You can clearly see the different levels of docstrings and how they can be used within a single source file.\n\u0026#34;\u0026#34;\u0026#34; Assuming this is file mymodule.py, then this string, being the first statement in the file, will become the \u0026#34;mymodule\u0026#34; module\u0026#39;s docstring when the file is imported. \u0026#34;\u0026#34;\u0026#34; class MyClass(object): \u0026#34;\u0026#34;\u0026#34;The class\u0026#39;s docstring\u0026#34;\u0026#34;\u0026#34; def my_method(self): \u0026#34;\u0026#34;\u0026#34;The method\u0026#39;s docstring\u0026#34;\u0026#34;\u0026#34; def my_function(): \u0026#34;\u0026#34;\u0026#34;The function\u0026#39;s docstring\u0026#34;\u0026#34;\u0026#34; How to access the Docstring Below we show you two methods you can use to access the docstring.\n\u0026gt;\u0026gt;\u0026gt; import mymodule \u0026gt;\u0026gt;\u0026gt; help(mymodule) Assuming this is file mymodule.py then this string, being the first statement in the file will become the mymodule modules docstring when the file is imported \u0026gt;\u0026gt;\u0026gt; help(mymodule.MyClass) The class\u0026#39;s docstring \u0026gt;\u0026gt;\u0026gt; help(mymodule.MyClass.my_method) The method\u0026#39;s docstring \u0026gt;\u0026gt;\u0026gt; help(mymodule.my_function) The function\u0026#39;s docstring Docstrings vs Comments Docstrings and comments are similar in nature, but serve a different purpose. Comments are great for describing lines of code and why they are there. This is very helpful in large code sets.\nDocstrings document what a class, module or package does and most importantly, is available to the help function, whereas, comments are not.\nDocstrings, therefore, can help to document the code programmatically.\nLearn More About Docstring\nEscape Characters Escape characters allow you to do things you normally wouldn’t be able to do following the normal Python syntax rules.\nFor example, you want to print this line in your code with double quotes around the title of the movie, “Titanic”.\n\u0026gt;\u0026gt;\u0026gt; print \u0026#34;Cory\u0026#39;s favorite movie is \u0026#34;Titanic\u0026#34;\u0026#34; SyntaxError: invalid syntax The compiler doesn’t allow you to use double quotes inside double quotes, so you have to “escape” the double quotes from the compiler and allow them to be treated as a string.\nTo do this, you simply add a backslash() before the character you want to escape.\n\u0026gt;\u0026gt;\u0026gt; print \u0026#34;Cory\u0026#39;s favorite movie is \\\u0026#34;Titanic\\\u0026#34;\u0026#34; Cory\u0026#39;s favorite movie is \u0026#34;Titanic\u0026#34; Below is a table of other common escape characters.\n   Escape Character Result     \\’ Single Quote   \\ Backslash   \\b Backspace   \\f Line Feed   \\n New Line   \\r Line Feed   \\t Tab   \\v Vertical Tab    Numbers Python supports 4 types of Numbers, the int, the long, the float and the complex.\nYou don’t have to specify what type of variable you want. Python does that\nautomatically.\n   Int This is the basic integer type in python.     Long This is a integer number that’s length is non-limited.   Float This is a binary floating point number.   Complex This is a complex number consisting of two floats.    Converting Numbers You can simply convert them, like this:\n\u0026gt;\u0026gt;\u0026gt; float(3) 3.0 \u0026gt;\u0026gt;\u0026gt; int(4.123) 4 Using Python interpreter as a calculator You can use the interpreter to do math with numbers.\n\u0026gt;\u0026gt;\u0026gt; 2 + 2 4 \u0026gt;\u0026gt;\u0026gt; 4 * 2 8 \u0026gt;\u0026gt;\u0026gt; 10 / 2 5 \u0026gt;\u0026gt;\u0026gt; 10 - 2 8 Keywords Keywords in Python are reserved words that cannot be used as ordinary identifiers. They must be spelled exactly as they are written.\nList of keywords The following is a list of keywords for the Python programming language.\n   and del from not     while as elif global   or with assert else   if pass yield break   except import print class   exec in raise continue   finally is return def   for lambda try nan    Strings A string is a list of characters in order. A character is anything you can type on the keyboard in one keystroke, like a letter, a number, or a backslash.\nAdditional Resources\nRecommended Course: Intro to Python\nStrings can have spaces: “hello world”. An empty string is a string that has 0 characters. Python strings are immutable, which means they can’t change. String syntax is recognized by anything between ” ” or ‘ ‘. Much like Lists, Strings have functions that can work on their value.\nString Functions Changing Case\nstring.lower() # lower case the string string.upper() # upper case the string string.title() # upper case the first letters Replace\nstring.replace(“This”,”That”) # will replace the text “This” with “That”\nSplit\nSplit will split a string into an array based on the delimiter passed into the function.\nx = \u0026#39;1,2,3\u0026#39; x.split(\u0026#34;,\u0026#34;) [\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;] There are many more string functions available. See our Learn More About Strings section.\nString Concatenation In Python there are a few different ways to concatenating strings. Concatenation combines two (or more) strings into a new string object.\nYou can use the + operator, like this:\nprint \u0026#34;You can concatenate two \u0026#34; + \u0026#34;strings with the \u0026#39;+\u0026#39; operator.\u0026#34; str1 = \u0026#34;Hello\u0026#34; str2 = \u0026#34;World\u0026#34; str1 + str2 # concatenation: a new string # String literals may be concatenated by a space word = \u0026#39;left\u0026#39; \u0026#34;right\u0026#34; \u0026#39;left\u0026#39; # Any string expression may be concatenated by a + word = wordA + \u0026#34; \u0026#34; + wordB Learn More About Strings\nStyle Rules A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is most important.\nAn example of this would be:\nSemicolons Do not terminate your lines with semi-colons and do not use semi-colons to put\ntwo commands on the same line.\nLine length Maximum line length is 80 characters.\nParentheses Use parentheses sparingly.\nIndentation Indent your code blocks with 4 spaces.\nLearn More About Style Rules\nBooleans The built-in type Boolean can hold only one of two possible objects: True or False\nBoolean Values Boolean values respond to logical operators and / or. The examples below show how multiple boolean values act together with differing operators.\n\u0026gt;\u0026gt;\u0026gt; True and False False \u0026gt;\u0026gt;\u0026gt; True and True True \u0026gt;\u0026gt;\u0026gt; False and True False \u0026gt;\u0026gt;\u0026gt; False or True True \u0026gt;\u0026gt;\u0026gt; False or False False Learn More About Booleans\nLoops Programming languages need a way to repeat the same sequence, this is called Iteration. Loops in programming allow us to iterate over elements in severals ways.\nFor Loops For loops allows us to iterate over elements of a sequence, it is often used when you have a piece of code which you want to repeat “n” number of time.\nIt works like this:\nLet’s say that you have a list of browsers like below. That reads, for every element that we assign the variable browser, in the list browsers, print out the variable browser\n\u0026gt;\u0026gt;\u0026gt; browsers = [\u0026#34;Safari\u0026#34;,\u0026#34;Firefox\u0026#34;,\u0026#34;Chrome\u0026#34;] \u0026gt;\u0026gt;\u0026gt; for browser in browsers: ... print browser ... Safari Firefox Chrome While Loops The while loop tells the computer to do something as long as the condition is met It’s construct consists of a block of code and a condition.\nThe loop will continue WHILE the condition met is true. Once it is false, the loop will exit.\nbrowsers = [\u0026#34;Safari\u0026#34;, \u0026#34;Firefox\u0026#34;, \u0026#34;Google Chrome\u0026#34;, \u0026#34;Opera\u0026#34;, \u0026#34;IE\u0026#34;] i = 0 while i \u0026lt; len(browsers): print browsers[i] #add 1 to i each iteration so that we exit once we reach the total number of browsers i = i + 1 Eternal Loops You typically want to avoid Eternal loops as they will never end until all system resources are consumed or the program is killed externally.\nAn example of an eternal loop.\nwhile True: print \u0026#34;Hello World\u0026#34; Typically eternal loops aren\u0026rsquo;t this obvious and usually involves inadvertently updating a variable that is being used as a counter.\nContinue The continue statement is used to tell Python to skip the rest of the statements in the current loop block and to continue to the next iteration of the loop.\nThis is typically used when a certain condition is met that makes it unnecessary to execute the remaining block.\nfor i in range(1,10): if i == 3: # don\u0026#39;t print 3\u0026#39;s, I hate 3\u0026#39;s, but keeping printing continue print i Break Break statements allow you to exit the loop if a condition is met. This is different from the Continue statement where the loop will continue.\nfor i in range(1,10): if i == 3: # 3\u0026#39;s are so bad that I can\u0026#39;t continue this loop any longer break print i Pass The pass statement does nothing. It can be used when a statement is required syntactically but the program requires no action.\n\u0026gt;\u0026gt;\u0026gt; while True: ... pass # Busy-wait for keyboard interrupt ... Learn More About Loops\nLists Lists in Python are a collection of items, such as Strings, Integers or other Lists. Lists are enclosed in [ ] with each item separated by commas. Lists, unlike Strings are mutable, which means they can be changed.\nList Examples emptyList = [] bourbonList = [\u0026#39;jeffersons\u0026#39;,\u0026#39;woodford reserve\u0026#39;,\u0026#39;maker\u0026#39;s mark\u0026#39;] numList = [1,2,3,4] List Functions While you can use other function against a list, like len to get the length of a list\nlen(bourbonList) \u0026gt;\u0026gt;\u0026gt; 3 Lists has its own set of methods.\nAppend will add an element to the end of a list.\nbourbonList.append(\u0026#34;Jack Daniels\u0026#34;) print bourbonList \u0026gt;\u0026gt;\u0026gt; [\u0026#39;jeffersons\u0026#39;,\u0026#39;woodford reserve\u0026#39;,\u0026#39;maker\u0026#39;s mark\u0026#39;,\u0026#39;Jack Daniels\u0026#39;] Here are more List functions and their purpose\n   Function Description     Insert(x,y) Inserts an item(x) into an array after (y)   Remove(x) Removes (x) on a match   Extend(list) Adds another list to the calling list   Delete(1) Deletes an item based on the index passed in    Operators Comparison operators    Operator Description Example     \u0026lt; less than x \u0026lt; 10   \u0026lt;= less than or equal to x \u0026lt;= 10   \u0026gt; greater than x \u0026gt; 10   \u0026gt;= greater than or equal to x \u0026gt;= 10   == equality x == 10   != inequality (also \u0026lt;\u0026gt;) x != 10    Logical operators    Operator Description Example     not logical notation not b   and logical and (x \u0026lt;= 10) and (y == True)   or logical or (x \u0026lt; 10) or (y \u0026gt; 100.1)    Conditional Statements In programming, very often we want to check the conditions and change the behavior of the program. We can write programs that has more than one choice of actions depending on a\nvariable\u0026rsquo;s value.\nPerhaps the most well-known statement type is the if statement.\nYou use the if statement to perform one action if one thing is true, or any number of other actions, if something else is true.\nWe must use indentation to define that code that is executed, based on whether acondition is met.\nTo compare data in Python we can use the comparison operators, find in this post\nIf Statement The syntax of the if statement is: if expression: statement(s) Elif Statement Sometimes there are more than two possibilities, in that case we can use the elif statement\nIt stands for \u0026ldquo;else if,\u0026rdquo; which means that if the original if statement is false\nand the elif statement is true, execute the block of code following the elif statement.\nThe syntax of the if…elif statement is:\nif expression1: statement(s) elif expression2: statement(s) elif expression3: statement(s) else: statement(s) Else Statement An else statement can be combined with an if statement.\nAn else statement contains the block of code that executes if the conditional\nexpression in the if statement resolves to 0 or a false value.\nThe else statement is an optional statement and there could be at most only one\nelse statement following if.\nThe syntax of if..else is:\nif expression: statement(s) else: statement(s) Examples This script will compare two strings based on the input from the user.\n# This program compares two strings. # Get a password from the user. password = raw_input(\u0026#39;Enter the password: \u0026#39;) # Determine whether the correct password # was entered. if password == \u0026#39;hello\u0026#39;: print\u0026#39;Password Accepted\u0026#39; else: print\u0026#39;Sorry, that is the wrong password.\u0026#39; Another Example Let\u0026rsquo;s show one more example that makes use of the elif statement.\n#!/usr/bin/python number = 20 guess = int(input(\u0026#39;Enter an integer : \u0026#39;)) if guess == number: print(\u0026#39;Congratulations, you guessed it.\u0026#39;) elif guess \u0026lt; number: print(\u0026#39;No, it is a little higher than that\u0026#39;) else: print(\u0026#39;No, it is a little lower than that\u0026#39;) Learn More About Conditional Statements\nException Handling When an error occurs in a Python program, Python generates an Exception. Why? So that it can be handled gracefully without breaking the program or causing issues with user interaction.\nException Examples IOError\nIf the file cannot be opened.\nImportError\nIf python cannot find the module\nValueError\nRaised when a built-in operation or function receives an argument that has the\nright type but an inappropriate value\nKeyboardInterrupt\nRaised when the user hits the interrupt key (normally Control-C or Delete)\nEOFError\nRaised when one of the built-in functions (input() or raw_input()) hits an\nend-of-file condition (EOF) without reading any data\nHandling Exceptions To handle exceptions you need to use the catch-all except clause. This involves using the \u0026ldquo;try\u0026rdquo; and \u0026ldquo;except\u0026rdquo; Python keywords.\nSimply put, you wrap the executing code in a \u0026ldquo;try\u0026rdquo; block and if any exception occurs, you catch it and handle it accordingly.\nAn example in pseudo code:\ntry: some statements here except: exception handling Let\u0026rsquo;s see a short example on how to do this:\ntry: print 1/0 except ZeroDivisionError: print \u0026#34;You can\u0026#39;t divide by zero, you\u0026#39;re silly.\u0026#34; Dictionaries Dictionary is another data type in Python.\nDictionaries are collections of items that have a “key” and a “value”.\nPython dictionaries are also known as associative arrays or hash tables.\nThey are just like lists, except instead of having an assigned index number,\nyou make up the index.\nCreate a Dictionary # This is a list myList = [\u0026#34;first\u0026#34;,\u0026#34;second\u0026#34;,\u0026#34;third\u0026#34;] # This is a dictionary myDictionary = {0:\u0026#34;first\u0026#34;,1:\u0026#34;second\u0026#34;,2:\u0026#34;third\u0026#34;} Accessing / Getting values To access dictionary elements, you can use the square brackets along with the key\nto obtain its value.\ndata = {\u0026#39;Name\u0026#39;:\u0026#39;Zara\u0026#39;,\u0026#39;Age\u0026#39;:7,\u0026#39;Class\u0026#39;:\u0026#39;First\u0026#39;}; # Get all keys data.keys() # Get all values data.values() # Print key1 print data[\u0026#39;Name\u0026#39;] # Prints 7 print data[\u0026#39;Age\u0026#39;] # Prints name and age print \u0026#39;Name\u0026#39;, data[\u0026#39;Name\u0026#39;]; print \u0026#39;Age\u0026#39;, data[\u0026#39;Age\u0026#39;]; Looping through a Dictionary You can use a for loop to iterate Dictionary items.\ndata = { \u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39; } for key, value in data.items(): print key,value Looping their values directory (not in order) for value in data.values(): print value There are many more operations you can perform on a Dictionary, like add, clear, delete, list all keys, list all values, test if a key exists, etc. You can learn more about these features by reviewing the articles in Learn More About Dictionaries.\nLearn More About Dictionaries\nModules Python modules makes the programming a lot easier. It’s basically a file that consist of already written code. When Python imports a module, it first checks the module registry (sys.modules) to see if the module is already imported. If that’s the case, Python uses the existing module object as is. There are different ways to import a module.\nImporting Modules import sys #access module, after this you can use sys.name to refer to things defined in module sys. from sys import stdout # access module without qualiying name.  This reads from the module \u0026#34;sys\u0026#34; import \u0026#34;stdout\u0026#34;, so that we would be able to refer \u0026#34;stdout\u0026#34;in our program. from sys import * # access all functions/classes in the sys module.  Python Standard Library URL: http://docs.python.org/library/index.html Collection of of modules that are already on the system, there is no need to install them. Just import the modules you want to use. Search for a module: http://docs.python.org/py-modindex.html\nPython Package Index URL: http://pypi.python.org/pypi Created by community members. It\u0026rsquo;s a repository of software containing more than 2400 packages\nMath Module The math module provides access to mathematical constants and functions.\nimport math math.pi #Pi, 3.14... math.e #Euler\u0026#39;s number, 2.71... math.degrees(2) #2 radians = 114.59 degreees math.radians(60) #60 degrees = 1.04 radians math.sin(2) #Sine of 2 radians math.cos(0.5) #Cosine of 0.5 radians math.tan(0.23) #Tangent of 0.23 radians math.factorial(5) #1 * 2 * 3 * 4 * 5 = 120 math.sqrt(49) #Square root of 49 = 7 Requests Module The Requests module is a an elegant and simple HTTP library for Python that allows you to send HTTP/1.1 requests.\nTo install requests, simply:\n$ pip install requests\nOr, if you absolutely must:\n$ easy_install requests\nTo create a Request object, simply call a URL using the following syntax.\n\u0026gt;\u0026gt;\u0026gt; r = requests.get(\u0026#39;https://github.com/timeline.json\u0026#39;) To operate on the object, you have many choices. Here is one example to check the http status code.\n\u0026gt;\u0026gt;\u0026gt; r = requests.get(\u0026#39;https://github.com/timeline.json\u0026#39;) \u0026gt;\u0026gt;\u0026gt; r.status_code 200 Learn More About Modules\nAdditional Resources\nRecommended Course: Intro to Python\nTaking User Input There are two functions in Python that you can use to read data from the user:\nraw_input and input\nYou can store the results from them into a variable.\nraw_input is used to read text (strings) from the user:\n#Ask the user to input a name, and store it in the variable name name = raw_input(\u0026#34;What is your name? \u0026#34;) type(name) #Create a new string with a greeting greet = \u0026#39;hello \u0026#39; + name input is used to read integers\nage = input(\u0026#34;What is your age? \u0026#34;) print \u0026#34;Your age is: \u0026#34;, age type(age) #Ask the user to input a number, and store it in the variable foo foo = int(raw input(\u0026#39;enter a number: \u0026#39;)) Learn More About Taking User Input\nSources http://www.python.org/\nhttp://www.tutorialspoint.com/python/index.htm\nhttp://loris.som.jhmi.edu/python_course/basic_syntax.html\n Reference : https://www.pythonforbeginners.com/python-tutorial\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/data_type/string/",
	"title": "Python: String",
	"tags": [],
	"description": "",
	"content": "In this tutorial you will learn to create, format, modify and delete strings in Python. Also, you will be introduced to various string operations and functions.\nWhat is String in Python? A string is a sequence of characters.\nA character is simply a symbol. For example, the English language has 26 characters. Computers do not deal with characters, they deal with numbers (binary). Even though you may see characters on your screen, internally it is stored and manipulated as a combination of 0s and 1s. This conversion of character to a number is called encoding, and the reverse process is decoding. ASCII and Unicode are some of the popular encodings used. In Python, a string is a sequence of Unicode characters. Unicode was introduced to include every character in all languages and bring uniformity in encoding. You can learn about Unicode from Python Unicode.\n How to create a string in Python? Strings can be created by enclosing characters inside a single quote or double-quotes. Even triple quotes can be used in Python but generally used to represent multiline strings and docstrings.\n# defining strings in Python # all of the following are equivalent my_string = \u0026#39;Hello\u0026#39; print(my_string) my_string = \u0026#34;Hello\u0026#34; print(my_string) my_string = \u0026#39;\u0026#39;\u0026#39;Hello\u0026#39;\u0026#39;\u0026#39; print(my_string) # triple quotes string can extend multiple lines my_string = \u0026#34;\u0026#34;\u0026#34;Hello, welcome to the world of Python\u0026#34;\u0026#34;\u0026#34; print(my_string) When you run the program, the output will be:\nHello Hello Hello Hello, welcome to the world of Python  How to access characters in a string? We can access individual characters using indexing and a range of characters using slicing. Index starts from 0. Trying to access a character out of index range will raise an IndexError. The index must be an integer. We can\u0026rsquo;t use floats or other types, this will result into TypeError.\nPython allows negative indexing for its sequences.\nThe index of -1 refers to the last item, -2 to the second last item and so on. We can access a range of items in a string by using the slicing operator :(colon).\n#Accessing string characters in Python str = \u0026#39;programiz\u0026#39; print(\u0026#39;str = \u0026#39;, str) #first character print(\u0026#39;str[0] = \u0026#39;, str[0]) #last character print(\u0026#39;str[-1] = \u0026#39;, str[-1]) #slicing 2nd to 5th character print(\u0026#39;str[1:5] = \u0026#39;, str[1:5]) #slicing 6th to 2nd last character print(\u0026#39;str[5:-2] = \u0026#39;, str[5:-2]) When we run the above program, we get the following output:\nstr = programiz str[0] = p str[-1] = z str[1:5] = rogr str[5:-2] = am If we try to access an index out of the range or use numbers other than an integer, we will get errors.\n# index must be in range my_string[15] ... IndexError: string index out of range # index must be an integer my_string[1.5] ... TypeError: string indices must be integers Slicing can be best visualized by considering the index to be between the elements as shown below. If we want to access a range, we need the index that will slice the portion from the string. String Slicing in Python\n How to change or delete a string? Strings are immutable. This means that elements of a string cannot be changed once they have been assigned. We can simply reassign different strings to the same name.\nmy_string = \u0026#39;programiz\u0026#39; my_string[5] = \u0026#39;a\u0026#39; ... TypeError: \u0026#39;str\u0026#39; object does not support item assignment my_string = \u0026#39;Python\u0026#39; my_string \u0026#39;Python\u0026#39; We cannot delete or remove characters from a string. But deleting the string entirely is possible using the del keyword.\ndel my_string[1] ... TypeError: \u0026#39;str\u0026#39; object doesn\u0026#39;t support item deletion del my_string my_string ... NameError: name \u0026#39;my_string\u0026#39; is not defined  Python String Operations There are many operations that can be performed with strings which makes it one of the most used data types in Python.\nTo learn more about the data types available in Python visit: Python Data Types\nConcatenation of Two or More Strings Joining of two or more strings into a single one is called concatenation.\nThe + operator does this in Python. Simply writing two string literals together also concatenates them.\nThe ***** operator can be used to repeat the string for a given number of times.\n# Python String Operations str1 = \u0026#39;Hello\u0026#39; str2 =\u0026#39;World!\u0026#39; # using + print(\u0026#39;str1 + str2 = \u0026#39;, str1 + str2) # using * print(\u0026#39;str1 * 3 =\u0026#39;, str1 * 3) When we run the above program, we get the following output:\nstr1 + str2 = HelloWorld! str1 * 3 = HelloHelloHello Writing two string literals together also concatenates them like + operator.\nIf we want to concatenate strings in different lines, we can use parentheses.\n# two string literals together \u0026#39;Hello \u0026#39;\u0026#39;World!\u0026#39; \u0026#39;Hello World!\u0026#39; # using parentheses s = (\u0026#39;Hello \u0026#39; ... \u0026#39;World\u0026#39;) s \u0026#39;Hello World\u0026#39;  Iterating Through a string We can iterate through a string using a for loop. Here is an example to count the number of \u0026lsquo;l\u0026rsquo;s in a string.\n# Iterating through a string count = 0 for letter in \u0026#39;Hello World\u0026#39;: if(letter == \u0026#39;l\u0026#39;): count += 1 print(count,\u0026#39;letters found\u0026#39;) When we run the above program, we get the following output:\n3 letters found  String Membership Test We can test if a substring exists within a string or not, using the keyword in.\n\u0026#39;a\u0026#39; in \u0026#39;program\u0026#39; True \u0026#39;at\u0026#39; not in \u0026#39;battle\u0026#39; False  Built-in functions to Work with Python Various built-in functions that work with sequence work with strings as well.\nSome of the commonly used ones are enumerate() and len(). The enumerate() function returns an enumerate object. It contains the index and value of all the items in the string as pairs. This can be useful for iteration.\nSimilarly, len() returns the length (number of characters) of the string.\nstr = \u0026#39;cold\u0026#39; # enumerate() list_enumerate = list(enumerate(str)) print(\u0026#39;list(enumerate(str) = \u0026#39;, list_enumerate) #character count print(\u0026#39;len(str) = \u0026#39;, len(str)) When we run the above program, we get the following output:\nlist(enumerate(str) = [(0, \u0026#39;c\u0026#39;), (1, \u0026#39;o\u0026#39;), (2, \u0026#39;l\u0026#39;), (3, \u0026#39;d\u0026#39;)] len(str) = 4  Python String Formatting Escape Sequence If we want to print a text like He said, \u0026ldquo;What\u0026rsquo;s there?\u0026rdquo;, we can neither use single quotes nor double quotes. This will result in a SyntaxError as the text itself contains both single and double quotes.\nprint(\u0026#34;He said, \u0026#34;What\u0026#39;s there?\u0026#34;\u0026#34;) ... SyntaxError: invalid syntax print(\u0026#39;He said, \u0026#34;What\u0026#39;s there?\u0026#34;\u0026#39;) ... SyntaxError: invalid syntax One way to get around this problem is to use triple quotes. Alternatively, we can use escape sequences.\nAn escape sequence starts with a backslash and is interpreted differently. If we use a single quote to represent a string, all the single quotes inside the string must be escaped. Similar is the case with double quotes. Here is how it can be done to represent the above text.\n# using triple quotes print(\u0026#39;\u0026#39;\u0026#39;He said, \u0026#34;What\u0026#39;s there?\u0026#34;\u0026#39;\u0026#39;\u0026#39;) # escaping single quotes print(\u0026#39;He said, \u0026#34;What\\\u0026#39;s there?\u0026#34;\u0026#39;) # escaping double quotes print(\u0026#34;He said, \\\u0026#34;What\u0026#39;s there?\\\u0026#34;\u0026#34;) When we run the above program, we get the following output:\nHe said, \u0026#34;What\u0026#39;s there?\u0026#34; He said, \u0026#34;What\u0026#39;s there?\u0026#34; He said, \u0026#34;What\u0026#39;s there?\u0026#34; Here is a list of all the escape sequences supported by Python.\n   Escape Sequence Description     \\newline Backslash and newline ignored   \\ Backslash   ' Single quote   \u0026quot; Double quote   \\a ASCII Bell   \\b ASCII Backspace   \\f ASCII Formfeed   \\n ASCII Linefeed   \\r ASCII Carriage Return   \\t ASCII Horizontal Tab   \\v ASCII Vertical Tab   \\ooo Character with octal value ooo   \\xHH Character with hexadecimal value HH    Here are some examples\nprint(\u0026#34;C:\\\\Python32\\\\Lib\u0026#34;) # C:\\Python32\\Lib print(\u0026#34;This is printed\\nin two lines\u0026#34;) #This is printed # in two lines print(\u0026#34;This is \\x48\\x45\\x58representation\u0026#34;) # This is HEX representation  Raw String to ignore escape sequence Sometimes we may wish to ignore the escape sequences inside a string. To do this we can place r or R in front of the string. This will imply that it is a raw string and any escape sequence inside it will be ignored.\nprint(\u0026#34;This is \\x61\\ngood example\u0026#34;) This is a good example print(r\u0026#34;This is \\x61 \\ngood example\u0026#34;) This is \\x61 \\ngood example  The format() Method for Formatting Strings The format() method that is available with the string object is very versatile and powerful in formatting strings. Format strings contain curly braces {} as placeholders or replacement fields which get replaced.\nWe can use positional arguments or keyword arguments to specify the order.\n# Python string format() method # default(implicit) order default_order = \u0026#34;{}, {} and {}\u0026#34;.format(\u0026#39;John\u0026#39;,\u0026#39;Bill\u0026#39;,\u0026#39;Sean\u0026#39;) print(\u0026#39;\\n--- Default Order ---\u0026#39;) print(default_order) # order using positional argument positional_order = \u0026#34;{1}, {0} and {2}\u0026#34;.format(\u0026#39;John\u0026#39;,\u0026#39;Bill\u0026#39;,\u0026#39;Sean\u0026#39;) print(\u0026#39;\\n--- Positional Order ---\u0026#39;) print(positional_order) # order using keyword argument keyword_order = \u0026#34;{s}, {b} and {j}\u0026#34;.format(j=\u0026#39;John\u0026#39;,b=\u0026#39;Bill\u0026#39;,s=\u0026#39;Sean\u0026#39;) print(\u0026#39;\\n--- Keyword Order ---\u0026#39;) print(keyword_order) When we run the above program, we get the following output:\n--- Default Order --- John, Bill and Sean --- Positional Order --- Bill, John and Sean --- Keyword Order --- Sean, Bill and John The format() method can have optional format specifications. They are separated from the field name using colon. For example, we can left-justify \u0026lt;, right-justify \u0026gt; or center ^ a string in the given space.\nWe can also format integers as binary, hexadecimal, etc. and floats can be rounded or displayed in the exponent format. There are tons of formatting you can use. Visit here for all the string formatting available with the [format()](https://www.programiz.com/python-programming/methods/string/format) method.\n# formatting integers \u0026#34;Binary representation of {0} is {0:b}\u0026#34;.format(12) \u0026#39;Binary representation of 12 is 1100\u0026#39; # formatting floats \u0026#34;Exponent representation: {0:e}\u0026#34;.format(1566.345) \u0026#39;Exponent representation: 1.566345e+03\u0026#39; # round off \u0026#34;One third is: {0:.3f}\u0026#34;.format(1/3) \u0026#39;One third is: 0.333\u0026#39; # string alignment \u0026#34;|{:\u0026lt;10}|{:^10}|{:\u0026gt;10}|\u0026#34;.format(\u0026#39;butter\u0026#39;,\u0026#39;bread\u0026#39;,\u0026#39;ham\u0026#39;) \u0026#39;|butter | bread | ham|\u0026#39;  Old style formatting We can even format strings like the old sprintf() style used in C programming language. We use the % operator to accomplish this.\nx = 12.3456789 print(\u0026#39;The value of x is %3.2f\u0026#39; %x) The value of x is 12.35 print(\u0026#39;The value of x is %3.4f\u0026#39; %x) The value of x is 12.3457  Common Python String Methods There are numerous methods available with the string object. The format() method that we mentioned above is one of them. Some of the commonly used methods are lower(), upper(), join(), split(), find(), replace() etc. Here is a complete list of all the built-in methods to work with strings in Python.\n\u0026#34;PrOgRaMiZ\u0026#34;.lower() \u0026#39;programiz\u0026#39; \u0026#34;PrOgRaMiZ\u0026#34;.upper() \u0026#39;PROGRAMIZ\u0026#39; \u0026#34;This will split all words into a list\u0026#34;.split() [\u0026#39;This\u0026#39;, \u0026#39;will\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;all\u0026#39;, \u0026#39;words\u0026#39;, \u0026#39;into\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;list\u0026#39;] \u0026#39; \u0026#39;.join([\u0026#39;This\u0026#39;, \u0026#39;will\u0026#39;, \u0026#39;join\u0026#39;, \u0026#39;all\u0026#39;, \u0026#39;words\u0026#39;, \u0026#39;into\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;string\u0026#39;]) \u0026#39;This will join all words into a string\u0026#39; \u0026#39;Happy New Year\u0026#39;.find(\u0026#39;ew\u0026#39;) 7 \u0026#39;Happy New Year\u0026#39;.replace(\u0026#39;Happy\u0026#39;,\u0026#39;Brilliant\u0026#39;) \u0026#39;Brilliant New Year\u0026#39;  Source : https://www.programiz.com/python-programming/string\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/pandas/tutorial-geeksforgeeks/selection/",
	"title": "Selection",
	"tags": [],
	"description": "",
	"content": " Dealing with Rows and Columns in Pandas DataFrame How to select multiple columns in a pandas dataframe Python | Pandas Extracting rows using .loc[] Python | Extracting rows using Pandas .iloc[] Indexing and Selecting Data with Pandas Boolean Indexing in Pandas Label and Integer based slicing technique using DataFrame.ix  "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/beginer/basic_functin/",
	"title": "ฟังก์ชันพื้นฐาน",
	"tags": [],
	"description": "",
	"content": "ความหมายของฟังก์ชัน คำว่าฟังก์ชัน (function) เป็นคำที่น่าจะเคยได้ยินอยู่บ่อยๆ แต่คำนี้จริงๆมีความหมายอยู่หลากหลายมาก ขึ้นอยู่กับว่าคุยกันเรื่องอะไร\nหลายคนอาจเคยได้ยินคำนี้ครั้งแรกกันตอนเรียนคณิตศาสตร์ชั้นมัธยมศึกษา\nคำว่าฟังก์ชันในทางคณิตศาสตร์หมายถึงสิ่งที่แสดงความสัมพันธ์ระหว่างจำนวน โดยใส่ค่าตัวเลขลงไปจำนวนหนึ่ง แล้วจะได้ค่าตัวเลขอีกจำนวนหนึ่งคืนกลับมา เช่น\nf(x) = (x+0.5)/10 ในที่นี้ f เป็นฟังก์ชัน และ x คืออาร์กิวเมนต์ของฟังก์ชัน อาร์กิวเมนต์ คือค่าที่อยู่ในวงเล็บหลังฟังก์ชัน เป็นค่าที่ป้อนให้กับฟังก์ชัน เพื่อให้ฟังก์ชัน นำค่านั้นไปดำเนินการทำอะไรบางอย่าง ในที่นี้หากป้อนค่า x เป็น 0.5 ค่านี้ก็จะถูกนำไปคำนวณ\nf(0.5) = (0.5+0.5)/10 = 0.1 ผลที่ได้คือฟังก์ชันนี้คืน 0.1 ออกมา ค่า 0.1 นี้จะเรียกว่าค่าคืนกลับ (return)\nฟังก์ชันในทางภาษาคอมพิวเตอร์ ก็มีลักษณะคล้ายกันนี้ คือใส่ค่าอะไรบางอย่าง (อาร์กิวเมนต์) ลงไปแล้วก็จะมีค่าคืนกลับออกมา\nในบทที่แล้วได้พูดถึงคำสั่ง int float str bool ซึ่งใช้แปลงชนิดของข้อมูลเพื่อให้เป็นชนิดตามนั้น โดยใส่ข้อมูลชนิดเก่าลงไปแล้วได้ค่าคืนกลับเป็นข้อมูลชนิดใหม่ เช่น\na = 1.111 b = int(a) print(b) # ได้ 1 ในตัวอย่างนี้ a เป็นจำนวนจริงซึ่งมีเลขทศนิยม แต่ใช้คำสั่ง int เพื่อแปลงเป็นจำนวนเต็มแล้วคืนค่ากลับมาแล้วเก็บค่าไว้ใน b ผลก็คือ b ได้ค่าเป็น 1 โดยเศษถูกปัดทิ้งหมด คำสั่งที่ใช้แปลงชนิดข้อมูลเหล่านี้ถือว่าเป็นฟังก์ชันชนิดหนึ่งในภาษาไพธอน\nที่จริงหากว่ากันในรายละเอียดจริงๆแล้ว int float str bool เป็นชื่อคลาส (ชื่อชนิดข้อมูล) อย่างไรก็ตามชื่อคลาสสามารถใช้ทำหน้าที่เหมือนเป็นฟังก์ชันเพื่อสร้างออบเจกต์ในคลาสนั้นอยู่แล้ว จึงถือว่าเป็นฟังก์ชันด้วย หรืออีกตัวอย่างหนึ่งคือฟังก์ชันที่ชือว่า len ซึ่งมีไว้สำหรับหาความยาวของสายอักขระ\nlen(\u0026#39;sawatdi\u0026#39;) # ได้ 7 ในที่นี้ \u0026lsquo;sawatdi\u0026rsquo; เป็นอาร์กิวเมนต์ของฟังก์ชัน len แล้ว 7 เป็นค่าคืนกลับที่ได้มา อย่างไรก็ตามฟังก์ชัน ในภาษาคอมพิวเตอร์นั้น นอกจากจะมีหน้าที่คืนค่ากลับมาแล้วก็ยัง มีอีกหน้าที่ที่สำคัญ นั่นคือดำเนินการบางอย่างให้เกิดผลอะไรบางอย่างขึ้น โดยอาจจะไม่มีการคืนค่ากลับมาเลยก็ได้ เช่นคำสั่ง print ซึ่งใช้มาตั้งแต่บทที่ ๒ แล้ว ก็ถือเป็นฟังก์ชันชนิดหนึ่ง ซึ่งกรณีของ print นั้น อาร์กิวเมนต์ที่ใส่เข้าไปคือสิ่งที่เราต้องการให้แสดงผลออกมา เช่น\nprint(\u0026#39;sawatdi\u0026#39;) ในที่นี้ \u0026lsquo;sawatdi\u0026rsquo; คืออาร์กิวเมนต์ เมื่อใส่ลงไปในฟังก์ชัน print ฟังก์ชันก็จะทำข้อความ ไปแสดงผลออกมาทางหน้าจอ จะเห็นว่าไม่ว่าฟังก์ชันไหนก็ตาม จะมีรูปแบบเหมือนกันก็คือ ชื่อฟังก์ชัน ตามด้วยวงเล็บเปิดและปิด ( ) ซึ่งภายในวงเล็บจะใส่อาร์กิวเมนต์ที่ฟังก์ชันต้องการ และฟังก์ชันก็จะนำค่าอาร์กิวเมนต์ไปทำอะไรบางอย่างและอาจมีการคืนค่ากลับมาหรือไม่ก็ได้\nอีกอย่างที่ต้องเน้นสักหน่อยก็คืออาร์กิวเมนต์อาจเป็นค่าข้อมูลหรือตัวแปรที่เก็บข้อมูลอยู่ก็ได้ ตัวแปรที่ถูกใช้เป็นอาร์กิวเมนต์ในฟังก์ชันมักจะไม่มีการเปลี่ยนแปลงอะไร แค่ถูกนำค่าไปใช้เท่านั้น เช่น\nc = 2.222 d = str(c) print(d) # ได้ \u0026#39;2.222\u0026#39;  print(c) # ได้ 2.222 จะเห็นว่า c ถูกใช้ในฟังก์ชัน str เพื่อให้ได้ค่า d เป็นสายอักขระ แต่ว่า c ยังเป็นตัวเลขอยู่เหมือนเดิมไม่เปลี่ยนแปลง อย่างไรก็ตาม ฟังก์ชันที่ทำให้เกิดความเปลี่ยนแปลงกับอาร์กิวเมนต์ที่ใส่เข้าไปก็มีอยู่เช่นกัน\nอาร์กิวเมนต์หลายตัว อาร์กิวเมนต์ไม่จำเป็นที่จะต้องมีแค่ตัวเดียว อาจมีหลายตัวก็ได้ หากมีหลายตัวก็ ต้องคั่นด้วยเครื่องหมายจุลภาค , เช่น\nprint(\u0026#39;a =\u0026#39;, 1, \u0026#39;, b =\u0026#39;, 2) # ได้ a = 1 , b = 2 จะเห็นกว่าในนี้มีการใส่อาร์กิวเมนต์ถึง ๔ ตัว โดยแต่ละตัวก็คือสิ่งที่ต้องการให้แสดงผลออกมา โดยทั่วไปแล้วฟังก์ชัน print สามารถนำออกข้อมูลได้กี่อันก็ได้ จึงถือว่ามีอาร์กิวเมนต์ แบบไม่จำกัดจำนวน จำนวนอาร์กิวเมนต์ที่แต่ละฟังก์ชันต้องการนั้นอาจไม่เท่ากัน บางฟังก์ชันอาจต้องการหลายตัว หรือบางฟังก์ชันอาจไม่ต้องใช้อาร์กิวเมนต์เลย ซึ่งในกรณีนั้นจะใส่เป็นวงเล็บเปิดแล้วก็ปิดทันที () เช่นฟังก์ชัน input ซึ่งจะยกตัวอย่างให้เห็นต่อไป\nคีย์เวิร์ดของฟังก์ชัน นอกจาก อาร์กิวเมนต์แล้ว ฟังก์ชันยังอาจประกอบด้วยสิ่งที่เรียกว่าคีย์เวิร์ด (keyword) ซึ่งเป็นอีกสิ่งหนึ่งที่สามารถป้อนให้กับฟังก์ชันได้ แต่ต่างจากอาร์กิวเมนต์ตรงที่ว่า การป้อนคีย์เวิร์ดจะต้องใส่ชื่อของ คีย์เวิร์ดนั้น ยกตัวอย่างการใช้คีย์เวิร์ดในฟังก์ชัน print\nprint(\u0026#39;ฉันมีความสุข\u0026#39;,\u0026#39;555\u0026#39;,\u0026#39;๕๕๕\u0026#39;,\u0026#39;อยากหัวเราะดังๆ\u0026#39;,sep=\u0026#39;(^_^)\u0026#39;) ผลลัพธ์\nฉันมีความสุข(^_^)555(^_^)๕๕๕(^_^)อยากหัวเราะดังๆ ตัวอย่าง นี้จะเห็นว่าประกอบไปด้วยอาร์กิวเมนต์ ๔ ตัว และด้านหลังอาร์กิวเมนต์ หลังจุลภาคตัวสุดท้ายจะเห็น sep=\u0026rsquo;(^_^)\u0026rsquo; ซึ่ง sep นี้ก็คือคีย์เวิร์ดที่ใส่เพิ่มลงไปนั่นเอง\nความหมายของ sep ในฟังก์ชัน print ก็คือคำที่ใช้แยกระหว่างอาร์กิวเมนต์แต่ละตัวที่ใส่ลงไป ดังนั้นจึงจะเห็นได้ว่ามี (^_^) ปรากฏขึ้นมาแทรก โดยปกติแล้วถ้าหาก ไม่พิมพ์ sep ลงไปฟังก์ชันก็ยังทำงานได้ปกติ เพียงแต่ตัวคั่นระหว่างแต่ละอาร์กิวเมนต์จะกลายเป็นการเว้นวรรค ดังที่เห็นในตัวอย่างที่แล้ว การเพิ่มคีย์เวิร์ดเข้ามาจึงเป็นแค่การแต่งเสริมเพิ่มเติม นอกจาก sep แล้วก็ยังมีคีย์เวิร์ดสำคัญอีกตัวคือ end ซึ่งเป็นตัวกำหนดการสิ้นสุดประโยค\nprint(\u0026#39;การฝึกฝนที่ไม่มีความเจ็บปวดมันไม่มีความหมาย\u0026#39;,end=\u0026#39; \u0026#39;) print(\u0026#39;เพราะคนเราไม่สามารถได้อะไรมาโดยที่ไม่ต้องเสียสละอะไร\u0026#39;,end=\u0026#39; \u0026#39;) print(\u0026#39;แต่ว่าเมื่อทนความเจ็บปวดนั้นและก้าวผ่านมันไปได้\u0026#39;,end=\u0026#39;\u0026#39;) print(\u0026#39;ถึงตอนนั้นคนเราก็จะมีจิตใจที่แกร่งกล้าไม่แพ้ใครๆ\u0026#39;,end=\u0026#39;!\u0026#39;) (ที่มาของประโยค)\nผลลัพธ์\nการฝึกฝนที่ไม่มีความเจ็บปวดมันไม่มีความหมาย เพราะคนเราไม่สามารถได้อะไรมาโดยที่ไม่ต้องเสียสละอะไร แต่ว่าเมื่อทนความเจ็บปวดนั้นและก้าวผ่านมันไปได้ถึงตอนนั้นคนเราก็จะมี จิตใจที่แกร่งกล้าไม่แพ้ใครๆ! โดยปกติแล้วถ้าไม่ใส่คีย์เวิร์ด end ลงไปพอจบฟังก์ชัน print จะมีการขึ้นบรรทัดใหม่ นั่นเพราะโดยปกติถูกกำหนดให้สิ้นสุดด้วย \\n ซึ่งหมายถึงขึ้นบรรทัดใหม่ แต่ถ้าใส่ end ลงไปเราจะสามารถเปลี่ยนเป็นจบด้วยอะไรก็ได้ ถ้าต้องการให้ติดกันเลยก็พิมพ์ '\u0026rsquo;\nทั้ง sep และ end ใช้ได้เฉพาะไพธอน 3 ส่วนไพธอน 2 จะใช้วิธีที่ต่างกันออกไป\nรายละเอียด\nการคืนกลับและการส่งออก มีอีกเรื่องที่พูดถึงไปแล้วเล็กน้อยในบทที่ ๒ แต่ก็ควรต้องนำมากล่าวย้ำตรงนี้ด้วย นั่นคือความแตกต่างระหว่างระหว่างการคืนกลับ (return) และการส่งออก (output) ซึ่งอาจสร้างความสับสนได้ การคืนกลับหมายถึงการที่ได้ค่าอะไรออกมา จากฟังก์ชันหรือการคำนวณต่าง ๆ โดยค่าที่ได้มานั้น จะยังไม่ปรากฏออกมาให้เห็น แต่เก็บอยู่ภายในหน่วยความจำของเครื่อง\nส่วนการส่งออกนั้นหมายถึงการที่ค่านั้นถูกนำออกมาแสดงผล ให้เราได้เห็น โดยทั่วไปคือออกมาบนหน้าจอ เป็นข้อความ ซึ่งการส่งออกที่พื้นฐานที่สุดก็คือการใช้ฟังก์ชัน print\nฟังก์ชัน print นั้นไม่ได้ทำให้เกิดค่าอะไรคืนกลับมา แต่แค่ทำหน้าที่ส่งออกค่าที่เราป้อนเข้าไปให้\nที่อาจทำให้สับสนได้คือ เวลาที่คำนวณหรือใช้ฟังก์ชันอะไรที่มีค่าคืนกลับมาแล้วไม่มีตัวแปรอะไรมารับ หากทำผ่านเชลมันจะส่งค่าที่คืนกลับมาให้เห็นด้วย ในขณะที่ถ้าทำผ่านอีดิเตอร์ จะไม่มีการส่งออกมาแสดงผล เช่นหากพิมพ์ float(\u0026lsquo;129.3\u0026rsquo;) ในเชลก็จะได้ค่า 129.3 ออกมาพร้อมแสดงออกมาทันทีโดยไม่ต้องใช้ print อย่างไรก็ตาม ความจริงแล้วการแสดงผลค่าคืนกลับผ่านทางเชลนั้นไม่ได้เหมือนฟังก์ชัน print เสมอไป และฟังก์ชันที่สามารถส่งออกข้อมูลมาแสดงผลได้ก็ไม่ได้มีแต่ print ซึ่งตรงนี้จะค่อยมาพูดกันต่อไป\nฟังก์ชัน input สิ่งที่ตรงข้ามกับการส่งออกข้อมูลก็คือการป้อนเข้า (input) ในภาษาไพธอนฟังก์ชัน ที่ใช้ในการป้อนเข้าข้อมูลชื่อฟังก์ชัน input ตัวอย่างการใช้ ลองพิมพ์ตามนี้ลงในเชล\na = input() เสร็จแล้วโปรแกรมก็จะให้เราพิมพ์ข้อความอะไรบางอย่างใส่เพิ่มลงไป ก็ให้พิมพ์อะไรก็ได้ลงไปแล้วกด enter เสร็จแล้วข้อความที่ใส่ลงไปนั้นก็จะถูกเก็บอยู่ในตัวแปร a จากนั้นลองใช้คำสั่ง print เพื่อพิมพ์สิ่งที่เก็บอยู่ในตัวแปร a ออกมา\nprint(\u0026#39;a คือ\u0026#39;,a) ก็จะได้ข้อความที่เราพิมพ์ลงไปนั้นออกมา นี่เป็นวิธีการใช้ฟังก์ชัน input เพื่อรับค่ามาเก็บไว้ในตัวแปร ในที่นี้จะเห็นว่า input ป็นฟังก์ชัน ที่ทำหน้าที่ทั้งดำเนินการอะไรบางอย่างซึ่งในที่นี้คือสั่งให้ รับค่าจากคีย์บอร์ด และสุดท้ายก็ยังคืนค่ากลับออกมาด้วย อย่างไรก็ตามฟังก์ชัน input นั้นที่จริงแล้วไม่ได้ทำหน้าที่แค่รับค่าเพียงอย่างเดียว แต่ยังสามารถทำหน้าที่แสดงผลข้อความไปด้วยในเวลาเดียวกันด้วย ในตัวอย่างข้างต้น จะเห็นว่าในวงเล็บหลัง input นั้นว่างเปล่า ไม่ได้ใส่อะไรลงไป แต่ที่จริงแล้วฟังก์ชัน input เองก็สามารถใส่อาร์กิวเมนต์ลงไปได้ ซึ่งพอใส่ลงไปแล้ว สิ่งนั้นจะกลายเป็น ข้อความที่เราต้องการให้แสดงผลออกมาก่อนที่จะให้ป้อนข้อความ โดยทั่วไปเหมือนเป็น ข้อความที่ใช้บอกให้ผู้ใช้รู้ว่าจะต้องป้อนอะไร ขอยกตัวอย่างการใช้ เช่น ลองพิมพ์\na = input(\u0026#39;จงป้อนค่าอะไรสักอย่าง: \u0026#39;) จากนั้นก็จะมีข้อความขึ้นว่า\nจงป้อนค่าอะไรสักอย่าง: แล้วจึงตามด้วยส่วนที่ให้พิมพ์ข้อความอยู่ทางขวาของข้อความ การทำงานของ input ก็เป็นอย่างที่เห็นนี้ อาจชวนให้สับสนได้ง่าย ต้องจำไว้ว่าข้อความในอาร์กิวเมนต์ของ input เป็นเพียงแค่ข้อความที่สื่อสาร กับผู้ใช้ว่าควรจะกรอกข้อมูลอะไร แต่ไม่ได้มีผลอะไรกับข้อมูลที่ป้อนเข้าไป สิ่งที่ต้องเน้นอีกอย่าง คือ ข้อมูลที่ป้อนเข้าไปด้วยฟังก์ชัน input นี้จะเป็นสายอักขระ หากต้องการจะได้ค่าเป็นจำนวนจริงหรือจำนวนเต็มก็จะต้องแปลงอีกที เช่น\na = float(input(\u0026#39;จงป้อนตัวเลขลงไป: \u0026#39;)) จากนั้นก็ลองป้อนค่าตัวเลขอะไรบางอย่างเข้าไป\nแต่ถ้าป้อนค่าที่ไม่ใช่ตัวเลขลงไป เช่นใส่ตัวหนังสือปนลงไปด้วยก็จะขัดข้องทันที\nทั้งหมดที่ว่ามานี้เป็นเรื่องของไพธอน 3 ส่วนในไพธอน 2 จะมีความแตกต่างออกไปพอสมควร\n รายละเอียด  เมธอด ในภาษาไพธอนและอีกหลายภาษาที่เน้นการเขียนโปรแกรมเชิงวัตถุนั้นนอกจากฟังก์ชันแล้วยังมีคำสั่งอีกอีกชนิดหนึ่งซึ่งซึ่งมีลักษณะพิเศษเฉพาะ เรียกว่าเมธอด (method) ซึ่งก็อาจถือเป็นฟังก์ชันชนิดหนึ่ง เพียงแต่จะมีความจำเพาะต่อออบเจ็กต์\nเมธอดจะถูกนิยามควบคู่ไปกับออบเจ็กต์แต่ละชนิด โดยออบเจ็กต์แต่ละชนิดจะมีเมธอดไม่เหมือนกัน เมธอดจะไม่ปรากฏขึ้นเดี่ยวๆเหมือนอย่างฟังก์ชันทั่วไป เวลาเขียนเมธอดจะเขียน ตามหลังวัตถุที่ต้องการใช้เมธอดนั้น โดยใช้จุด . คั่น ขอยกตัวอย่างเช่น ออบเจ็กต์ชนิดจำนวนจริงมีเมธอดที่ชื่อว่า is_integer() คือเมธอดสำหรับตรวจว่าค่าของจำนวนจริงนั้นเป็นจำนวนเต็มในทางคณิตศาสตร์หรือ ไม่ (คือมีค่าเลขทศนิยมเป็น 0 หรือไม่) ถ้าเป็นก็คืนค่า True ถ้าไม่ใช่ก็คืนค่า False\nx = 3.0 x.is_integer() # ได้ผลเป็น True แต่\n(3.1).is_integer() # ได้ผลเป็น False แต่ถ้าใช้เมธอดกับวัตถุผิดชนิด (3).is_integer() # จะได้ AttributeError: \u0026#39;int\u0026#39; object has no attribute \u0026#39;is_integer\u0026#39; เพราะข้อมูลชนิดจำนวนเต็มไม่มีเมธอด is_integer ต้องเป็นข้อมูลชนิดจำนวนจริงเท่านั้นถึงจะมี\nวงเล็บที่อยู่ด้านหลังนั้นสามารถใส่อาร์กิวเมนต์หรือคีย์เวิร์ดลงไปได้เช่นกันหากเมธอดนั้นเป็นเมธอดที่ต้องการหรือสามารถใส่เพิ่มอาร์กิวเมนต์หรือคีย์เวิร์ดได้\nสรุปเนื้อหา  ฟังก์ชันคือสิ่งที่ทำให้เกิดการดำเนินการทำอะไรบางอย่าง หรืออาจคืนค่าอะไรบางอย่างกลับออกมา คลาสหรือชนิดของข้อมูล เช่น str int float bool นั้น ไม่ใช่ฟังก์ชันโดยตรงแต่ก็สามารถทำหน้าที่เหมือนฟังก์ชัน โดยมีหน้าที่แปลงชนิดข้อมูลให้กลายเป็นคลาสนั้น ฟังก์ชันจะต้องลงท้ายด้วยวงเล็บ () และอาจมีอาร์กิวเมนต์หรือคีย์อยู่ภายใน ส่วนเมธอดคือฟังก์ชันที่จำเพาะต่อออบเจ็กต์แต่ละชนิด เวลาใช้จะต้องเขียนตามหลังวัตถุโดยคั่นด้วยจุด . และต้องมีวงเล็บ () ต่อท้ายเช่นกัน  ยังมีฟังก์ชันและเมธ็อดอีกมากมาย ในบทนี้แค่ยกมาให้เห็นตัวอย่างบางส่วนให้พอเริ่มเห็นภาพ เมื่อผ่านไปถึงบทต่อๆไปก็จะได้รู้จักเพิ่มขึ้นเรื่อยๆและจะเริ่มคุ้นชินกับการใช้\nอ้างอิง\n http://docs.python.jp/3/library/functions.html http://docs.python.jp/3/tutorial/inputoutput.html   Reference : https://phyblas.hinaboshi.com/tsuchinoko04\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/files/exception-handling/",
	"title": "Exception Handling",
	"tags": [],
	"description": "",
	"content": "In this tutorial you will learn to create, format, modify and delete strings in Python. Also, you will be introduced to various string operations and functions.\nPython Exception Handling Using try, except and finally statement\nIn this tutorial, you\u0026rsquo;ll learn how to handle exceptions in your Python program using try, except and finally statements with the help of examples.\nExceptions in Python Python has many built-in exceptions that are raised when your program encounters an error (something in the program goes wrong).\nWhen these exceptions occur, the Python interpreter stops the current process and passes it to the calling process until it is handled. If not handled, the program will crash.\nFor example, let us consider a program where we have a function A that calls function B, which in turn calls function C. If an exception occurs in function C but is not handled in C, the exception passes to B and then to A.\nIf never handled, an error message is displayed and our program comes to a sudden unexpected halt.\n Catching Exceptions in Python In Python, exceptions can be handled using a try statement.\nThe critical operation which can raise an exception is placed inside the try clause. The code that handles the exceptions is written in the except clause.\nWe can thus choose what operations to perform once we have caught the exception. Here is a simple example.\n# import module sys to get the type of exception import sys randomList = [\u0026#39;a\u0026#39;, 0, 2] for entry in randomList: try: print(\u0026#34;The entry is\u0026#34;, entry) r = 1/int(entry) break except: print(\u0026#34;Oops!\u0026#34;, sys.exc_info()[0], \u0026#34;occurred.\u0026#34;) print(\u0026#34;Next entry.\u0026#34;) print() print(\u0026#34;The reciprocal of\u0026#34;, entry, \u0026#34;is\u0026#34;, r) Output\nThe entry is a Oops! \u0026lt;class \u0026#39;ValueError\u0026#39;\u0026gt; occurred. Next entry. The entry is 0 Oops! \u0026lt;class \u0026#39;ZeroDivisionError\u0026#39;\u0026gt; occured. Next entry. The entry is 2 The reciprocal of 2 is 0.5 In this program, we loop through the values of the randomList list. As previously mentioned, the portion that can cause an exception is placed inside the `try` block. If no exception occurs, the `except` block is skipped and normal flow continues(for last value). But if any exception occurs, it is caught by the `except` block (first and second values). Here, we print the name of the exception using the `exc_info()` function inside `sys` module. We can see that `a` causes `ValueError` and `0` causes `ZeroDivisionError`. Since every exception in Python inherits from the base `Exception` class, we can also perform the above task # import module sys to get the type of exception import sys randomList = [\u0026#39;a\u0026#39;, 0, 2] for entry in randomList: try: print(\u0026#34;The entry is\u0026#34;, entry) r = 1/int(entry) break except Exception as e: print(\u0026#34;Oops!\u0026#34;, e.__class__, \u0026#34;occurred.\u0026#34;) print(\u0026#34;Next entry.\u0026#34;) print() print(\u0026#34;The reciprocal of\u0026#34;, entry, \u0026#34;is\u0026#34;, r) This program has the same output as the above program.\n Catching Specific Exceptions in Python In the above example, we did not mention any specific exception in the except clause.\nThis is not a good programming practice as it will catch all exceptions and handle every case in the same way. We can specify which exceptions an except clause should catch.\nA try clause can have any number of except clauses to handle different exceptions, however, only one will be executed in case an exception occurs.\nWe can use a tuple of values to specify multiple exceptions in an except clause. Here is an example pseudo code.\ntry: # do something pass except ValueError: # handle ValueError exception pass except (TypeError, ZeroDivisionError): # handle multiple exceptions # TypeError and ZeroDivisionError pass except: # handle all other exceptions pass  Raising Exceptions in Python In Python programming, exceptions are raised when errors occur at runtime. We can also manually raise exceptions using the raise keyword.\nWe can optionally pass values to the exception to clarify why that exception was raised.\nraise KeyboardInterrupt Traceback (most recent call last): ... KeyboardInterrupt raise MemoryError(\u0026#34;This is an argument\u0026#34;) Traceback (most recent call last): ... MemoryError: This is an argument try: ... a = int(input(\u0026#34;Enter a positive integer: \u0026#34;)) ... if a \u0026lt;= 0: ... raise ValueError(\u0026#34;That is not a positive number!\u0026#34;) ... except ValueError as ve: ... print(ve) ... Enter a positive integer: -2 That is not a positive number!  Python try with else clause In some situations, you might want to run a certain block of code if the code block inside try ran without any errors. For these cases, you can use the optional else keyword with the try statement.\nNote: Exceptions in the else clause are not handled by the preceding except clauses.\nLet\u0026rsquo;s look at an example:\n# program to print the reciprocal of even numbers try: num = int(input(\u0026#34;Enter a number: \u0026#34;)) assert num % 2 == 0 except: print(\u0026#34;Not an even number!\u0026#34;) else: reciprocal = 1/num print(reciprocal) Output\nIf we pass an odd number:\nEnter a number: 1 Not an even number! If we pass an even number, the reciprocal is computed and displayed.\nEnter a number: 4 0.25 However, if we pass 0, we get ZeroDivisionError as the code block inside else is not handled by preceding except.\nEnter a number: 0 Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 7, in \u0026lt;module\u0026gt; reciprocal = 1/num ZeroDivisionError: division by zero  Python try\u0026hellip;finally The try statement in Python can have an optional finally clause. This clause is executed no matter what, and is generally used to release external resources.\nFor example, we may be connected to a remote data center through the network or working with a file or a Graphical User Interface (GUI).\nIn all these circumstances, we must clean up the resource before the program comes to a halt whether it successfully ran or not. These actions (closing a file, GUI or disconnecting from network) are performed in the finally clause to guarantee the execution.\nHere is an example of file operations to illustrate this.\ntry: f = open(\u0026#34;test.txt\u0026#34;,encoding = \u0026#39;utf-8\u0026#39;) # perform file operations finally: f.close() This type of construct makes sure that the file is closed even if an exception occurs during the program execution.\n Source : https://www.programiz.com/python-programming/exception-handling\n What is String in Python? A string is a sequence of characters.\nA character is simply a symbol. For example, the English language has 26 characters.\nComputers do not deal with characters, they deal with numbers (binary). Even though you may see characters on your screen, internally it is stored and manipulated as a combination of 0s and 1s.\nThis conversion of character to a number is called encoding, and the reverse process is decoding. ASCII and Unicode are some of the popular encodings used.\nIn Python, a string is a sequence of Unicode characters. Unicode was introduced to include every character in all languages and bring uniformity in encoding. You can learn about Unicode from Python Unicode.\n How to create a string in Python? Strings can be created by enclosing characters inside a single quote or double-quotes. Even triple quotes can be used in Python but generally used to represent multiline strings and docstrings.\n# defining strings in Python # all of the following are equivalent my_string = \u0026#39;Hello\u0026#39; print(my_string) my_string = \u0026#34;Hello\u0026#34; print(my_string) my_string = \u0026#39;\u0026#39;\u0026#39;Hello\u0026#39;\u0026#39;\u0026#39; print(my_string) # triple quotes string can extend multiple lines my_string = \u0026#34;\u0026#34;\u0026#34;Hello, welcome to the world of Python\u0026#34;\u0026#34;\u0026#34; print(my_string) When you run the program, the output will be:\nHello Hello Hello Hello, welcome to the world of Python  How to access characters in a string? We can access individual characters using indexing and a range of characters using slicing. Index starts from 0. Trying to access a character out of index range will raise an IndexError. The index must be an integer. We can\u0026rsquo;t use floats or other types, this will result into TypeError.\nPython allows negative indexing for its sequences.\nThe index of -1 refers to the last item, -2 to the second last item and so on. We can access a range of items in a string by using the slicing operator :(colon).\n#Accessing string characters in Python str = \u0026#39;programiz\u0026#39; print(\u0026#39;str = \u0026#39;, str) #first character print(\u0026#39;str[0] = \u0026#39;, str[0]) #last character print(\u0026#39;str[-1] = \u0026#39;, str[-1]) #slicing 2nd to 5th character print(\u0026#39;str[1:5] = \u0026#39;, str[1:5]) #slicing 6th to 2nd last character print(\u0026#39;str[5:-2] = \u0026#39;, str[5:-2]) When we run the above program, we get the following output:\nstr = programiz str[0] = p str[-1] = z str[1:5] = rogr str[5:-2] = am If we try to access an index out of the range or use numbers other than an integer, we will get errors.\n# index must be in range my_string[15] ... IndexError: string index out of range # index must be an integer my_string[1.5] ... TypeError: string indices must be integers Slicing can be best visualized by considering the index to be between the elements as shown below.\nIf we want to access a range, we need the index that will slice the portion from the string.\nString Slicing in Python\n How to change or delete a string? Strings are immutable. This means that elements of a string cannot be changed once they have been assigned. We can simply reassign different strings to the same name.\nmy_string = \u0026#39;programiz\u0026#39; my_string[5] = \u0026#39;a\u0026#39; ... TypeError: \u0026#39;str\u0026#39; object does not support item assignment my_string = \u0026#39;Python\u0026#39; my_string \u0026#39;Python\u0026#39; We cannot delete or remove characters from a string. But deleting the string entirely is possible using the del keyword.\ndel my_string[1] ... TypeError: \u0026#39;str\u0026#39; object doesn\u0026#39;t support item deletion del my_string my_string ... NameError: name \u0026#39;my_string\u0026#39; is not defined  Python String Operations There are many operations that can be performed with strings which makes it one of the most used data types in Python.\nTo learn more about the data types available in Python visit: Python Data Types\nConcatenation of Two or More Strings Joining of two or more strings into a single one is called concatenation.\nThe + operator does this in Python. Simply writing two string literals together also concatenates them.\nThe ***** operator can be used to repeat the string for a given number of times.\n# Python String Operations str1 = \u0026#39;Hello\u0026#39; str2 =\u0026#39;World!\u0026#39; # using + print(\u0026#39;str1 + str2 = \u0026#39;, str1 + str2) # using * print(\u0026#39;str1 * 3 =\u0026#39;, str1 * 3) When we run the above program, we get the following output:\nstr1 + str2 = HelloWorld! str1 * 3 = HelloHelloHello Writing two string literals together also concatenates them like + operator.\nIf we want to concatenate strings in different lines, we can use parentheses.\n# two string literals together \u0026#39;Hello \u0026#39;\u0026#39;World!\u0026#39; \u0026#39;Hello World!\u0026#39; # using parentheses s = (\u0026#39;Hello \u0026#39; ... \u0026#39;World\u0026#39;) s \u0026#39;Hello World\u0026#39;  Iterating Through a string We can iterate through a string using a for loop. Here is an example to count the number of \u0026lsquo;l\u0026rsquo;s in a string.\n# Iterating through a string count = 0 for letter in \u0026#39;Hello World\u0026#39;: if(letter == \u0026#39;l\u0026#39;): count += 1 print(count,\u0026#39;letters found\u0026#39;) When we run the above program, we get the following output:\n3 letters found  String Membership Test We can test if a substring exists within a string or not, using the keyword in.\n\u0026#39;a\u0026#39; in \u0026#39;program\u0026#39; True \u0026#39;at\u0026#39; not in \u0026#39;battle\u0026#39; False  Built-in functions to Work with Python Various built-in functions that work with sequence work with strings as well.\nSome of the commonly used ones are enumerate() and len(). The enumerate() function returns an enumerate object. It contains the index and value of all the items in the string as pairs. This can be useful for iteration.\nSimilarly, len() returns the length (number of characters) of the string.\nstr = \u0026#39;cold\u0026#39; # enumerate() list_enumerate = list(enumerate(str)) print(\u0026#39;list(enumerate(str) = \u0026#39;, list_enumerate) #character count print(\u0026#39;len(str) = \u0026#39;, len(str)) When we run the above program, we get the following output:\nlist(enumerate(str) = [(0, \u0026#39;c\u0026#39;), (1, \u0026#39;o\u0026#39;), (2, \u0026#39;l\u0026#39;), (3, \u0026#39;d\u0026#39;)] len(str) = 4  Python String Formatting Escape Sequence If we want to print a text like He said, \u0026ldquo;What\u0026rsquo;s there?\u0026rdquo;, we can neither use single quotes nor double quotes. This will result in a SyntaxError as the text itself contains both single and double quotes.\nprint(\u0026#34;He said, \u0026#34;What\u0026#39;s there?\u0026#34;\u0026#34;) ... SyntaxError: invalid syntax print(\u0026#39;He said, \u0026#34;What\u0026#39;s there?\u0026#34;\u0026#39;) ... SyntaxError: invalid syntax One way to get around this problem is to use triple quotes. Alternatively, we can use escape sequences.\nAn escape sequence starts with a backslash and is interpreted differently. If we use a single quote to represent a string, all the single quotes inside the string must be escaped. Similar is the case with double quotes. Here is how it can be done to represent the above text.\n# using triple quotes print(\u0026#39;\u0026#39;\u0026#39;He said, \u0026#34;What\u0026#39;s there?\u0026#34;\u0026#39;\u0026#39;\u0026#39;) # escaping single quotes print(\u0026#39;He said, \u0026#34;What\\\u0026#39;s there?\u0026#34;\u0026#39;) # escaping double quotes print(\u0026#34;He said, \\\u0026#34;What\u0026#39;s there?\\\u0026#34;\u0026#34;) When we run the above program, we get the following output:\nHe said, \u0026#34;What\u0026#39;s there?\u0026#34; He said, \u0026#34;What\u0026#39;s there?\u0026#34; He said, \u0026#34;What\u0026#39;s there?\u0026#34; Here is a list of all the escape sequences supported by Python.\n   Escape Sequence Description     \\newline Backslash and newline ignored   \\ Backslash   ' Single quote   \u0026quot; Double quote   \\a ASCII Bell   \\b ASCII Backspace   \\f ASCII Formfeed   \\n ASCII Linefeed   \\r ASCII Carriage Return   \\t ASCII Horizontal Tab   \\v ASCII Vertical Tab   \\ooo Character with octal value ooo   \\xHH Character with hexadecimal value HH    Here are some examples\nprint(\u0026#34;C:\\\\Python32\\\\Lib\u0026#34;) # C:\\Python32\\Lib print(\u0026#34;This is printed\\nin two lines\u0026#34;) #This is printed # in two lines print(\u0026#34;This is \\x48\\x45\\x58representation\u0026#34;) # This is HEX representation  Raw String to ignore escape sequence Sometimes we may wish to ignore the escape sequences inside a string. To do this we can place r or R in front of the string. This will imply that it is a raw string and any escape sequence inside it will be ignored.\nprint(\u0026#34;This is \\x61\\ngood example\u0026#34;) This is a good example print(r\u0026#34;This is \\x61 \\ngood example\u0026#34;) This is \\x61 \\ngood example  The format() Method for Formatting Strings The format() method that is available with the string object is very versatile and powerful in formatting strings. Format strings contain curly braces {} as placeholders or replacement fields which get replaced.\nWe can use positional arguments or keyword arguments to specify the order.\n# Python string format() method # default(implicit) order default_order = \u0026#34;{}, {} and {}\u0026#34;.format(\u0026#39;John\u0026#39;,\u0026#39;Bill\u0026#39;,\u0026#39;Sean\u0026#39;) print(\u0026#39;\\n--- Default Order ---\u0026#39;) print(default_order) # order using positional argument positional_order = \u0026#34;{1}, {0} and {2}\u0026#34;.format(\u0026#39;John\u0026#39;,\u0026#39;Bill\u0026#39;,\u0026#39;Sean\u0026#39;) print(\u0026#39;\\n--- Positional Order ---\u0026#39;) print(positional_order) # order using keyword argument keyword_order = \u0026#34;{s}, {b} and {j}\u0026#34;.format(j=\u0026#39;John\u0026#39;,b=\u0026#39;Bill\u0026#39;,s=\u0026#39;Sean\u0026#39;) print(\u0026#39;\\n--- Keyword Order ---\u0026#39;) print(keyword_order) When we run the above program, we get the following output:\n--- Default Order --- John, Bill and Sean --- Positional Order --- Bill, John and Sean --- Keyword Order --- Sean, Bill and John The format() method can have optional format specifications. They are separated from the field name using colon. For example, we can left-justify \u0026lt;, right-justify \u0026gt; or center ^ a string in the given space.\nWe can also format integers as binary, hexadecimal, etc. and floats can be rounded or displayed in the exponent format. There are tons of formatting you can use. Visit here for all the string formatting available with the [format()](https://www.programiz.com/python-programming/methods/string/format) method.\n# formatting integers \u0026#34;Binary representation of {0} is {0:b}\u0026#34;.format(12) \u0026#39;Binary representation of 12 is 1100\u0026#39; # formatting floats \u0026#34;Exponent representation: {0:e}\u0026#34;.format(1566.345) \u0026#39;Exponent representation: 1.566345e+03\u0026#39; # round off \u0026#34;One third is: {0:.3f}\u0026#34;.format(1/3) \u0026#39;One third is: 0.333\u0026#39; # string alignment \u0026#34;|{:\u0026lt;10}|{:^10}|{:\u0026gt;10}|\u0026#34;.format(\u0026#39;butter\u0026#39;,\u0026#39;bread\u0026#39;,\u0026#39;ham\u0026#39;) \u0026#39;|butter | bread | ham|\u0026#39;  Old style formatting We can even format strings like the old sprintf() style used in C programming language. We use the % operator to accomplish this.\nx = 12.3456789 print(\u0026#39;The value of x is %3.2f\u0026#39; %x) The value of x is 12.35 print(\u0026#39;The value of x is %3.4f\u0026#39; %x) The value of x is 12.3457  Common Python String Methods There are numerous methods available with the string object. The format() method that we mentioned above is one of them. Some of the commonly used methods are lower(), upper(), join(), split(), find(), replace() etc. Here is a complete list of all the built-in methods to work with strings in Python.\n\u0026#34;PrOgRaMiZ\u0026#34;.lower() \u0026#39;programiz\u0026#39; \u0026#34;PrOgRaMiZ\u0026#34;.upper() \u0026#39;PROGRAMIZ\u0026#39; \u0026#34;This will split all words into a list\u0026#34;.split() [\u0026#39;This\u0026#39;, \u0026#39;will\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;all\u0026#39;, \u0026#39;words\u0026#39;, \u0026#39;into\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;list\u0026#39;] \u0026#39; \u0026#39;.join([\u0026#39;This\u0026#39;, \u0026#39;will\u0026#39;, \u0026#39;join\u0026#39;, \u0026#39;all\u0026#39;, \u0026#39;words\u0026#39;, \u0026#39;into\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;string\u0026#39;]) \u0026#39;This will join all words into a string\u0026#39; \u0026#39;Happy New Year\u0026#39;.find(\u0026#39;ew\u0026#39;) 7 \u0026#39;Happy New Year\u0026#39;.replace(\u0026#39;Happy\u0026#39;,\u0026#39;Brilliant\u0026#39;) \u0026#39;Brilliant New Year\u0026#39;  Source : https://www.programiz.com/python-programming/string\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/files/",
	"title": "Files",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/function/global_variables/",
	"title": "Global, Local and variables",
	"tags": [],
	"description": "",
	"content": "In this tutorial, you’ll learn about Python Global variables, Local variables, Nonlocal variables and where to use them.\nGlobal Variables In Python, a variable declared outside of the function or in global scope is known as a global variable. This means that a global variable can be accessed inside or outside of the function.\nLet\u0026rsquo;s see an example of how a global variable is created in Python.\nExample 1: Create a Global Variable x = \u0026#34;global\u0026#34; def foo(): print(\u0026#34;x inside:\u0026#34;, x) foo() print(\u0026#34;x outside:\u0026#34;, x) Output\nx inside: global x outside: global In the above code, we created x as a global variable and defined a foo() to print the global variable x. Finally, we call the foo() which will print the value of x.\nWhat if you want to change the value of x inside a function?\nx = \u0026#34;global\u0026#34; def foo(): x = x * 2 print(x) foo() Output\nUnboundLocalError: local variable \u0026#39;x\u0026#39; referenced before assignment The output shows an error because Python treats x as a local variable and x is also not defined inside foo().\nTo make this work, we use the global keyword. Visit Python Global Keyword to learn more.\n Local Variables A variable declared inside the function\u0026rsquo;s body or in the local scope is known as a local variable.\nExample 2: Accessing local variable outside the scope def foo(): y = \u0026#34;local\u0026#34; foo() print(y) Output\nNameError: name \u0026#39;y\u0026#39; is not defined The output shows an error because we are trying to access a local variable y in a global scope whereas the local variable only works inside foo() or local scope.\n Let\u0026rsquo;s see an example on how a local variable is created in Python.\nExample 3: Create a Local Variable Normally, we declare a variable inside the function to create a local variable.\ndef foo(): y = \u0026#34;local\u0026#34; print(y) foo() Output\nlocal Let\u0026rsquo;s take a look at the earlier problem where x was a global variable and we wanted to modify x inside foo().\n Global and local variables Here, we will show how to use global variables and local variables in the same code.\nExample 4: Using Global and Local variables in the same code x = \u0026#34;global \u0026#34; def foo(): global x y = \u0026#34;local\u0026#34; x = x * 2 print(x) print(y) foo() Output\nglobal global local In the above code, we declare x as a global and y as a local variable in the foo(). Then, we use multiplication operator * to modify the global variable x and we print both x and y.\nAfter calling the foo(), the value of x becomes global global because we used the x * 2 to print two times global. After that, we print the value of local variable y i.e local.\n Example 5: Global variable and Local variable with same name x = 5 def foo(): x = 10 print(\u0026#34;local x:\u0026#34;, x) foo() print(\u0026#34;global x:\u0026#34;, x) Output\nlocal x: 10 global x: 5 In the above code, we used the same name x for both global variable and local variable. We get a different result when we print the same variable because the variable is declared in both scopes, i.e. the local scope inside foo() and global scope outside foo().\nWhen we print the variable inside foo() it outputs local x: 10. This is called the local scope of the variable.\nSimilarly, when we print the variable outside the foo(), it outputs global x: 5. This is called the global scope of the variable.\n Nonlocal Variables Nonlocal variables are used in nested functions whose local scope is not defined. This means that the variable can be neither in the local nor the global scope.\nLet\u0026rsquo;s see an example of how a global variable is created in Python.\nWe use nonlocal keywords to create nonlocal variables.\nExample 6: Create a nonlocal variable def outer(): x = \u0026#34;local\u0026#34; def inner(): nonlocal x x = \u0026#34;nonlocal\u0026#34; print(\u0026#34;inner:\u0026#34;, x) inner() print(\u0026#34;outer:\u0026#34;, x) outer() Output\ninner: nonlocal outer: nonlocal In the above code, there is a nested inner() function. We use nonlocal keywords to create a nonlocal variable. The inner() function is defined in the scope of another function outer().\nNote : If we change the value of a nonlocal variable, the changes appear in the local variable.\n Reference : https://www.programiz.com\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/data_type/set/",
	"title": "Python: Set",
	"tags": [],
	"description": "",
	"content": "In this tutorial, you\u0026rsquo;ll learn everything about Python sets; how they are created, adding or removing elements from them, and all operations performed on sets in Python.\nA set is an unordered collection of items. Every set element is unique (no duplicates) and must be immutable (cannot be changed).\nHowever, a set itself is mutable. We can add or remove items from it.\nSets can also be used to perform mathematical set operations like union, intersection, symmetric difference, etc.\n Creating Python Sets A set is created by placing all the items (elements) inside curly braces {}, separated by comma, or by using the built-in set() function.\nIt can have any number of items and they may be of different types (integer, float, tuple, string etc.). But a set cannot have mutable elements like lists, sets or dictionaries as its elements.\n# Different types of sets in Python # set of integers my_set = {1, 2, 3} print(my_set) # set of mixed datatypes my_set = {1.0, \u0026#34;Hello\u0026#34;, (1, 2, 3)} print(my_set) Output\n{1, 2, 3} {1.0, (1, 2, 3), \u0026#39;Hello\u0026#39;} Try the following examples as well.\n# set cannot have duplicates # Output: {1, 2, 3, 4} my_set = {1, 2, 3, 4, 3, 2} print(my_set) # we can make set from a list # Output: {1, 2, 3} my_set = set([1, 2, 3, 2]) print(my_set) # set cannot have mutable items # here [3, 4] is a mutable list # this will cause an error. my_set = {1, 2, [3, 4]} Output\n{1, 2, 3, 4} {1, 2, 3} Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 15, in \u0026lt;module\u0026gt; my_set = {1, 2, [3, 4]} TypeError: unhashable type: \u0026#39;list\u0026#39;  Creating an empty set is a bit tricky.\nEmpty curly braces {} will make an empty dictionary in Python. To make a set without any elements, we use the set() function without any argument.\n# Distinguish set and dictionary while creating empty set # initialize a with {} a = {} # check data type of a print(type(a)) # initialize a with set() a = set() # check data type of a print(type(a)) Output\n\u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026lt;class \u0026#39;set\u0026#39;\u0026gt;  Modifying a set in Python Sets are mutable. However, since they are unordered, indexing has no meaning.\nWe cannot access or change an element of a set using indexing or slicing. Set data type does not support it.\nWe can add a single element using the add() method, and multiple elements using the update() method. The update() method can take tuples, lists, strings or other sets as its argument. In all cases, duplicates are avoided.\n# initialize my_set my_set = {1, 3} print(my_set) # if you uncomment line 9, # you will get an error # TypeError: \u0026#39;set\u0026#39; object does not support indexing # my_set[0] # add an element # Output: {1, 2, 3} my_set.add(2) print(my_set) # add multiple elements # Output: {1, 2, 3, 4} my_set.update([2, 3, 4]) print(my_set) # add list and set # Output: {1, 2, 3, 4, 5, 6, 8} my_set.update([4, 5], {1, 6, 8}) print(my_set) Output\n{1, 3} {1, 2, 3} {1, 2, 3, 4} {1, 2, 3, 4, 5, 6, 8}  Removing elements from a set A particular item can be removed from a set using the methods discard() and remove().\nThe only difference between the two is that the discard() function leaves a set unchanged if the element is not present in the set. On the other hand, the remove() function will raise an error in such a condition (if element is not present in the set).\nThe following example will illustrate this.\n# Difference between discard() and remove() # initialize my_set my_set = {1, 3, 4, 5, 6} print(my_set) # discard an element # Output: {1, 3, 5, 6} my_set.discard(4) print(my_set) # remove an element # Output: {1, 3, 5} my_set.remove(6) print(my_set) # discard an element # not present in my_set # Output: {1, 3, 5} my_set.discard(2) print(my_set) # remove an element # not present in my_set # you will get an error. # Output: KeyError my_set.remove(2) Output\n{1, 3, 4, 5, 6} {1, 3, 5, 6} {1, 3, 5} {1, 3, 5} Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 28, in \u0026lt;module\u0026gt; KeyError: 2 Similarly, we can remove and return an item using the pop() method.\nSince set is an unordered data type, there is no way of determining which item will be popped. It is completely arbitrary.\nWe can also remove all the items from a set using the clear() method.\n# initialize my_set # Output: set of unique elements my_set = set(\u0026#34;HelloWorld\u0026#34;) print(my_set) # pop an element # Output: random element print(my_set.pop()) # pop another element my_set.pop() print(my_set) # clear my_set # Output: set() my_set.clear() print(my_set) print(my_set) Output\n{\u0026#39;H\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;} H {\u0026#39;r\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;} set()  Python Set Operations Sets can be used to carry out mathematical set operations like union, intersection, difference and symmetric difference. We can do this with operators or methods.\nLet us consider the following two sets for the following operations.\nA = {1, 2, 3, 4, 5} B = {4, 5, 6, 7, 8} Set Union Set Union in Python\nUnion of A and B is a set of all elements from both sets.\nUnion is performed using | operator. Same can be accomplished using the union() method.\n# Set union method # initialize A and B A = {1, 2, 3, 4, 5} B = {4, 5, 6, 7, 8} # use | operator # Output: {1, 2, 3, 4, 5, 6, 7, 8} print(A | B) Output\n{1, 2, 3, 4, 5, 6, 7, 8} Try the following examples on Python shell.\n# use union function A.union(B) {1, 2, 3, 4, 5, 6, 7, 8} # use union function on B B.union(A) {1, 2, 3, 4, 5, 6, 7, 8}  Set Intersection Set Intersection in Python\nIntersection of A and B is a set of elements that are common in both the sets.\nIntersection is performed using \u0026amp; operator. Same can be accomplished using the intersection() method.\n# Intersection of sets # initialize A and B A = {1, 2, 3, 4, 5} B = {4, 5, 6, 7, 8} # use \u0026amp; operator # Output: {4, 5} print(A \u0026amp; B) Output\n{4, 5} Try the following examples on Python shell.\n# use intersection function on A A.intersection(B) {4, 5} # use intersection function on B B.intersection(A) {4, 5}  Set Difference Set Difference in Python\nDifference of the set B from set A(A - B) is a set of elements that are only in A but not in B. Similarly, B - A is a set of elements in B but not in A.\nDifference is performed using - operator. Same can be accomplished using the difference() method.\n# Difference of two sets # initialize A and B A = {1, 2, 3, 4, 5} B = {4, 5, 6, 7, 8} # use - operator on A # Output: {1, 2, 3} print(A - B) Output\n{1, 2, 3} Try the following examples on Python shell.\n# use difference function on A A.difference(B) {1, 2, 3} # use - operator on B B - A {8, 6, 7} # use difference function on B B.difference(A) {8, 6, 7}  Set Symmetric Difference Set Symmetric Difference in Python\nSymmetric Difference of A and B is a set of elements in A and B but not in both (excluding the intersection).\nSymmetric difference is performed using ^ operator. Same can be accomplished using the method symmetric_difference().\n# Symmetric difference of two sets # initialize A and B A = {1, 2, 3, 4, 5} B = {4, 5, 6, 7, 8} # use ^ operator # Output: {1, 2, 3, 6, 7, 8} print(A ^ B) Output\n{1, 2, 3, 6, 7, 8} Try the following examples on Python shell.\n# use symmetric_difference function on A A.symmetric_difference(B) {1, 2, 3, 6, 7, 8} # use symmetric_difference function on B B.symmetric_difference(A) {1, 2, 3, 6, 7, 8}  Other Python Set Methods There are many set methods, some of which we have already used above. Here is a list of all the methods that are available with the set objects:\n   Method Description     add() Adds an element to the set   clear() Removes all elements from the set   copy() Returns a copy of the set   difference() Returns the difference of two or more sets as a new set   difference_update() Removes all elements of another set from this set   discard() Removes an element from the set if it is a member. (Do nothing if the element is not in set)   intersection() Returns the intersection of two sets as a new set   intersection_update() Updates the set with the intersection of itself and another   isdisjoint() Returns True if two sets have a null intersection   issubset() Returns True if another set contains this set   issuperset() Returns True if this set contains another set   pop() Removes and returns an arbitrary set element. Raises KeyError if the set is empty   remove() Removes an element from the set. If the element is not a member, raises a KeyError   symmetric_difference() Returns the symmetric difference of two sets as a new set   symmetric_difference_update() Updates a set with the symmetric difference of itself and another   union() Returns the union of sets in a new set   update() Updates the set with the union of itself and others     Other Set Operations Set Membership Test We can test if an item exists in a set or not, using the in keyword.\n# in keyword in a set # initialize my_set my_set = set(\u0026#34;apple\u0026#34;) # check if \u0026#39;a\u0026#39; is present # Output: True print(\u0026#39;a\u0026#39; in my_set) # check if \u0026#39;p\u0026#39; is present # Output: False print(\u0026#39;p\u0026#39; not in my_set) Output\nTrue False  Iterating Through a Set We can iterate through each item in a set using a for loop.\nfor letter in set(\u0026#34;apple\u0026#34;): ... print(letter) ... a p e l  Built-in Functions with Set Built-in functions like all(), any(), enumerate(), len(), max(), min(), sorted(), sum() etc. are commonly used with sets to perform different tasks.\n   Function Description     all() Returns True if all elements of the set are true (or if the set is empty).   any() Returns True if any element of the set is true. If the set is empty, returns False.   enumerate() Returns an enumerate object. It contains the index and value for all the items of the set as a pair.   len() Returns the length (the number of items) in the set.   max() Returns the largest item in the set.   min() Returns the smallest item in the set.   sorted() Returns a new sorted list from elements in the set(does not sort the set itself).   sum() Returns the sum of all elements in the set.     Python Frozenset Frozenset is a new class that has the characteristics of a set, but its elements cannot be changed once assigned. While tuples are immutable lists, frozensets are immutable sets.\nSets being mutable are unhashable, so they can\u0026rsquo;t be used as dictionary keys. On the other hand, frozensets are hashable and can be used as keys to a dictionary.\nFrozensets can be created using the frozenset() function.\nThis data type supports methods like copy(), difference(), intersection(), isdisjoint(), issubset(), issuperset(), symmetric_difference() and union(). Being immutable, it does not have methods that add or remove elements.\n# Frozensets # initialize A and B A = frozenset([1, 2, 3, 4]) B = frozenset([3, 4, 5, 6]) Try these examples on Python shell.\nA.isdisjoint(B) False A.difference(B) frozenset({1, 2}) A | B frozenset({1, 2, 3, 4, 5, 6}) A.add(3) ... AttributeError: \u0026#39;frozenset\u0026#39; object has no attribute \u0026#39;add\u0026#39;  Source : https://www.programiz.com/python-programming/set\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/datetime/timestamp_datetime/",
	"title": "Timestamp to Datetime",
	"tags": [],
	"description": "",
	"content": "Python timestamp to datetime and vice-versa\n In this article, you will learn to convert timestamp to datetime object and datetime object to timestamp (with the help of examples).\n It\u0026rsquo;s pretty common to store date and time as a timestamp in a database. A Unix timestamp is the number of seconds between a particular date and January 1, 1970 at UTC.\n Example 1: Python timestamp to datetime from datetime import datetime timestamp = 1545730073 dt_object = datetime.fromtimestamp(timestamp) print(\u0026#34;dt_object =\u0026#34;, dt_object) print(\u0026#34;type(dt_object) =\u0026#34;, type(dt_object)) When you run the program, the output will be:\ndt_object = 2018-12-25 09:27:53 type(dt_object) = \u0026lt;class \u0026#39;datetime.datetime\u0026#39;\u0026gt; Here, we have imported datetime class from the datetime module. Then, we used datetime.fromtimestamp() classmethod which returns the local date and time (datetime object). This object is stored in dt_object variable.\nNote: You can easily create a string representing date and time from a datetime object using strftime() method.\n Example 2: Python datetime to timestamp You can get timestamp from a datetime object using datetime.timestamp() method.\nfrom datetime import datetime # current date and time now = datetime.now() timestamp = datetime.timestamp(now) print(\u0026#34;timestamp =\u0026#34;, timestamp)  Reference : https://www.programiz.com/python-programming/datetime/timestamp-datetime\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/files/user-defined-exception/",
	"title": "Custom Exceptions",
	"tags": [],
	"description": "",
	"content": "In this tutorial, you will learn how to define custom exceptions depending upon your requirements with the help of examples.\nPython has numerous built-in exceptions that force your program to output an error when something in the program goes wrong.\nHowever, sometimes you may need to create your own custom exceptions that serve your purpose.\n Creating Custom Exceptions In Python, users can define custom exceptions by creating a new class. This exception class has to be derived, either directly or indirectly, from the built-in Exception class. Most of the built-in exceptions are also derived from this class.\nclass CustomError(Exception): ... pass ... raise CustomError Traceback (most recent call last): ... __main__.CustomError raise CustomError(\u0026#34;An error occurred\u0026#34;) Traceback (most recent call last): ... __main__.CustomError: An error occurred Here, we have created a user-defined exception called CustomError which inherits from the Exception class. This new exception, like other exceptions, can be raised using the raise statement with an optional error message.\nWhen we are developing a large Python program, it is a good practice to place all the user-defined exceptions that our program raises in a separate file. Many standard modules do this. They define their exceptions separately as exceptions.py or errors.py (generally but not always).\nUser-defined exception class can implement everything a normal class can do, but we generally make them simple and concise. Most implementations declare a custom base class and derive others exception classes from this base class. This concept is made clearer in the following example.\n Example: User-Defined Exception in Python In this example, we will illustrate how user-defined exceptions can be used in a program to raise and catch errors.\nThis program will ask the user to enter a number until they guess a stored number correctly. To help them figure it out, a hint is provided whether their guess is greater than or less than the stored number.\n# define Python user-defined exceptions class Error(Exception): \u0026#34;\u0026#34;\u0026#34;Base class for other exceptions\u0026#34;\u0026#34;\u0026#34; pass class ValueTooSmallError(Error): \u0026#34;\u0026#34;\u0026#34;Raised when the input value is too small\u0026#34;\u0026#34;\u0026#34; pass class ValueTooLargeError(Error): \u0026#34;\u0026#34;\u0026#34;Raised when the input value is too large\u0026#34;\u0026#34;\u0026#34; pass # you need to guess this number number = 10 # user guesses a number until he/she gets it right while True: try: i_num = int(input(\u0026#34;Enter a number: \u0026#34;)) if i_num \u0026lt; number: raise ValueTooSmallError elif i_num \u0026gt; number: raise ValueTooLargeError break except ValueTooSmallError: print(\u0026#34;This value is too small, try again!\u0026#34;) print() except ValueTooLargeError: print(\u0026#34;This value is too large, try again!\u0026#34;) print() print(\u0026#34;Congratulations! You guessed it correctly.\u0026#34;) Here is a sample run of this program.\nEnter a number: 12 This value is too large, try again! Enter a number: 0 This value is too small, try again! Enter a number: 8 This value is too small, try again! Enter a number: 10 Congratulations! You guessed it correctly. We have defined a base class called Error.\nThe other two exceptions (ValueTooSmallError and ValueTooLargeError) that are actually raised by our program are derived from this class. This is the standard way to define user-defined exceptions in Python programming, but you are not limited to this way only.\n Customizing Exception Classes We can further customize this class to accept other arguments as per our needs.\nTo learn about customizing the Exception classes, you need to have the basic knowledge of Object-Oriented programming.\nVisit Python Object Oriented Programming to start learning about Object-Oriented programming in Python.\nLet\u0026rsquo;s look at one example:\nclass SalaryNotInRangeError(Exception): \u0026#34;\u0026#34;\u0026#34;Exception raised for errors in the input salary. Attributes: salary -- input salary which caused the error message -- explanation of the error \u0026#34;\u0026#34;\u0026#34; def __init__(self, salary, message=\u0026#34;Salary is not in (5000, 15000) range\u0026#34;): self.salary = salary self.message = message super().__init__(self.message) salary = int(input(\u0026#34;Enter salary amount: \u0026#34;)) if not 5000 \u0026lt; salary \u0026lt; 15000: raise SalaryNotInRangeError(salary) Output\nEnter salary amount: 2000 Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 17, in \u0026lt;module\u0026gt; raise SalaryNotInRangeError(salary) __main__.SalaryNotInRangeError: Salary is not in (5000, 15000) range Here, we have overridden the constructor of the Exception class to accept our own custom arguments salary and message. Then, the constructor of the parent Exception class is called manually with the self.message argument using super().\nThe custom self.salary attribute is defined to be used later.\nThe inherited __str__ method of the Exception class is then used to display the corresponding message when SalaryNotInRangeError is raised.\nWe can also customize the __str__ method itself by overriding it.\nclass SalaryNotInRangeError(Exception): \u0026#34;\u0026#34;\u0026#34;Exception raised for errors in the input salary. Attributes: salary -- input salary which caused the error message -- explanation of the error \u0026#34;\u0026#34;\u0026#34; def __init__(self, salary, message=\u0026#34;Salary is not in (5000, 15000) range\u0026#34;): self.salary = salary self.message = message super().__init__(self.message) def __str__(self): return f\u0026#39;{self.salary} -\u0026gt; {self.message}\u0026#39; salary = int(input(\u0026#34;Enter salary amount: \u0026#34;)) if not 5000 \u0026lt; salary \u0026lt; 15000: raise SalaryNotInRangeError(salary) Output\nEnter salary amount: 2000 Traceback (most recent call last): File \u0026#34;/home/bsoyuj/Desktop/Untitled-1.py\u0026#34;, line 20, in \u0026lt;module\u0026gt; raise SalaryNotInRangeError(salary) __main__.SalaryNotInRangeError: 2000 -\u0026gt; Salary is not in (5000, 15000) range  To learn more about how you can handle exceptions in Python, visit Python Exception Handling.\nReference : https://www.programiz.com/python-programming/user-defined-exception\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/objects_class/",
	"title": "Object &amp; Class",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/data_type/dictionary/",
	"title": "Python: Dictionary",
	"tags": [],
	"description": "",
	"content": "In this tutorial, you\u0026rsquo;ll learn everything about Python dictionaries; how they are created, accessing, adding, removing elements from them and various built-in methods.\nPython dictionary is an unordered collection of items. Each item of a dictionary has a key/value pair.\nDictionaries are optimized to retrieve values when the key is known.\n Creating Python Dictionary Creating a dictionary is as simple as placing items inside curly braces {} separated by commas.\nAn item has a key and a corresponding value that is expressed as a pair (key: value).\nWhile the values can be of any data type and can repeat, keys must be of immutable type (string, number or tuple with immutable elements) and must be unique.\n# empty dictionary my_dict = {} # dictionary with integer keys my_dict = {1: \u0026#39;apple\u0026#39;, 2: \u0026#39;ball\u0026#39;} # dictionary with mixed keys my_dict = {\u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, 1: [2, 4, 3]} # using dict() my_dict = dict({1:\u0026#39;apple\u0026#39;, 2:\u0026#39;ball\u0026#39;}) # from sequence having each item as a pair my_dict = dict([(1,\u0026#39;apple\u0026#39;), (2,\u0026#39;ball\u0026#39;)]) As you can see from above, we can also create a dictionary using the built-in dict() function.\n Accessing Elements from Dictionary While indexing is used with other data types to access values, a dictionary uses keys. Keys can be used either inside square brackets [] or with the get() method.\nIf we use the square brackets [], KeyError is raised in case a key is not found in the dictionary. On the other hand, the get() method returns None if the key is not found.\n# get vs [] for retrieving elements my_dict = {\u0026#39;name\u0026#39;: \u0026#39;Jack\u0026#39;, \u0026#39;age\u0026#39;: 26} # Output: Jack print(my_dict[\u0026#39;name\u0026#39;]) # Output: 26 print(my_dict.get(\u0026#39;age\u0026#39;)) # Trying to access keys which doesn\u0026#39;t exist throws error # Output None print(my_dict.get(\u0026#39;address\u0026#39;)) # KeyError print(my_dict[\u0026#39;address\u0026#39;]) Output\nJack 26 None Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 15, in \u0026lt;module\u0026gt; print(my_dict[\u0026#39;address\u0026#39;]) KeyError: \u0026#39;address\u0026#39;  Changing and Adding Dictionary elements Dictionaries are mutable. We can add new items or change the value of existing items using an assignment operator.\nIf the key is already present, then the existing value gets updated. In case the key is not present, a new (key: value) pair is added to the dictionary.\n# Changing and adding Dictionary Elements my_dict = {\u0026#39;name\u0026#39;: \u0026#39;Jack\u0026#39;, \u0026#39;age\u0026#39;: 26} # update value my_dict[\u0026#39;age\u0026#39;] = 27 #Output: {\u0026#39;age\u0026#39;: 27, \u0026#39;name\u0026#39;: \u0026#39;Jack\u0026#39;} print(my_dict) # add item my_dict[\u0026#39;address\u0026#39;] = \u0026#39;Downtown\u0026#39; # Output: {\u0026#39;address\u0026#39;: \u0026#39;Downtown\u0026#39;, \u0026#39;age\u0026#39;: 27, \u0026#39;name\u0026#39;: \u0026#39;Jack\u0026#39;} print(my_dict) Output\n{\u0026#39;name\u0026#39;: \u0026#39;Jack\u0026#39;, \u0026#39;age\u0026#39;: 27} {\u0026#39;name\u0026#39;: \u0026#39;Jack\u0026#39;, \u0026#39;age\u0026#39;: 27, \u0026#39;address\u0026#39;: \u0026#39;Downtown\u0026#39;}  Removing elements from Dictionary We can remove a particular item in a dictionary by using the pop() method. This method removes an item with the provided key and returns the value.\nThe popitem() method can be used to remove and return an arbitrary (key, value) item pair from the dictionary. All the items can be removed at once, using the clear() method.\nWe can also use the del keyword to remove individual items or the entire dictionary itself.\n# Removing elements from a dictionary # create a dictionary squares = {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} # remove a particular item, returns its value # Output: 16 print(squares.pop(4)) # Output: {1: 1, 2: 4, 3: 9, 5: 25} print(squares) # remove an arbitrary item, return (key,value) # Output: (5, 25) print(squares.popitem()) # Output: {1: 1, 2: 4, 3: 9} print(squares) # remove all items squares.clear() # Output: {} print(squares) # delete the dictionary itself del squares # Throws Error print(squares) Output\n16 {1: 1, 2: 4, 3: 9, 5: 25} (5, 25) {1: 1, 2: 4, 3: 9} {} Traceback (most recent call last): File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 30, in \u0026lt;module\u0026gt; print(squares) NameError: name \u0026#39;squares\u0026#39; is not defined  Python Dictionary Methods Methods that are available with a dictionary are tabulated below. Some of them have already been used in the above examples.\n   Method Description     clear() Removes all items from the dictionary.   copy() Returns a shallow copy of the dictionary.   fromkeys(seq[, v]) Returns a new dictionary with keys from seq and value equal to v (defaults to None).   get(key[,d]) Returns the value of the key. If the key does not exist, returns d (defaults to None).   items() Return a new object of the dictionary\u0026rsquo;s items in (key, value) format.   keys() Returns a new object of the dictionary\u0026rsquo;s keys.   pop(key[,d]) Removes the item with the key and returns its value or d if key is not found. If d is not provided and the key is not found, it raises KeyError.   popitem() Removes and returns an arbitrary item (key, value). Raises KeyError if the dictionary is empty.   setdefault(key[,d]) Returns the corresponding value if the key is in the dictionary. If not, inserts the key with a value of d and returns d (defaults to None).   update([other]) Updates the dictionary with the key/value pairs from other, overwriting existing keys.   values() Returns a new object of the dictionary\u0026rsquo;s values    Here are a few example use cases of these methods.\n# Dictionary Methods marks = {}.fromkeys([\u0026#39;Math\u0026#39;, \u0026#39;English\u0026#39;, \u0026#39;Science\u0026#39;], 0) # Output: {\u0026#39;English\u0026#39;: 0, \u0026#39;Math\u0026#39;: 0, \u0026#39;Science\u0026#39;: 0} print(marks) for item in marks.items(): print(item) # Output: [\u0026#39;English\u0026#39;, \u0026#39;Math\u0026#39;, \u0026#39;Science\u0026#39;] print(list(sorted(marks.keys()))) Output\n{\u0026#39;Math\u0026#39;: 0, \u0026#39;English\u0026#39;: 0, \u0026#39;Science\u0026#39;: 0} (\u0026#39;Math\u0026#39;, 0) (\u0026#39;English\u0026#39;, 0) (\u0026#39;Science\u0026#39;, 0) [\u0026#39;English\u0026#39;, \u0026#39;Math\u0026#39;, \u0026#39;Science\u0026#39;]  Python Dictionary Comprehension Dictionary comprehension is an elegant and concise way to create a new dictionary from an iterable in Python.\nDictionary comprehension consists of an expression pair (key: value) followed by a for statement inside curly braces {}.\nHere is an example to make a dictionary with each item being a pair of a number and its square.\n# Dictionary Comprehension squares = {x: x*x for x in range(6)} print(squares) Output\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25} This code is equivalent to\nsquares = {} for x in range(6): squares[x] = x*x print(squares) Output\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25} A dictionary comprehension can optionally contain more for or if statements.\nAn optional if statement can filter out items to form the new dictionary.\nHere are some examples to make a dictionary with only odd items.\n# Dictionary Comprehension with if conditional odd_squares = {x: x*x for x in range(11) if x % 2 == 1} print(odd_squares) Output\n{1: 1, 3: 9, 5: 25, 7: 49, 9: 81} To learn more dictionary comprehensions, visit Python Dictionary Comprehension.\n Other Dictionary Operations Dictionary Membership Test We can test if a key is in a dictionary or not using the keyword in. Notice that the membership test is only for the keys and not for the values.\n# Membership Test for Dictionary Keys squares = {1: 1, 3: 9, 5: 25, 7: 49, 9: 81} # Output: True print(1 in squares) # Output: True print(2 not in squares) # membership tests for key only not value # Output: False print(49 in squares) Output\nTrue True False Iterating Through a Dictionary We can iterate through each key in a dictionary using a for loop.\n# Iterating through a Dictionary squares = {1: 1, 3: 9, 5: 25, 7: 49, 9: 81} for i in squares: print(squares[i]) Output\n1 9 25 49 81  Dictionary Built-in Functions Built-in functions like all(), any(), len(), cmp(), sorted(), etc. are commonly used with dictionaries to perform different tasks.\n   Function Description     all() Return True if all keys of the dictionary are True (or if the dictionary is empty).   any() Return True if any key of the dictionary is true. If the dictionary is empty, return False.   len() Return the length (the number of items) in the dictionary.   cmp() Compares items of two dictionaries. (Not available in Python 3)   sorted() Return a new sorted list of keys in the dictionary.    Here are some examples that use built-in functions to work with a dictionary.\n# Dictionary Built-in Functions squares = {0: 0, 1: 1, 3: 9, 5: 25, 7: 49, 9: 81} # Output: False print(all(squares)) # Output: True print(any(squares)) # Output: 6 print(len(squares)) # Output: [0, 1, 3, 5, 7, 9] print(sorted(squares)) Output\nFalse True 6 [0, 1, 3, 5, 7, 9]  Source : https://www.programiz.com/python-programming/dictionary\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/datetime/time_module/",
	"title": "Time Module",
	"tags": [],
	"description": "",
	"content": "Python time Module\nIn this article, we will explore time module in detail. We will learn to use different time-related functions defined in the time module with the help of examples.\nPython has a module named time to handle time-related tasks. To use functions defined in the module, we need to import the module first. Here\u0026rsquo;s how:\nimport time  Here are commonly used time-related functions.\nPython time.time() The time() function returns the number of seconds passed since epoch.\nFor Unix system, January 1, 1970, 00:00:00 at UTC is epoch (the point where time begins).\nimport time seconds = time.time() print(\u0026#34;Seconds since epoch =\u0026#34;, seconds)\t Python time.ctime() The time.ctime() function takes seconds passed since epoch as an argument and returns a string representing local time.\nimport time # seconds passed since epoch seconds = 1545925769.9618232 local_time = time.ctime(seconds) print(\u0026#34;Local time:\u0026#34;, local_time)\tIf you run the program, the output will be something like:\nLocal time: Thu Dec 27 15:49:29 2018  Python time.sleep() The sleep() function suspends (delays) execution of the current thread for the given number of seconds.\nimport time print(\u0026#34;This is printed immediately.\u0026#34;) time.sleep(2.4) print(\u0026#34;This is printed after 2.4 seconds.\u0026#34;) To learn more, visit: Python sleep().\n Before we talk about other time-related functions, let\u0026rsquo;s explore time.struct_time class in brief.\n time.struct_time Class Several functions in the time module such as gmtime(), asctime() etc. either take time.struct_time object as an argument or return it.\nHere\u0026rsquo;s an example of time.struct_time object.\ntime.struct_time(tm_year=2018, tm_mon=12, tm_mday=27, tm_hour=6, tm_min=35, tm_sec=17, tm_wday=3, tm_yday=361, tm_isdst=0)    Index Attribute Values     0 tm_year 0000, \u0026hellip;., 2018, \u0026hellip;, 9999   1 tm_mon 1, 2, \u0026hellip;, 12   2 tm_mday 1, 2, \u0026hellip;, 31   3 tm_hour 0, 1, \u0026hellip;, 23   4 tm_min 0, 1, \u0026hellip;, 59   5 tm_sec 0, 1, \u0026hellip;, 61   6 tm_wday 0, 1, \u0026hellip;, 6; Monday is 0   7 tm_yday 1, 2, \u0026hellip;, 366   8 tm_isdst 0, 1 or -1    The values (elements) of the time.struct_time object are accessible using both indices and attributes.\n Python time.localtime() The localtime() function takes the number of seconds passed since epoch as an argument and returns struct_time in local time.\nimport time result = time.localtime(1545925769) print(\u0026#34;result:\u0026#34;, result) print(\u0026#34;\\nyear:\u0026#34;, result.tm_year) print(\u0026#34;tm_hour:\u0026#34;, result.tm_hour) When you run the program, the output will be something like:\nresult: time.struct_time(tm_year=2018, tm_mon=12, tm_mday=27, tm_hour=15, tm_min=49, tm_sec=29, tm_wday=3, tm_yday=361, tm_isdst=0) year: 2018 tm_hour: 15 If no argument or None is passed to localtime(), the value returned by time() is used.\n Python time.gmtime() The gmtime() function takes the number of seconds passed since epoch as an argument and returns struct_time in UTC.\nimport time result = time.gmtime(1545925769) print(\u0026#34;result:\u0026#34;, result) print(\u0026#34;\\nyear:\u0026#34;, result.tm_year) print(\u0026#34;tm_hour:\u0026#34;, result.tm_hour) When you run the program, the output will be:\nresult = time.struct_time(tm_year=2018, tm_mon=12, tm_mday=28, tm_hour=8, tm_min=44, tm_sec=4, tm_wday=4, tm_yday=362, tm_isdst=0) year = 2018 tm_hour = 8 If no argument or None is passed to gmtime(), the value returned by time() is used.\n Python time.mktime() The mktime() function takes struct_time (or a tuple containing 9 elements corresponding to struct_time) as an argument and returns the seconds passed since epoch in local time. Basically, it\u0026rsquo;s the inverse function of localtime().\nimport time t = (2018, 12, 28, 8, 44, 4, 4, 362, 0) local_time = time.mktime(t) print(\u0026#34;Local time:\u0026#34;, local_time)  The example below shows how mktime() and localtime() are related.\nimport time seconds = 1545925769 # returns struct_time t = time.localtime(seconds) print(\u0026#34;t1: \u0026#34;, t) # returns seconds from struct_time s = time.mktime(t) print(\u0026#34;\\s:\u0026#34;, seconds) When you run the program, the output will be something like:\nt1: time.struct_time(tm_year=2018, tm_mon=12, tm_mday=27, tm_hour=15, tm_min=49, tm_sec=29, tm_wday=3, tm_yday=361, tm_isdst=0) s: 1545925769.0  Python time.asctime() The asctime() function takes struct_time (or a tuple containing 9 elements corresponding to struct_time) as an argument and returns a string representing it. Here\u0026rsquo;s an example:\nimport time t = (2018, 12, 28, 8, 44, 4, 4, 362, 0) result = time.asctime(t) print(\u0026#34;Result:\u0026#34;, result) When you run the program, the output will be:\nResult: Fri Dec 28 08:44:04 2018  Python time.strftime() The strftime() function takes struct_time (or tuple corresponding to it) as an argument and returns a string representing it based on the format code used. For example,\nimport time named_tuple = time.localtime() # get struct_time time_string = time.strftime(\u0026#34;%m/%d/%Y, %H:%M:%S\u0026#34;, named_tuple) print(time_string) When you run the program, the output will be something like:\n12/28/2018, 09:47:41 Here, %Y, %m, %d, %H etc. are format codes.\n %Y - year [0001,\u0026hellip;, 2018, 2019,\u0026hellip;, 9999] %m - month [01, 02, \u0026hellip;, 11, 12] %d - day [01, 02, \u0026hellip;, 30, 31] %H - hour [00, 01, \u0026hellip;, 22, 23 %M - minutes [00, 01, \u0026hellip;, 58, 59] %S - second [00, 01, \u0026hellip;, 58, 61]  To learn more, visit: time.strftime().\n Python time.strptime() The strptime() function parses a string representing time and returns struct_time.\nimport time time_string = \u0026#34;21 June, 2018\u0026#34; result = time.strptime(time_string, \u0026#34;%d%B, %Y\u0026#34;) print(result) When you run the program, the output will be:\ntime.struct_time(tm_year=2018, tm_mon=6, tm_mday=21, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=172, tm_isdst=-1) \n Reference : https://www.programiz.com/python-programming/time\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/advance_topic/",
	"title": "Advance Topics",
	"tags": [],
	"description": "",
	"content": " Source : https://www.programiz.com/python-programming/iterator\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/datetime/sleep/",
	"title": "Time Sleep()",
	"tags": [],
	"description": "",
	"content": "Python sleep()\nThe sleep() function suspends (waits) execution of the current thread for a given number of seconds.\nPython has a module named time which provides several useful functions to handle time-related tasks. One of the popular functions among them is sleep().\nThe sleep() function suspends execution of the current thread for a given number of seconds.\n Example 1: Python sleep() import time print(\u0026#34;Printed immediately.\u0026#34;) time.sleep(2.4) print(\u0026#34;Printed after 2.4 seconds.\u0026#34;) Here\u0026rsquo;s how this program works:\n \u0026quot;Printed immediately\u0026quot; is printed Suspends (Delays) execution for 2.4 seconds. \u0026quot;Printed after 2.4 seconds\u0026quot; is printed.  As you can see from the above example, sleep() takes a floating-point number as an argument.\nBefore Python 3.5, the actual suspension time may be less than the argument specified to the time() function.\nSince Python 3.5, the suspension time will be at least the seconds specified.\n Example 2: Python create a digital clock import time while True: localtime = time.localtime() result = time.strftime(\u0026#34;%I:%M:%S %p\u0026#34;, localtime) print(result) time.sleep(1) In the above program, we computed and printed the current local time inside the infinite while loop. Then, the program waits for 1 second. Again, the current local time is computed and printed. This process goes on.\nWhen you run the program, the output will be something like:\n02:10:50 PM 02:10:51 PM 02:10:52 PM 02:10:53 PM 02:10:54 PM Here is a slightly modified better version of the above program.\nimport time while True: localtime = time.localtime() result = time.strftime(\u0026#34;%I:%M:%S %p\u0026#34;, localtime) print(result, end=\u0026#34;\u0026#34;, flush=True) print(\u0026#34;\\r\u0026#34;, end=\u0026#34;\u0026#34;, flush=True) time.sleep(1) To learn more, visit digital clock in Python shell.\n Multithreading in Python Before talking about sleep() in multithreaded programs, let\u0026rsquo;s talk about processes and threads.\nA computer program is a collection of instructions. A process is the execution of those instructions.\nA thread is a subset of the process. A process can have one or more threads.\n Example 3: Python multithreading All the programs above in this article are single-threaded programs. Here\u0026rsquo;s an example of a multithreaded Python program.\nimport threading def print_hello_three_times(): for i in range(3): print(\u0026#34;Hello\u0026#34;) def print_hi_three_times(): for i in range(3): print(\u0026#34;Hi\u0026#34;) t1 = threading.Thread(target=print_hello_three_times) t2 = threading.Thread(target=print_hi_three_times) t1.start() t2.start() When you run the program, the output will be something like:\nHello Hello Hi Hello Hi Hi The above program has two threads t1 and t2. These threads are run using t1.start() and t2.start() statements.\nNote that, t1 and t2 run concurrently and you might get different output.\nVisit this page to learn more about Multithreading in Python.\n time.sleep() in multithreaded programs The sleep() function suspends execution of the current thread for a given number of seconds.\nIn case of single-threaded programs, sleep() suspends execution of the thread and process. However, the function suspends a thread rather than the whole process in multithreaded programs.\n Example 4: sleep() in a multithreaded program import threading import time def print_hello(): for i in range(4): time.sleep(0.5) print(\u0026#34;Hello\u0026#34;) def print_hi(): for i in range(4): time.sleep(0.7) print(\u0026#34;Hi\u0026#34;) t1 = threading.Thread(target=print_hello) t2 = threading.Thread(target=print_hi) t1.start() t2.start() The above program has two threads. We have used time.sleep(0.5) and time.sleep(0.75) to suspend execution of these two threads for 0.5 seconds and 0.7 seconds respectively.\nRecommended Reading: Python time.sleep() sleeps thread\n Reference : https://www.programiz.com/python-programming/time/sleep\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/learn_python/datetime/",
	"title": "Date and Time",
	"tags": [],
	"description": "",
	"content": " Source : https://www.programiz.com/python-programming/datetime\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/tutorials/date-time/time-module/",
	"title": "Time Module",
	"tags": [],
	"description": "",
	"content": "The Python time module provides many ways of representing time in code, such as objects, numbers, and strings. It also provides functionality other than representing time, like waiting during code execution and measuring the efficiency of your code.\nThis article will walk you through the most commonly used functions and objects in time.\nBy the end of this article, you’ll be able to:\n Understand core concepts at the heart of working with dates and times, such as epochs, time zones, and daylight savings time Represent time in code using floats, tuples, and struct_time Convert between different time representations Suspend thread execution Measure code performance using perf_counter()  You’ll start by learning how you can use a floating point number to represent time.\nFree Bonus: Click here to get our free Python Cheat Sheet that shows you the basics of Python 3, like working with data types, dictionaries, lists, and Python functions.\nRemove ads\nDealing With Python Time Using Seconds One of the ways you can manage the concept of Python time in your application is by using a floating point number that represents the number of seconds that have passed since the beginning of an era—that is, since a certain starting point.\nLet’s dive deeper into what that means, why it’s useful, and how you can use it to implement logic, based on Python time, in your application.\nThe Epoch You learned in the previous section that you can manage Python time with a floating point number representing elapsed time since the beginning of an era.\nMerriam-Webster defines an era as:\n A fixed point in time from which a series of years is reckoned A system of chronological notation computed from a given date as basis  The important concept to grasp here is that, when dealing with Python time, you’re considering a period of time identified by a starting point. In computing, you call this starting point the epoch.\nThe epoch, then, is the starting point against which you can measure the passage of time.\nFor example, if you define the epoch to be midnight on January 1, 1970 UTC—the epoch as defined on Windows and most UNIX systems—then you can represent midnight on January 2, 1970 UTC as 86400 seconds since the epoch.\nThis is because there are 60 seconds in a minute, 60 minutes in an hour, and 24 hours in a day. January 2, 1970 UTC is only one day after the epoch, so you can apply basic math to arrive at that result:\n60 * 60 * 24 # 86400 It is also important to note that you can still represent time before the epoch. The number of seconds would just be negative.\nFor example, you would represent midnight on December 31, 1969 UTC (using an epoch of January 1, 1970) as -86400 seconds.\nWhile January 1, 1970 UTC is a common epoch, it is not the only epoch used in computing. In fact, different operating systems, filesystems, and APIs sometimes use different epochs.\nAs you saw before, UNIX systems define the epoch as January 1, 1970. The Win32 API, on the other hand, defines the epoch as January 1, 1601.\nYou can use time.gmtime() to determine your system’s epoch:\nimport time time.gmtime(0) ## output time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0) You’ll learn about gmtime() and struct_time throughout the course of this article. For now, just know that you can use time to discover the epoch using this function.\nNow that you understand more about how to measure time in seconds using an epoch, let’s take a look at Python’s time module to see what functions it offers that help you do so.\nPython Time in Seconds as a Floating Point Number First, time.time() returns the number of seconds that have passed since the epoch. The return value is a floating point number to account for fractional seconds:\nfrom time import time time() # 1551143536.9323719`  The number you get on your machine may be very different because the reference point considered to be the epoch may be very different.\nFurther Reading: Python 3.7 introduced time_ns(), which returns an integer value representing the same elapsed time since the epoch, but in nanoseconds rather than seconds.\nMeasuring time in seconds is useful for a number of reasons:\n You can use a float to calculate the difference between two points in time. A float is easily serializable, meaning that it can be stored for data transfer and come out intact on the other side.  Sometimes, however, you may want to see the current time represented as a string. To do so, you can pass the number of seconds you get from time() into time.ctime().\nPython Time in Seconds as a String Representing Local Time As you saw before, you may want to convert the Python time, represented as the number of elapsed seconds since the epoch, to a string. You can do so using ctime():\nfrom time import time, ctime t = time() ctime(t) # \u0026#39;Mon Feb 25 19:11:59 2019\u0026#39; Here, you’ve recorded the current time in seconds into the variable t, then passed t as an argument to ctime(), which returns a string representation of that same time.\nTechnical Detail: The argument, representing seconds since the epoch, is optional according to the ctime() definition. If you don’t pass an argument, then ctime() uses the return value of time() by default. So, you could simplify the example above:\nfrom time import ctime ctime() ## \u0026#39;Mon Feb 25 19:11:59 2019\u0026#39; The string representation of time, also known as a timestamp, returned by ctime() is formatted with the following structure:\n Day of the week: Mon (Monday) Month of the year: Feb (February) Day of the month: 25 Hours, minutes, and seconds using the 24-hour clock notation: 19:11:59 Year: 2019  The previous example displays the timestamp of a particular moment captured from a computer in the South Central region of the United States. But, let’s say you live in Sydney, Australia, and you executed the same command at the same instant.\nInstead of the above output, you’d see the following:\nfrom time import time, ctime t = time() ctime(t) ## \u0026#39;Tue Feb 26 12:11:59 2019\u0026#39; Notice that the day of week, day of month, and hour portions of the timestamp are different than the first example.\nThese outputs are different because the timestamp returned by ctime() depends on your geographical location.\nNote: While the concept of time zones is relative to your physical location, you can modify this in your computer’s settings without actually relocating.\nThe representation of time dependent on your physical location is called local time and makes use of a concept called time zones.\nNote: Since local time is related to your locale, timestamps often account for locale-specific details such as the order of the elements in the string and translations of the day and month abbreviations. ctime() ignores these details.\nLet’s dig a little deeper into the notion of time zones so that you can better understand Python time representations.\nUnderstanding Time Zones A time zone is a region of the world that conforms to a standardized time. Time zones are defined by their offset from Coordinated Universal Time (UTC) and, potentially, the inclusion of daylight savings time (which we’ll cover in more detail later in this article).\nFun Fact: If you’re a native English speaker, you might be wondering why the abbreviation for “Coordinated Universal Time” is UTC rather than the more obvious CUT. However, if you’re a native French speaker, you would call it “Temps Universel Coordonné,” which suggests a different abbreviation: TUC.\nUltimately, the International Telecommunication Union and the International Astronomical Union compromised on UTC as the official abbreviation so that, regardless of language, the abbreviation would be the same.\nUTC and Time Zones UTC is the time standard against which all the world’s timekeeping is synchronized (or coordinated). It is not, itself, a time zone but rather a transcendent standard that defines what time zones are.\nUTC time is precisely measured using astronomical time, referring to the Earth’s rotation, and atomic clocks.\nTime zones are then defined by their offset from UTC. For example, in North and South America, the Central Time Zone (CT) is behind UTC by five or six hours and, therefore, uses the notation UTC-5:00 or UTC-6:00.\nSydney, Australia, on the other hand, belongs to the Australian Eastern Time Zone (AET), which is ten or eleven hours ahead of UTC (UTC+10:00 or UTC+11:00).\nThis difference (UTC-6:00 to UTC+10:00) is the reason for the variance you observed in the two outputs from ctime() in the previous examples:\n Central Time (CT): 'Mon Feb 25 19:11:59 2019' Australian Eastern Time (AET): 'Tue Feb 26 12:11:59 2019'  These times are exactly sixteen hours apart, which is consistent with the time zone offsets mentioned above.\nYou may be wondering why CT can be either five or six hours behind UTC or why AET can be ten or eleven hours ahead. The reason for this is that some areas around the world, including parts of these time zones, observe daylight savings time.\nDaylight Savings Time Summer months generally experience more daylight hours than winter months. Because of this, some areas observe daylight savings time (DST) during the spring and summer to make better use of those daylight hours.\nFor places that observe DST, their clocks will jump ahead one hour at the beginning of spring (effectively losing an hour). Then, in the fall, the clocks will be reset to standard time.\nThe letters S and D represent standard time and daylight savings time in time zone notation:\n Central Standard Time (CST) Australian Eastern Daylight Time (AEDT)  When you represent times as timestamps in local time, it is always important to consider whether DST is applicable or not.\nctime() accounts for daylight savings time. So, the output difference listed previously would be more accurate as the following:\n Central Standard Time (CST): 'Mon Feb 25 19:11:59 2019' Australian Eastern Daylight Time (AEDT): 'Tue Feb 26 12:11:59 2019'  Dealing With Python Time Using Data Structures Now that you have a firm grasp on many fundamental concepts of time including epochs, time zones, and UTC, let’s take a look at more ways to represent time using the Python time module.\nPython Time as a Tuple Instead of using a number to represent Python time, you can use another primitive data structure: a tuple.\nThe tuple allows you to manage time a little more easily by abstracting some of the data and making it more readable.\nWhen you represent time as a tuple, each element in your tuple corresponds to a specific element of time:\n Year Month as an integer, ranging between 1 (January) and 12 (December) Day of the month Hour as an integer, ranging between 0 (12 A.M.) and 23 (11 P.M.) Minute Second Day of the week as an integer, ranging between 0 (Monday) and 6 (Sunday) Day of the year Daylight savings time as an integer with the following values:  1 is daylight savings time. 0 is standard time. -1 is unknown.    Using the methods you’ve already learned, you can represent the same Python time in two different ways:\nfrom time import time, ctime t = time() t # 1551186415.360564 ctime(t) # \u0026#39;Tue Feb 26 07:06:55 2019\u0026#39; time_tuple = (2019, 2, 26, 7, 6, 55, 1, 57, 0) In this case, both t and time_tuple represent the same time, but the tuple provides a more readable interface for working with time components.\nTechnical Detail: Actually, if you look at the Python time represented by time_tuple in seconds (which you’ll see how to do later in this article), you’ll see that it resolves to 1551186415.0 rather than 1551186415.360564.\nThis is because the tuple doesn’t have a way to represent fractional seconds.\nWhile the tuple provides a more manageable interface for working with Python time, there is an even better object: struct_time.\nPython Time as an Object The problem with the tuple construct is that it still looks like a bunch of numbers, even though it’s better organized than a single, seconds-based number.\nstruct_time provides a solution to this by utilizing NamedTuple, from Python’s collections module, to associate the tuple’s sequence of numbers with useful identifiers:\nfrom time import struct_time time_tuple = (2019, 2, 26, 7, 6, 55, 1, 57, 0) time_obj = struct_time(time_tuple) time_obj ## output time.struct_time(tm_year=2019, tm_mon=2, tm_mday=26, tm_hour=7, tm_min=6, tm_sec=55, tm_wday=1, tm_yday=57, tm_isdst=0)` Technical Detail: If you’re coming from another language, the terms struct and object might be in opposition to one another.\nIn Python, there is no data type called struct. Instead, everything is an object.\nHowever, the name struct_time is derived from the C-based time library where the data type is actually a struct.\nIn fact, Python’s time module, which is implemented in C, uses this struct directly by including the header file times.h.\nNow, you can access specific elements of time_obj using the attribute’s name rather than an index:\nday_of_year = time_obj.tm_yday day_of_year # 57 day_of_month = time_obj.tm_mday day_of_month # 26  Beyond the readability and usability of struct_time, it is also important to know because it is the return type of many of the functions in the Python time module.\nConverting Python Time in Seconds to an Object Now that you’ve seen the three primary ways of working with Python time, you’ll learn how to convert between the different time data types.\nConverting between time data types is dependent on whether the time is in UTC or local time.\nCoordinated Universal Time (UTC) The epoch uses UTC for its definition rather than a time zone. Therefore, the seconds elapsed since the epoch is not variable depending on your geographical location.\nHowever, the same cannot be said of struct_time. The object representation of Python time may or may not take your time zone into account.\nThere are two ways to convert a float representing seconds to a struct_time:\n UTC Local time  To convert a Python time float to a UTC-based struct_time, the Python time module provides a function called gmtime().\nYou’ve seen gmtime() used once before in this article:\nimport time time.gmtime(0) ## output time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0) You used this call to discover your system’s epoch. Now, you have a better foundation for understanding what’s actually happening here.\ngmtime() converts the number of elapsed seconds since the epoch to a struct_time in UTC. In this case, you’ve passed 0 as the number of seconds, meaning you’re trying to find the epoch, itself, in UTC.\nNote: Notice the attribute tm_isdst is set to 0. This attribute represents whether the time zone is using daylight savings time. UTC never subscribes to DST, so that flag will always be 0 when using gmtime().\nAs you saw before, struct_time cannot represent fractional seconds, so gmtime() ignores the fractional seconds in the argument:\nimport time time.gmtime(1.99) ## output time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=1, tm_wday=3, tm_yday=1, tm_isdst=0) Notice that even though the number of seconds you passed was very close to 2, the .99 fractional seconds were simply ignored, as shown by tm_sec=1.\nThe secs parameter for gmtime() is optional, meaning you can call gmtime() with no arguments. Doing so will provide the current time in UTC:\nimport time time.gmtime() time.struct_time(tm_year=2019, tm_mon=2, tm_mday=28, tm_hour=12, tm_min=57, tm_sec=24, tm_wday=3, tm_yday=59, tm_isdst=0)` Interestingly, there is no inverse for this function within time. Instead, you’ll have to look in Python’s calendar module for a function named timegm():\nimport calendar import time time.gmtime() time.struct_time(tm_year=2019, tm_mon=2, tm_mday=28, tm_hour=13, tm_min=23, tm_sec=12, tm_wday=3, tm_yday=59, tm_isdst=0) calendar.timegm(time.gmtime()) # 1551360204 timegm() takes a tuple (or struct_time, since it is a subclass of tuple) and returns the corresponding number of seconds since the epoch.\nHistorical Context: If you’re interested in why timegm() is not in time, you can view the discussion in Python Issue 6280.\nIn short, it was originally added to calendar because time closely follows C’s time library (defined in time.h), which contains no matching function. The above-mentioned issue proposed the idea of moving or copying timegm() into time.\nHowever, with advances to the datetime library, inconsistencies in the patched implementation of time.timegm(), and a question of how to then handle calendar.timegm(), the maintainers declined the patch, encouraging the use of datetime instead.\nWorking with UTC is valuable in programming because it’s a standard. You don’t have to worry about DST, time zone, or locale information.\nThat said, there are plenty of cases when you’d want to use local time. Next, you’ll see how to convert from seconds to local time so that you can do just that.\nLocal Time In your application, you may need to work with local time rather than UTC. Python’s time module provides a function for getting local time from the number of seconds elapsed since the epoch called localtime().\nThe signature of localtime() is similar to gmtime() in that it takes an optional secs argument, which it uses to build a struct_time using your local time zone:\nimport time time.time() # 1551448206.86196 time.localtime(1551448206.86196) # time.struct_time(tm_year=2019, tm_mon=3, tm_mday=1, tm_hour=7, tm_min=50, tm_sec=6, tm_wday=4, tm_yday=60, tm_isdst=0)`  Notice that tm_isdst=0. Since DST matters with local time, tm_isdst will change between 0 and 1 depending on whether or not DST is applicable for the given time. Since tm_isdst=0, DST is not applicable for March 1, 2019.\nIn the United States in 2019, daylight savings time begins on March 10. So, to test if the DST flag will change correctly, you need to add 9 days’ worth of seconds to the secs argument.\nTo compute this, you take the number of seconds in a day (86,400) and multiply that by 9 days:\nnew_secs = 1551448206.86196 + (86400 * 9) time.localtime(new_secs) # time.struct_time(tm_year=2019, tm_mon=3, tm_mday=10, tm_hour=8, tm_min=50, tm_sec=6, tm_wday=6, tm_yday=69, tm_isdst=1)`  Now, you’ll see that the struct_time shows the date to be March 10, 2019 with tm_isdst=1. Also, notice that tm_hour has also jumped ahead, to 8 instead of 7 in the previous example, because of daylight savings time.\nSince Python 3.3, struct_time has also included two attributes that are useful in determining the time zone of the struct_time:\n tm_zone tm_gmtoff  At first, these attributes were platform dependent, but they have been available on all platforms since Python 3.6.\nFirst, tm_zone stores the local time zone:\nimport time current_local = time.localtime() current_local.tm_zone # \u0026#39;CST\u0026#39; Here, you can see that localtime() returns a struct_time with the time zone set to CST (Central Standard Time).\nAs you saw before, you can also tell the time zone based on two pieces of information, the UTC offset and DST (if applicable):\nimport time current_local = time.localtime() current_local.tm_gmtoff # -21600 current_local.tm_isdst # 0  In this case, you can see that current_local is 21600 seconds behind GMT, which stands for Greenwich Mean Time. GMT is the time zone with no UTC offset: UTC±00:00.\n21600 seconds divided by seconds per hour (3,600) means that current_local time is GMT-06:00 (or UTC-06:00).\nYou can use the GMT offset plus the DST status to deduce that current_local is UTC-06:00 at standard time, which corresponds to the Central standard time zone.\nLike gmtime(), you can ignore the secs argument when calling localtime(), and it will return the current local time in a struct_time:\nimport time time.localtime() time.struct_time(tm_year=2019, tm_mon=3, tm_mday=1, tm_hour=8, tm_min=34, tm_sec=28, tm_wday=4, tm_yday=60, tm_isdst=0)` Unlike gmtime(), the inverse function of localtime() does exist in the Python time module. Let’s take a look at how that works.\nConverting a Local Time Object to Seconds You’ve already seen how to convert a UTC time object to seconds using calendar.timegm(). To convert local time to seconds, you’ll use mktime().\nmktime() requires you to pass a parameter called t that takes the form of either a normal 9-tuple or a struct_time object representing local time:\nimport time time_tuple = (2019, 3, 10, 8, 50, 6, 6, 69, 1) time.mktime(time_tuple) # 1552225806.0 time_struct = time.struct_time(time_tuple) time.mktime(time_struct) # 1552225806.0`  It’s important to keep in mind that t must be a tuple representing local time, not UTC:\nfrom time import gmtime, mktime # 1 current_utc = time.gmtime() current_utc time.struct_time(tm_year=2019, tm_mon=3, tm_mday=1, tm_hour=14, tm_min=51, tm_sec=19, tm_wday=4, tm_yday=60, tm_isdst=0) # 2 current_utc_secs = mktime(current_utc) current_utc_secs # 1551473479.0 # 3 time.gmtime(current_utc_secs) time.struct_time(tm_year=2019, tm_mon=3, tm_mday=1, tm_hour=20, tm_min=51, tm_sec=19, tm_wday=4, tm_yday=60, tm_isdst=0)` Note: For this example, assume that the local time is March 1, 2019 08:51:19 CST.\nThis example shows why it’s important to use mktime() with local time, rather than UTC:\n  gmtime() with no argument returns a struct_time using UTC. current_utc shows March 1, 2019 14:51:19 UTC. This is accurate because CST is UTC-06:00, so UTC should be 6 hours ahead of local time.\n  mktime() tries to return the number of seconds, expecting local time, but you passed current_utc instead. So, instead of understanding that current_utc is UTC time, it assumes you meant March 1, 2019 14:51:19 CST.\n  gmtime() is then used to convert those seconds back into UTC, which results in an inconsistency. The time is now March 1, 2019 20:51:19 UTC. The reason for this discrepancy is the fact that mktime() expected local time. So, the conversion back to UTC adds another 6 hours to local time.\n  Working with time zones is notoriously difficult, so it’s important to set yourself up for success by understanding the differences between UTC and local time and the Python time functions that deal with each.\nConverting a Python Time Object to a String While working with tuples is fun and all, sometimes it’s best to work with strings.\nString representations of time, also known as timestamps, help make times more readable and can be especially useful for building intuitive user interfaces.\nThere are two Python time functions that you use for converting a time.struct_time object to a string:\n asctime() strftime()  You’ll begin by learning aboutasctime().\nasctime() You use asctime() for converting a time tuple or struct_time to a timestamp:\nimport time time.asctime(time.gmtime()) # \u0026#39;Fri Mar 1 18:42:08 2019\u0026#39; time.asctime(time.localtime()) # \u0026#39;Fri Mar 1 12:42:15 2019\u0026#39;`  Both gmtime() and localtime() return struct_time instances, for UTC and local time respectively.\nYou can use asctime() to convert either struct_time to a timestamp. asctime() works similarly to ctime(), which you learned about earlier in this article, except instead of passing a floating point number, you pass a tuple. Even the timestamp format is the same between the two functions.\nAs with ctime(), the parameter for asctime() is optional. If you do not pass a time object to asctime(), then it will use the current local time:\nimport time time.asctime() # \u0026#39;Fri Mar 1 12:56:07 2019\u0026#39;`  As with ctime(), it also ignores locale information.\nOne of the biggest drawbacks of asctime() is its format inflexibility. strftime() solves this problem by allowing you to format your timestamps.\nstrftime() You may find yourself in a position where the string format from ctime() and asctime() isn’t satisfactory for your application. Instead, you may want to format your strings in a way that’s more meaningful to your users.\nOne example of this is if you would like to display your time in a string that takes locale information into account.\nTo format strings, given a struct_time or Python time tuple, you use strftime(), which stands for “string format time.”\nstrftime() takes two arguments:\n format specifies the order and form of the time elements in your string. t is an optional time tuple.  To format a string, you use directives. Directives are character sequences that begin with a % that specify a particular time element, such as:\n %d: Day of the month %m: Month of the year %Y: Year  For example, you can output the date in your local time using the ISO 8601 standard like this:\nimport time time.strftime(\u0026#39;%Y-%m-%d\u0026#39;, time.localtime()) # \u0026#39;2019-03-01\u0026#39;`  Further Reading: While representing dates using Python time is completely valid and acceptable, you should also consider using Python’s datetime module, which provides shortcuts and a more robust framework for working with dates and times together.\nFor example, you can simplify outputting a date in the ISO 8601 format using datetime:\nfrom datetime import date date(year=2019, month=3, day=1).isoformat() #\u0026#39;2019-03-01\u0026#39;`  As you saw before, a great benefit of using strftime() over asctime() is its ability to render timestamps that make use of locale-specific information.\nFor example, if you want to represent the date and time in a locale-sensitive way, you can’t use asctime():\nfrom time import asctime asctime() # \u0026#39;Sat Mar 2 15:21:14 2019\u0026#39; import locale locale.setlocale(locale.LC_TIME, \u0026#39;zh_HK\u0026#39;) # Chinese - Hong Kong # \u0026#39;zh_HK\u0026#39; asctime() # \u0026#39;Sat Mar 2 15:58:49 2019\u0026#39;`  Notice that even after programmatically changing your locale, asctime() still returns the date and time in the same format as before.\nTechnical Detail: LC_TIME is the locale category for date and time formatting. The locale argument 'zh_HK' may be different, depending on your system.\nWhen you use strftime(), however, you’ll see that it accounts for locale:\nfrom time import strftime, localtime strftime(\u0026#39;%c\u0026#39;, localtime()) # \u0026#39;Sat Mar 2 15:23:20 2019\u0026#39; import locale locale.setlocale(locale.LC_TIME, \u0026#39;zh_HK\u0026#39;) # Chinese - Hong Kong # \u0026#39;zh_HK\u0026#39; strftime(\u0026#39;%c\u0026#39;, localtime()) # \u0026#39;六 3/ 2 15:58:12 2019\u0026#39; 2019\u0026#39; Here, you have successfully utilized the locale information because you used strftime().\nNote: %c is the directive for locale-appropriate date and time.\nIf the time tuple is not passed to the parameter t, then strftime() will use the result of localtime() by default. So, you could simplify the examples above by removing the optional second argument:\nfrom time import strftime strftime(\u0026lsquo;The current local datetime is: %c\u0026rsquo;) \u0026lsquo;The current local datetime is: Fri Mar 1 23:18:32 2019'`\nHere, you’ve used the default time instead of passing your own as an argument. Also, notice that the format argument can consist of text other than formatting directives.\nFurther Reading: Check out this thorough list of directives available to strftime().\nThe Python time module also includes the inverse operation of converting a timestamp back into a struct_time object.\nConverting a Python Time String to an Object When you’re working with date and time related strings, it can be very valuable to convert the timestamp to a time object.\nTo convert a time string to a struct_time, you use strptime(), which stands for “string parse time”:\nfrom time import strptime strptime(\u0026#39;2019-03-01\u0026#39;, \u0026#39;%Y-%m-%d\u0026#39;) time.struct_time(tm_year=2019, tm_mon=3, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=60, tm_isdst=-1)` The first argument to strptime() must be the timestamp you wish to convert. The second argument is the format that the timestamp is in.\nThe format parameter is optional and defaults to '%a %b %d %H:%M:%S %Y'. Therefore, if you have a timestamp in that format, you don’t need to pass it as an argument:\nstrptime(\u0026#39;Fri Mar 01 23:38:40 2019\u0026#39;) time.struct_time(tm_year=2019, tm_mon=3, tm_mday=1, tm_hour=23, tm_min=38, tm_sec=40, tm_wday=4, tm_yday=60, tm_isdst=-1)` Since a struct_time has 9 key date and time components, strptime() must provide reasonable defaults for values for those components it can’t parse from string.\nIn the previous examples, tm_isdst=-1. This means that strptime() can’t determine by the timestamp whether it represents daylight savings time or not.\nNow you know how to work with Python times and dates using the time module in a variety of ways. However, there are other uses for time outside of simply creating time objects, getting Python time strings, and using seconds elapsed since the epoch.\nSuspending Execution One really useful Python time function is sleep(), which suspends the thread’s execution for a specified amount of time.\nFor example, you can suspend your program’s execution for 10 seconds like this:\nfrom time import sleep, strftime strftime(\u0026#39;%c\u0026#39;) # \u0026#39;Fri Mar 1 23:49:26 2019\u0026#39; sleep(10) strftime(\u0026#39;%c\u0026#39;) # \u0026#39;Fri Mar 1 23:49:36 2019\u0026#39;`  Your program will print the first formatted datetime string, then pause for 10 seconds, and finally print the second formatted datetime string.\nYou can also pass fractional seconds to sleep():\nfrom time import sleep sleep(0.5)` sleep() is useful for testing or making your program wait for any reason, but you must be careful not to halt your production code unless you have good reason to do so.\nBefore Python 3.5, a signal sent to your process could interrupt sleep(). However, in 3.5 and later, sleep() will always suspend execution for at least the amount of specified time, even if the process receives a signal.\nsleep() is just one Python time function that can help you test your programs and make them more robust.\nMeasuring Performance You can use time to measure the performance of your program.\nThe way you do this is to use perf_counter() which, as the name suggests, provides a performance counter with a high resolution to measure short distances of time.\nTo use perf_counter(), you place a counter before your code begins execution as well as after your code’s execution completes:\nfrom time import perf_counter def longrunning_function(): ... for i in range(1, 11): ... time.sleep(i / i ** 2) ... start = perf_counter() longrunning_function() end = perf_counter() execution_time = (end - start) execution_time # 8.201258441999926`  First, start captures the moment before you call the function. end captures the moment after the function returns. The function’s total execution time took (end - start) seconds.\nTechnical Detail: Python 3.7 introduced perf_counter_ns(), which works the same as perf_counter(), but uses nanoseconds instead of seconds.\nperf_counter() (or perf_counter_ns()) is the most precise way to measure the performance of your code using one execution. However, if you’re trying to accurately gauge the performance of a code snippet, I recommend using the Python timeit module.\ntimeit specializes in running code many times to get a more accurate performance analysis and helps you to avoid oversimplifying your time measurement as well as other common pitfalls.\nConclusion Congratulations! You now have a great foundation for working with dates and times in Python.\nNow, you’re able to:\n Use a floating point number, representing seconds elapsed since the epoch, to deal with time Manage time using tuples and struct_time objects Convert between seconds, tuples, and timestamp strings Suspend the execution of a Python thread Measure performance using perf_counter()  On top of all that, you’ve learned some fundamental concepts surrounding date and time, such as:\n Epochs UTC Time zones Daylight savings time  Now, it’s time for you to apply your newfound knowledge of Python time in your real world applications!\nFurther Reading If you want to continue learning more about using dates and times in Python, take a look at the following modules:\n datetime: A more robust date and time module in Python’s standard library timeit: A module for measuring the performance of code snippets astropy: Higher precision datetimes used in astronomy   Source : .\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/beginer/string_output/",
	"title": "การแสดงผลตัวอักษร",
	"tags": [],
	"description": "",
	"content": "การใช้อักษรพิเศษที่มีหน้าที่เฉพาะ ปกติแล้วข้อความที่พิมพ์ป้อนให้สายอักขระมักจะแสดงผลตามที่ป้อนเข้าไปทั้งหมด แต่ก็มีอักษรบางตัวที่มีหน้าที่พิเศษภายในสายอักขระ ได้แก่ ' \u0026quot; \\ % เวลาต้องการใส่อักษรเหล่านี้ ลงในสายอักขระจึงอาจต้องระวัง สายอักขระจะสร้างขึ้นจากการใช้เครื่องหมายคำพูดแบบเดี่ยว ' หรือแบบคู่ \u0026quot; ล้อมข้อความ แต่ว่าหากต้องการให้มี ' หรือ \u0026quot; อยู่ในสายอักขระแล้วละก็ ต้องระวังเพราะอาจทำให้โปรแกรมตีความผิดเข้าใจว่า ตัดจบหรือเริ่มสายอักขระใหม่ได้ ดังนั้นจึงต้องหาวิธีเลี่ยง วิธีที่ง่ายที่สุดคือการใช้อีกตัวแทน เช่น ถ้าต้องการข้อความที่มี ' อยู่ก็ต้องใช้ \u0026quot;\u0026rdquo; เป็นตัวครอบ\nprint(\u0026#34;คำว่า \u0026#39;รัก\u0026#39; มันยากจะอธิบาย\u0026#34;) ในทางกลับกันถ้าต้องการข้อความที่มี \u0026quot; อยู่ก็ต้องใช้ ' ' เป็นตัวครอบ แต่ถ้าต้องการ ใช้ทั้งสองตัวทีเดียวเลี่ยงไม่ได้จริงๆก็ต้องใช้แบ็กสแลช \\ ช่วย\nprint(\u0026#34;เครื่องหมายคำพูดมีแบบเดี่ยว \u0026#39; \u0026#39; และแบบคู่ \\\u0026#34;\\\u0026#34;\u0026#34;) ผลที่แสดงออกมา\nเครื่องหมายคำพูดมีแบบเดี่ยว \u0026#39; \u0026#39; และแบบคู่ \u0026#34; \u0026#34; เอสเคปคาแร็กเตอร์ นอกจากแบ็กสแลชจะทำหน้าที่นำหน้าอักษรที่มีหน้าที่เฉพาะเพื่อให้ปรากฏตามที่เห็นโดยไม่ถูกตีความแล้ว มีอักษรหลายตัวที่นำหน้าด้วยแบ็กสแลช \\ แล้วมีความหมายพิเศษ ซึ่งเรียกว่า เอสเคปคาแร็กเตอร์ (escape character)\n\\n คือ ขึ้นบรรทัดใหม่ \\t คือ เคาะเว้นย่อหน้า \\b คือ แบ็กสเปซ (ลบตัวอักษร) \\a คือ ส่งเสียงเตือน ตัวอย่าง\nprint(\u0026#39;ma\\bc\u0026#39;) # ได้ mc (เพราะ a ถูกลบ)  print(\u0026#39;a\\ta\u0026#39;) # ได้ a a  print(\u0026#39;\\a\u0026#39;) # จะได้ยินเสียงเตือนดังขึ้นมา หาก \\ ตามด้วยตัวอักษรที่รวมแล้วไม่ได้มีความหมายพิเศษก็จะปรากฏตามที่พิมพ์ไป\nprint(\u0026#39;\\s\u0026#39;) # ได้ \\s แต่หาก \\ ตามด้วยอักษรที่รวมแล้วมีความหมายพิเศษ เช่น n t b a ก็จะเกิดการตีความแล้วให้ผลที่ต่างออกจากที่พิมพ์ ในกรณีที่ต้องการหลีกเลี่ยงไม่ให้เป็นเช่นนั้นสามารถทำได้โดยเขียน \\ ติดกัน ๒ ขีด เป็น \\ เช่น\nprint(\u0026#39;\\\\n\u0026#39;) # ได้ \\n จะเห็นว่ามี \\ ปรากฏขึ้นแค่ตัวเดียว เพราะ \\ ถูกตีความเป็น \\ ตัวเดียว หากต้องการ ๒ ตัวก็พิมพ์ ๔ ตัว\nprint(\u0026#39;\\\\\\\\\u0026#39;) # ได้ \\\\ หากไม่ต้องการให้เอสเคปคาแร็กเตอร์ทำงานเลยก็สามารถทำได้โดยใส่ r ลงไปหน้าเครื่องหมายคำพูด แล้วสายอักขระนั้นจะถูกมองเป็นตัวอักษรตามที่พิมพ์ลงไปทั้งหมด\nprint(r\u0026#39;\\n\\t\\b\\a\u0026#39;) # ได้ \\n\\t\\b\\a ยูนิโค้ด ในสายอักขระสามารถใช้โค้ดในระบบยูนิโค้ดเพื่อแทนตัวอักษรได้ โค้ดจะถูกแปลงเป็นตัวอักษร วิธีการใช้ทำได้โดยใช้ \\u \\U และ \\X\n \\uคคคค ระบุอักษรด้วยรหัสยูนิโค้ดแบบ utf-16 (ค แทนเลขฐาน 16 ทั้งหมด 4 ตัว) \\Uคคคคคคคค ระบุอักษรด้วยรหัสยูนิโค้ดแบบ utf-32 (ค แทนเลขฐาน 16 ทั้งหมด 8 ตัว) \\N{ชื่ออักษร} คือ ระบุอักษรด้วยชื่อที่ถูกเก็บในฐานข้อมูลของยูนิโค้ด  ตัวอย่าง\nprint(\u0026#39;\\u0e2e\u0026#39;) # ได้ ฮ  print(\u0026#39;\\U00000e0e\u0026#39;) # ได้ ฎ  print(\u0026#34;\\N{Thai Character Pho Phan}\u0026#34;) # ได้ พ ในไพธอน 2 จะได้ผลต่างออกไป จำเป็นต้องเติม u นำหน้า อ่านรายละเอียดได้ที่\nการเปลี่ยนรูปแบบการแสดงผลของข้อความ ในการแสดงผลข้อมูลที่เป็นตัวเลขนั้นจะเห็นว่าหากสั่ง print ค่าตัวเลขนั้นโดยตรง จะได้ลักษณะที่มีค่าตายตัวแบบหนึ่ง เช่น จำนวนจริงที่เป็นจำนวนเต็ม จะมีศูนย์หลังจุดแค่ตัวเดียวเสมอ หรือเลขทศนิยมที่เล็กมากหรือใหญ่มากจะถูกเขียนในรูป e เช่น\nprint(3.000000000) # ได้ 3.0  print(0.00000000003) # ได้ 3e-11  print(300000000000000000.) # ได้ 3e+17 แต่ก็มีวิธีที่จะเปลี่ยนการแสดงผลเมื่อใช้คำสั่ง print หรือเมื่อแปลงเป็นสายอักขระได้ ซึ่งทำได้โดยเขียนให้อยู่ในรูปของ %d, %e, %f, ฯลฯ\nการแสดงจำนวนเต็ม %d ใช้แทนจำนวนเต็มที่แทรกอยู่ภายในสายอักขระ โดยค่าของจำนวนเต็ม ที่จะคำนวณนั้นต้องใส่ไว้ด้านหลังเครื่องหมายคำพูด\ni = 20 print(\u0026#39;==%d==\u0026#39;%i) # ได้ ==20== จากตัวอย่างจะเห็นว่าค่าของ i เข้าไปแทนที่ %d สิ่งที่อาจชวนสับสนก็คือ รูปแบบการเขียนแบบนี้มีการใช้เครื่องหมาย % ถึง ๒ ครั้ง แต่ว่า % ทั้ง ๒ นี้เป็นคนละความหมายกัน % ตัวแรกอยู่ภายในเครื่องหมายคำพูด วางอยู่ในตำแหน่งที่ต้องการให้ค่าตัวเลขไปอยู่ แล้วก็ตามด้วยชนิดของข้อมูลที่ต้องการแทน ในที่นี้เป็นจำนวนเต็มใช้ d ส่วน % ตัวหลังอยู่หลังเครื่องหมายคำพูด โดยตามหลังด้วยค่าที่ต้องการนำไปแทน โดยอาจเป็นตัวเลขหรือเป็นตัวแปรก็ได้ การเปลี่ยนการแสดงผลทำได้โดยใส่ส่วนแต่งเติมลงหลัง % ตัวหน้า\nprint(\u0026#39;==%4d==\u0026#39;%19) # ได้ == 19== ให้เพิ่มช่องว่างจนครบ 4 ตำแหน่ง  print(\u0026#39;==%4d==\u0026#39;%19000) # ==19000== ถ้าเลขเกิน 4 อยู่แล้วไม่มีผล  print(\u0026#39;==%04d==\u0026#39;%19) # ได้ ==0019== ให้ใส่เลข 0 จนถึง 4 ตำแหน่ง  print(\u0026#39;==%04d==\u0026#39;%19000) # ==19000== ถ้าเลขเกิน 4 อยู่แล้วไม่มีผล  print(\u0026#39;==%+d==\u0026#39;%19) # ได้ ==+19== ให้ใส่เครื่องหมาย + เมื่อเป็นค่าบวก  print(\u0026#39;==%+d==\u0026#39;%-19) # ได้ ==-19== ถ้าเป็นลบอยู่แล้วไม่มีผล  print(\u0026#39;==%+04d==\u0026#39;%19) # ได้ ==+019== 4 ตำแหน่งนี้นับรวมเครื่องหมายด้วย ตัวอย่าง ไล่เรียงหมายเลขโดยขึ้นเป็น ๒ หลัก\ns = [\u0026#39;no.%02d\u0026#39;%i for i in range(1,21)] print(s) # ได้ [\u0026#39;no.01\u0026#39;, \u0026#39;no.02\u0026#39;, \u0026#39;no.03\u0026#39;, \u0026#39;no.04\u0026#39;, \u0026#39;no.05\u0026#39;, \u0026#39;no.06\u0026#39;, \u0026#39;no.07\u0026#39;, \u0026#39;no.08\u0026#39;, \u0026#39;no.09\u0026#39;, \u0026#39;no.10\u0026#39;, \u0026#39;no.11\u0026#39;, \u0026#39;no.12\u0026#39;, \u0026#39;no.13\u0026#39;, \u0026#39;no.14\u0026#39;, \u0026#39;no.15\u0026#39;, \u0026#39;no.16\u0026#39;, \u0026#39;no.17\u0026#39;, \u0026#39;no.18\u0026#39;, \u0026#39;no.19\u0026#39;, \u0026#39;no.20\u0026#39;] หากมีส่วนที่ต้องการแทรกอยู่หลายตัวก็ให้ใส่ตัวแปรตามจำนวนนั้นโดยใส่วงเล็บแล้วคั่นด้วยจุลภาค ,ตัวอย่าง แสดงวันเดือนปี\nprint(\u0026#39;%02d/ %02d/ %04d\u0026#39;%(9,2,2016)) # ได้ 09 / 02 / 2016 แปลงเลขเป็นฐาน 16 นอกจาก %d ที่ให้แสดงเลขตามปกติเป็นฐาน 10 ที่เราคุ้นเคยกันดีแล้ว หากแทนด้วย %x ก็จะได้ค่าเป็นเลขฐาน 16 แทน\nprint(\u0026#39;%x\u0026#39;%(2**16-1)) # ได้ ffff  print(\u0026#39;%x\u0026#39;%(27365824924)) # ได้ 65f21599c  print(\u0026#39;%09x\u0026#39;%1000) # ได้ 0000003e8 เลขฐาน 16 มีประโยชน์ เพราะใช้แทนค่ารหัสสีซึ่งมักประกอบไปด้วยค่าของเลขฐาน 16 ของค่าแม่สีทั้งสาม\nprint(\u0026#39;#%02x%02x%02x\u0026#39;%(10,252,90)) # ได้#0afc5a การแสดงเลขจำนวนจริง จำนวนจริงใช้ %f ในการแสดง สามารถปรับตำแหน่งหลักและตำแหน่งเลขทศนิยมได้\nprint(\u0026#39;==%12f==\u0026#39;%129.3) # ได้ == 129.300000== เติมช่องว่างจนครบ 12 ตำแหน่ง  print(\u0026#39;==%012f==\u0026#39;%129.3) # ได้ ==00129.300000== เติม 0 จนครบ 12 ตำแหน่ง  print(\u0026#39;==%.3f==\u0026#39;%129.3) # ได้ ==129.300== ทศนิยม 3 ตำแหน่ง  print(\u0026#39;==%.0f==\u0026#39;%129.3) # ได้ ==129== เศษถูกปัดทิ้ง  print(\u0026#39;==%12.3f==\u0026#39;%129.3) # ได้ == 129.300==  print(\u0026#39;==%012.3f==\u0026#39;%129.3) # ได้ ==00000129.300== อีกวิธีในการแสดงผลก็คือใช้ %e ซึ่งจะแสดงเป็นตัวเลขในรูปแบบ e\npi = 3.14159 print(\u0026#39;==%e==\u0026#39;%pi) # ได้ ==3.141590e+00==  print(\u0026#39;==%15e==\u0026#39;%pi) # ได้ == 3.141590e+00==  print(\u0026#39;==%015e==\u0026#39;%pi) # ได้ ==0003.141590e+00==  print(\u0026#39;==%.8e==\u0026#39;%pi) # ได้ ==3.14159000e+00==  print(\u0026#39;==%.2e==\u0026#39;%pi) # ได้ ==3.14e+00==  print(\u0026#39;==%015.8e==\u0026#39;%pi) # ได้ ==3.14e+00== นอกจากนี้ยังมี %s ซึ่งแสดงผลสายอักขระเอง\nprint(\u0026#39;==%s==\u0026#39;%\u0026#39;asa\u0026#39;) # ได้ ==asa==  print(\u0026#39;==%5s==\u0026#39;%\u0026#39;asa\u0026#39;) # ได้ == asa6== โดย %s นี้ยังใช้กับข้อมูลชนิดกลุ่มเช่นลิสต์หรือทูเพิลได้ด้วย ผลที่ได้จะเหมือนกับเวลาที่ print ลิสต์หรือทูเพิลนั้นออกมาโดดๆ\nprint(\u0026#39;==%s==\u0026#39;%[1,2]) # ได้ ==[1, 2]==  print(\u0026#39;==%25s==\u0026#39;%[\u0026#39;a\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;a\u0026#39;]) # ได้ == [\u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;a\u0026#39;]== สำหรับลิสต์ไม่มีปัญหาอะไร แต่กรณีที่ต้องการใช้กับทูเพิลจะมีความยุ่งยากเล็กน้อย เนื่องจากโดยทั่วไปเมื่อมีทูเพิลอยู่หลัง % จะถูกตีความว่าเป็นการใส่ข้อมูลหลายตัว ดังนั้นต้องเขียนในรูปทูเพิลซ้อนทูเพิล\nprint(\u0026#39;==%s==\u0026#39;%(\u0026#39;a\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;a\u0026#39;)) # ได้ TypeError: not all arguments converted during string formatting  print(\u0026#39;==%s%s%s==\u0026#39;%(\u0026#39;a\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;a\u0026#39;)) # ได้ ==a s a==  print(\u0026#39;==%s==\u0026#39;%((\u0026#39;a\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;a\u0026#39;),)) # ได้ ==(\u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;a\u0026#39;)== กรณีที่มีข้อมูลมาแทนเป็นจำนวนไม่เท่ากันกับจำนวน % ที่อยู่ด้านหน้า หรือชนิดผิด ก็จะขัดข้องทันที\nprint(\u0026#39;==%s,%s==\u0026#39;%\u0026#39;asa\u0026#39;) # ได้ TypeError: not enough arguments for format string  print(\u0026#39;==%f==\u0026#39;%\u0026#39;asa\u0026#39;) # ได้ TypeError: a float is required กรณีมี % ตัวอื่นอยู่ในสายอักขระและไม่ได้ต้องการให้แสดงผลด้วยเลยให้ใส่ % นำหน้าอีกตัว\nprint(\u0026#39;==%.2f%%formaldehyde==\u0026#39;%70) # ได้ ==70%formaldehyde== สรุปเนื้อหา  ในบทนี้ได้เข้าใจรูปแบบการแสดงผลของสายอักขระแล้ว เมื่อเข้าใจแล้ว ก็จะสามารถเปลี่ยนผลให้ออกมาได้ตามที่ต้องการ ต้องระวังการใช้เอสเคปคาแร็กเตอร์ \\n \\t \\b \\a ' \u0026quot; \\ ให้ดี เวลาที่แปลงตัวเลขเป็นสายอักขระมักถูกตีความในรูปแบบที่ถูกกำหนดมาแล้ว แต่ด้วย %d %x %f %e สามารถเปลี่ยนให้หลากหลายขึ้นได้  อ้างอิง\n http://docs.python.jp/3/howto/unicode.html http://www.tohoho-web.com/python/types.html http://www.isl.ne.jp/pcsp/python/python18.html   Reference : https://phyblas.hinaboshi.com/tsuchinoko10\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/beginer/string_format/",
	"title": "การจัดการกับสายอักขระ",
	"tags": [],
	"description": "",
	"content": "ความยาวของสายอักขระ สายอักขระอาจยาวเท่าใดก็ได้ การหาความยาวของสายอักขระทำได้เช่นเดียวกับลิสต์หรือทูเพิล คือใช้ฟังก์ชัน len\nprint(len(\u0026#39;กขคงจ\u0026#39;)) # ได้ 5 สายอักขระอาจจะมีความยาวเป็นศูนย์ก็ได้ ซึ่งเขียนแทนด้วยเครื่องหมายคำพูดติดกันสองตัวโดยไม่มีอะไรข้างใน\nprint(len(\u0026#39;\u0026#39;)) # ได้ 0 ช่องว่างจะถูกนับรวมความยาวด้วย ต่อให้ไม่ได้อยู่ตรงกลางก็ตาม\nprint(len(\u0026#39; \u0026#39;)) # ได้ 2 ภายในสายอักขระอักษรทุกตัวมีความยาวตัวละหน่วยเท่ากันหมด ไม่ว่าจะเป็นอักษรอะไรก็ตาม จะเป็นอักษร ASCII หรือไม่ก็ตาม\n***ข้อนี้สำหรับไพธอน 3 ส่วนในไพธอน 2 จะแตกต่างออกไป รายละเอียด\nการเข้าถึงสมาชิกของสายอักขระ สายอักขระก็เป็นข้อมูลชนิดลำดับเช่นเดียวกับลิสต์หรือทูเพิล ดังนั้นสามารถเข้าถึงข้อมูลได้โดยใส่ลำดับสมาชิกในวงเล็บเหลี่ยม\na = \u0026#39;bestuurdersaansprakelijkheidsverzekering\u0026#39; print(a[0]) # ได้ b  print(a[-1]) # ได้ g  print(a[int(len(a)/2)]) # ได้ l สามารถเข้าถึงทีละหลายตัวด้วยการใช้ : เช่นกัน\na[29:40] # ได้ verzekering  a[0:40:2] # ได้ \u0026#39;bsuresasrkljhisezkrn\u0026#39; การแก้ไขและเพิ่มข้อความในสายอักขระ\nสายอักขระไม่สามารถแก้ไขข้อมูลอะไรได้ เช่นเดียวกับทูเพิล\nb = \u0026#39;เขาเป็นคนป่วย\u0026#39; b[9:11] = \u0026#39;ร\u0026#39; # ได้ TypeError: \u0026#39;str\u0026#39; object does not support item assignment แม้ว่าจะไม่สามารถแก้ไขข้อความข้างในได้ แต่ก็สามารถสร้างใหม่ทับตัวเก่าได้\nb = b[:9]+\u0026#39;ร\u0026#39;+b[11:] print(b) # ได้ เขาเป็นคนรวย ส่วนการเพิ่มข้อความในสายอักขระก็ทำได้โดยเอาสายอักขระเดิมมาบวกกับสิ่งที่ต้องการเพิ่ม\nc = \u0026#39;เขาเป็นคนดี\u0026#39; c += \u0026#39;แต่พูด\u0026#39; print(c) # ได้ เขาเป็นคนดีแต่พูด การเปรียบเทียบสายอักขระ สายอักขระสามารถนำมาทำการเปรียบเทียบเพื่อหาค่าความจริงเท็จได้โดย เมื่อใช้เครื่องหมาย == จะให้ค่าเป็นจริงต่อเมื่อเหมือนกันทุกตัวอักษร\nprint(\u0026#39;J\u0026#39; == \u0026#39;j\u0026#39;) # False เพราะพิมพ์เล็กกับพิมพ์ใหญ่ถือเป็นคนละตัว  print(\u0026#39;J\u0026#39; == \u0026#39;j\u0026#39;.upper()) #True เมื่อใช้เปรียบเทียบมากกว่า \u0026gt; หรือน้อยกว่า \u0026lt; จะเปรียบเทียบลำดับภายในยูนิโค้ดของอักษรนั้นทีละตัว โดยเลขที่มาก่อนถือว่าค่าน้อยกว่า หากเหมือนกันจึงจะพิจารณาตัวต่อไป\nprint(\u0026#39;11\u0026#39; \u0026gt; \u0026#39;2\u0026#39;) # False เพราะเลข 1 เทียบกับ 2 ก่อน  print(\u0026#39;A\u0026#39; \u0026gt; \u0026#39;a\u0026#39;) # False เพราะตัวพิมพ์ใหญ่มาก่อนตัวพิมพ์เล็ก  print(\u0026#39;ü\u0026#39; \u0026gt; \u0026#39;z\u0026#39;) # True เพราะ z เป็น ASCII แต่ ü ไม่ใช่  print(\u0026#39;ม\u0026#39; \u0026gt; \u0026#39;美\u0026#39;) # False เพราะอักษรไทยมาก่อนอักษรจีนในยูนิโค้ด  print(\u0026#39;ア\u0026#39; \u0026gt; \u0026#39;あ\u0026#39;) # True เพราะฮิรางานะมาก่อนคาตาคานะ การตัดช่องว่างหัวท้าย ช่องว่างที่หัวท้ายของสายอักขระสามารถทำให้หายไปได้โดยใช้เมธอด strip\nprint(len(\u0026#39; แม่นแล้ว \u0026#39;)) # ได้ 13  print(\u0026#39; แม่นแล้ว \u0026#39;.strip()) # ได้ แม่นแล้ว  print(len(\u0026#39; แม่นแล้ว \u0026#39;.strip())) # ได้ 8 หากต้องการตัดแค่หัวหรือท้ายอย่างเดียวก็ใช้ lstrip หรือ rstrip โดย lstrip จะตัดเฉพาะหัว ส่วน rstrip จะตัดเฉพาะท้าย\nprint(len(\u0026#39; แม่นแล้ว \u0026#39;.lstrip())) # ได้ 11  print(len(\u0026#39; แม่นแล้ว \u0026#39;.rstrip())) # ได้ 10 การแบ่งและเชื่อมรวมสายอักขระ สามารถแยกสายอักขระออกเป็นส่วนๆได้ด้วยเมธอด split โดยเมธอดนี้จะสร้างลิสต์ของสายอักขระแต่ละส่วนที่แยกได้ออกมา\nโดยในการแยกจำเป็นต้องระบุว่าจะใช้สัญลักษณ์อะไรเป็นตัวแยก โดยใส่เป็นอาร์กิวเมนต์ในเมธอด เช่นหากต้องการให้แยกตามจุลภาพ ,\nit = \u0026#39;pasta, spaghetti, macaroni, lasagna, pizza\u0026#39; ita = it.split(\u0026#39;, \u0026#39;) print(ita) # ได้ [\u0026#39;pasta\u0026#39;, \u0026#39;spaghetti\u0026#39;, \u0026#39;macaroni\u0026#39;, \u0026#39;lasagna\u0026#39;, \u0026#39;pizza\u0026#39;] หากไม่ใส่อาร์กิวเมนต์อะไรลงในเมธอดเลยจะแยกตามช่องว่าง\nfr = \u0026#39;croissant baguette éclair macaron madeleine\u0026#39; fra = fr.split() print(fra) # ได้ [\u0026#39;croissant\u0026#39;, \u0026#39;baguette\u0026#39;, \u0026#39;éclair\u0026#39;, \u0026#39;macaron\u0026#39;, \u0026#39;madeleine\u0026#39;] ในทางตรงข้ามมีเมธอดที่ชื่อ join เอาไว้ใช้รวมลิสต์ของสายอักขระเข้าเป็นสายอักขระอันเดียว\njoin นั้นถือเป็นเมธอดของสายอักขระโดยทำกับสายอักขระที่เป็นตัวคั่นแล้วมีอาร์กิวเมนต์เป็นลิสต์ของสายอักขระที่ต้องการรวม\nวิธีการใช้อาจดูแล้วเข้าใจยากกว่า split อยู่หน่อยและอาจสับสนกันได้ ให้ดูตัวอย่างประกอบ\nf = [\u0026#39;ยานี้ดี\u0026#39;, \u0026#39;กินแล้วแข็ง\u0026#39;, \u0026#39;แรงไม่มี\u0026#39;, \u0026#39;โรคภัยไข้เจ็บเบียดเบียน\u0026#39;] g = \u0026#39;\u0026#39;.join(f) print(g) # ได้ ยานี้ดีกินแล้วแข็งแรงไม่มีโรคภัยไข้เจ็บเบียดเบียน ลองเขียนโปรแกรมสำหรับเชื่อมโดยไม่ใช้ join ดูก็สามารถทำได้\nf = [\u0026#39;ยานี้ดี\u0026#39;, \u0026#39;กินแล้วแข็ง\u0026#39;, \u0026#39;แรงไม่มี\u0026#39;, \u0026#39;โรคภัยไข้เจ็บเบียดเบียน\u0026#39;] g = \u0026#39;\u0026#39; for s in f: g += s print(g) ตัวเชื่อมอาจใช้เป็นอะไรก็ได้ เช่นเว้นวรรคก็ใช้ \\n\nh = \u0026#39;\\n\u0026#39;.join([\u0026#39;ooo\u0026#39;,\u0026#39;o o\u0026#39;,\u0026#39;ooo\u0026#39;]) print(h) จะได้สายอักขระที่มี ๓ บรรทัด\nooo o o ooo สำหรับการแยกสายอักขระโดยใช้การขึ้นบรรทัดใหม่เป็นตัวแยกอาจใช้เมธอด splitlines เช่นลองใช้กับสายอักขระตัวเมื่อครู่\nprint(h.splitlines()) # ได้กลับมาเป็น [\u0026#39;ooo\u0026#39;, \u0026#39;o o\u0026#39;, \u0026#39;ooo\u0026#39;] หากต้องการแยกสายอักขระออกเป็นทีละตัวๆก็อาจทำได้ง่ายๆด้วยการใช้ list แปลงเป็นลิสต์ได้เลย\nprint(list(\u0026#39;กลุ่มก้อน\u0026#39;)) # ได้ [\u0026#39;ก\u0026#39;, \u0026#39;ล\u0026#39;, \u0026#39;ุ\u0026#39;, \u0026#39;่\u0026#39;, \u0026#39;ม\u0026#39;, \u0026#39;ก\u0026#39;, \u0026#39;้\u0026#39;, \u0026#39;อ\u0026#39;, \u0026#39;น\u0026#39;] การเปลี่ยนตัวพิมพ์ใหญ่พิมพ์เล็ก อักษรโรมันมักประกอบไปด้วยตัวพิมพ์เล็กและพิมพ์ใหญ่ ในภาษาไพธอนมีคำสั่งสำหรับเปลี่ยนข้อความในสายอักขระทั้งหมดเป็นพิมพ์เล็ก หรือพิมพ์ใหญ่ทั้งหมด นั่นคือใช้เมธอด upper และ lower\na = \u0026#39;Die Flügel der Freiheit\u0026#39; print(a.upper()) # ได้ DIE FLÜGEL DER FREIHEIT  print(a.lower()) # ได้ die flügel der freiheit อักษรกรีกเองก็มีตัวพิมพ์เล็กพิมพ์ใหญ่ สามารถใช้ได้ด้วย\na = \u0026#39;Αστρονομία\u0026#39; print(a.upper()) # ΑΣΤΡΟΝΟΜΊΑ  print(a.lower()) # αστρονομία ***แต่ถ้าใช้ในไพธอน 2 มีข้อต้องระวัง อ่านรายละเอียด\nสำหรับอักษรไทยไม่มีตัวพิมพ์เล็กพิมพ์ใหญ่จึงไม่มีผลอะไรกับเมธอดนี้\nลองเขียนโปรแกรมให้สร้างสายอักขระขึ้นใหม่โดยเปลี่ยนคำที่เป็นตัวพิมพ์เล็กทั้งหมดให้เป็นตัวพิมพ์ใหญ่สลับกับตัวพิมพ์เล็ก\na = \u0026#39;pneumoultramicroscopicossilicovulcanoconioticozinhos\u0026#39; b = \u0026#39;\u0026#39; for i in range(0,len(a),2): b += a[i].upper() if(i\u0026lt;len(a)-1): b += a[i+1] print(b) # ได้ PnEuMoUlTrAmIcRoScOpIcOsSiLiCoVuLcAnOcOnIoTiCoZiNhOs การค้นหาข้อความที่ต้องการภายในสายอักขระ การจะตรวจว่าข้อความสั้นๆที่เราต้องการค้นนั้นอยู่ภายในสายอักขระยาวๆหรือไม่สามารถใช้ in เช่น\n\u0026#39;Essen\u0026#39; in \u0026#39;Sie sind das Essen und wir sind die Jäger\u0026#39; # ได้ True หากต้องการหาว่าคำที่ต้องการนั้นอยู่ในตำแหน่งไหนก็อาจทำการวนซ้ำเพื่อค้น เช่น\ng = \u0026#39;Sie sind das Essen und wir sind die Jäger\u0026#39; s = \u0026#39;Essen\u0026#39; if(s in guren): for i in range(len(g)): if(s not in g[i:]): print(i-1) break else: print(\u0026#39;ไม่พบคำที่ต้องการหา\u0026#39;) ผลลัพธ์จะได้ 13\nอย่างไรก็ตามในภาษาไพธอนมีคำสั่งที่สามารถช่วยค้นหาได้โดยอัตโนมัติอยู่ นั่นคือ find\nโครงสร้าง\nสายอักขระ.find(คำที่ค้น, จุดเริ่มค้น, จุดสิ้นสุดการค้น)\nโดยที่จุดเริ่มต้นและสิ้นสุดอาจใส่หรือไม่ใส่ก็ได้ ถ้าไม่ใส่ก็จะค้นทั้งหมด\ng = \u0026#39;Sie sind das Essen und wir sind die Jäger\u0026#39; print(g.find(\u0026#39;Essen\u0026#39;)) # ได้ 13 หากค้นหาแล้วไม่พบ จะคืนค่า -1\nprint(g.find(\u0026#39;der\u0026#39;)) # ได้ -1 กรณีที่มีคำที่ค้นอยู่ ๒ ตัวขึ้นไป จะขึ้นตำแหน่งของตัวแรก\nprint(g.find(\u0026#39;sind\u0026#39;)) # ได้ 4 หากต้องการให้ค้นไล่มาจากด้านหลังให้ใช้เมธอด rfind\nprint(g.rfind(\u0026#39;sind\u0026#39;)) # ได้ 27 กรณีที่กำหนดจุดเริ่มต้นและจุดสิ้นสุด ถ้าตัวที่ต้องการหาไม่อยู่ในขอบเขตก็จะหาไม่พบ\nprint(g.find(\u0026#39;Sie\u0026#39;,3)) # ได้ -1 (คือหาไม่พบ)  print(g.find(\u0026#39;die\u0026#39;,2,35)) # ได้ 32  print(g.find(\u0026#39;die\u0026#39;,2,32)) # ได้ -1 (คือหาไม่พบ) นอกจากนี้ยังมีเมธอด index และ rindex ซึ่งก็ใช้ค้นหาเหมือนกัน แต่ความต่างคือหากค้นหาแล้วไม่เจอจะขึ้นขัดข้องแทนที่จะคืนค่า -1\nprint(g.index(\u0026#39;Eren\u0026#39;)) # ได้ ValueError: substring not found หากต้องการนับจำนวนคำที่ต้องการค้นว่ามีทั้งหมดกี่ตัวสามารถใช้เมธอด count\nprint(g.count(\u0026#39;sind\u0026#39;)) # ได้ 2 ตรวจจุดเริ่มและจุดสิ้นสุด ในการตรวจว่าข้อความขึ้นต้นและสิ้นสุดเป็นตัวที่ต้องการหรือไม่นั้น มีเมธอดเฉพาะที่สามารถใช้ได้ คือ startswith กับ endswith\nโครงสร้าง\nสายอักขระ.startswith(คำที่ค้น, จุดเริ่มค้น, จุดสิ้นสุดการค้น) สายอักขระ.endswith(คำที่ค้น, จุดเริ่มค้น, จุดสิ้นสุดการค้น) ตัวอย่าง\na = \u0026#39;verbrennungsanlage\u0026#39; print(a.startswith(\u0026#39;ver\u0026#39;)) # ได้ True  print(a.startswith(\u0026#39;ver\u0026#39;,3)) # ได้ False  print(a.startswith(\u0026#39;bren\u0026#39;,3)) # ได้ True  print(a.startswith(\u0026#39;erb\u0026#39;,1,7)) # ได้ True  print(a.endswith(\u0026#39;sanlage\u0026#39;)) # ได้ True  print(a.endswith(\u0026#39;nung\u0026#39;,7)) # ได้ False  print(a.endswith(\u0026#39;san\u0026#39;,3,14)) # ได้ True  print(a.endswith(\u0026#39;san\u0026#39;,12,14)) # ได้ False การแทนที่ สามารถค้นหาอักษรที่ต้องการแล้วเขียนทับได้โดยใช้เมธอด replace\nโครงสร้าง\nสายอักขระ.replace(ข้อความที่จะให้ถูกแทนที่,ข้อความที่จะนำไปแทน,จำนวนที่จะแทน) จำนวนที่แทนอาจไม่จำเป็นต้องใส่ก็ได้ หากไม่ใส่มีกี่ตัวก็จะถูกแทนหมด\nตัวอย่าง\nv = \u0026#39;ไก่จิกเด็กตายเด็กตายบนปากโอ่ง\u0026#39; print(v.replace(\u0026#39;เด็กตาย\u0026#39;,\u0026#39;เด็กเต้น\u0026#39;)) # ได้ ไก่จิกเด็กเต้นเด็กเต้นบนปากโอ่ง กรณีที่กำหนดจำนวนก็จะถูกแทนแค่จำนวนนั้น\nprint(v.replace(\u0026#39;เด็กตาย\u0026#39;,\u0026#39;โดนเตียง\u0026#39;,1)) # ได้ ไก่จิกโดนเตียงเด็กตายบนปากโอ่ง กรณีที่อยากลบข้อความก็ทำได้โดยปล่อยว่าง\nprint(v.replace(\u0026#39;จิกเด็กตายเด็ก\u0026#39;,\u0026#39;\u0026#39;)) # ได้ ไก่ตายบนปากโอ่ง อ้างอิง\nhttp://docs.python.jp/3/library/functions.html\nhttp://python.civic-apps.com/string-find\nhttp://python.civic-apps.com/string-split-join\nhttp://www.isl.ne.jp/pcsp/python/python19.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko11\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/beginer/list/",
	"title": "การจัดการกับลิสต์ (List)",
	"tags": [],
	"description": "",
	"content": "ในบทนี้จะมาขยายความถึงลิสต์ ซึ่งเป็นข้อมูลชนิดลำดับที่ใช้มากที่สุดเนื่องจากสามารถเพิ่มและแก้ไขข้อมูลได้ตลอด ต่างกับทูเพิลซึ่งแก้อะไรไม่ได้ สิ่งที่จะแนะนำในบทนี้เป็นคำสั่งที่ใช้กับลิสต์เป็นหลัก แต่บางอย่างก็สามารถนำมาใช้กับทูเพิลได้ด้วยเช่นกัน\nการกลับลำดับลิสต์ สามารถกลับลำดับของสมาชิกในลิสต์จากหัวมาท้ายได้โดยใช้ for สร้างลิสต์ใหม่ที่ดึงข้อมูลลิสต์เดิมที่ไล่ตำแหน่งจากท้ายมาหัว เช่น\na = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;] b = [a[4-i] for i in range(len(a))] print(b) # [\u0026#39;จ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ก\u0026#39;] อย่างไรก็ตาม มีวิธีที่สามารถสลับลำดับของสมาชิกได้ในทันที นั่นคือใช้เมธอด reverse\na = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;] a.reverse() print(a) # ได้[\u0026#39;จ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ก\u0026#39;] วิธีนี้ยังมีข้อดีตรงที่เป็นการเปลี่ยนสลับลำดับของสมาชิกในลิสต์เดิมไปเลยทันที ไม่ต้องสร้างลิสต์ขึ้นมาใหม่ ข้อเสียคือลิสต์แบบเดิมหายไป นอกจากนี้ยังอาจใช้ฟังก์ชัน reversed อย่างไรก็ตามฟังก์ชันนี้ไม่ได้ให้ผลเป็นลิสต์\na = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;] print(reversed(a)) # ได้ \u0026lt;list_reverseiterator object at 0x10de03198\u0026gt; จะเห็นว่าผลที่ได้ไม่ใช่ลิสต์ที่ถูกสลับตำแหน่งข้อมูล แต่เป็นออบเจ็กต์อีกชนิดหนึ่งชื่อชนิด list_reverseiterator ซึ่งเป็นอิเทอเรเตอร์ (iterator) ชนิดหนึ่ง เวลาสั่งให้แสดงผลจะไม่สามารถเห็นผลได้ทันที\nอย่างไรก็ตามสามารถนำมาใช้ใน for ได้เหมือนกับลิสต์ ละจะเห็นว่าตำแหน่งถูกสลับจากหลังมาหน้าจริงๆ\nfor i in reversed([\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;]): print(i,end=\u0026#39; \u0026#39;) # ได้ จ ง ค ข ก หรืออาจเปลี่ยนให้เป็นลิสต์ธรรมดาได้โดย\nlist(reversed((\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;))) #ได้ [\u0026#39;จ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ก\u0026#39;] วิธีนี้ใช้กับทูเพิลได้เช่นกัน\ntuple(reversed((\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;))) # ได้ (\u0026#39;จ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ก\u0026#39;) การหาค่าสูงสุดและต่ำสุดของลิสต์ หลักการหาค่าสูงสุดหรือต่ำสุดของสมาชิกที่อยู่ภายในลิสต์นั้น ให้นึกถึงนายพรานที่ไปล่าหมูป่าเพื่อทำเป็นอาหาร\nนายพรานสามารถขนหมูป่ากลับได้แค่ตัวเดียว สมมุติว่าเข้าไปถึงเขาเจอหมูป่าตัวหนึ่งก็ฆ่าแล้วขนมา แต่ต่อมาก็เจอตัวใหม่ซึ่งใหญ่กว่า จึงตัดสินใจทิ้งตัวเก่าไป พอเดินไปต่อก็ฆ่าหมูป่าได้อีกตัว แต่ตัวนี้ตัวเล็กกว่าเขาจึงเดินผ่านไปโดยเก็บตัวเดิมไว้ หลังจากนั้นก็เดินเจอหมูป่าอีกหลายตัวแล้วก็ทำเหมือนเดิมคือถ้าเจอตัวใหญ่ กว่าก็ฆ่าแล้วเปลี่ยนไปถือตัวนั้น จนสุดท้ายนายพรานก็จะได้หมูป่าตัวใหญ่ที่สุดกลับบ้าน การหาค่าสูงสุดของลิสต์ก็ใช้หลักการเดียวกันนี้ ลองสร้างลิสต์ของน้ำหนักหมูป่าทั้งหมดในป่าแล้วใช้ for เพื่อไล่หาค่าน้ำหนักของตัวที่มากที่สุดดู\nmupa = [50.9,89.3,62.7,101.2,70.4,129.3,94.9] #น้ำหนักหมูป่า 7 ตัว  mmax = mupa[0] # ตั้งค่าสูงสุดเริ่มต้น  i = 0 # ลำดับของค่าสูงสุดเริ่มต้น  for m in mupa: # ทำการวนซ้ำตามจำนวนในลิสต์  if(m\u0026gt;mmax): # ถ้ามากกว่าค่าสูงสุดเดิม  mmax = m # ให้เปลี่ยนเป็นค่านั้น  imax = i # และเปลี่ยนลำดับด้วย  i += 1 print(\u0026#39;ตัวที่ %dหนักสุด หนัก %.1fกก.\u0026#39;%(imax,mmax)) ผลลัพธ์\nตัวที่ 5 หนักสุด หนัก 129.3 กก. อย่างไรก็ตาม มีฟังก์ชันที่ใช้หาค่าสูงสุดได้ทันที นั่นคือ max\nprint(max(mupa)) # ได้ 129.3 และในทางกลับกันก็สามารถหาค่าต่ำสุดได้ด้วย โดยใช้ฟังก์ชัน min\nprint(min(mupa)) # ได้ 50.9 แต่ฟังก์ชันนี้ไม่สามารถบอกลำดับของข้อมูลที่ให้ค่าสูงสุดหรือต่ำสุดได้ ต้องใช้คู่กับฟังก์ชัน index เพื่อหาว่าตัวที่ตำแหน่งไหนมีค่าเป็นค่าสูงสุด\nprint(mupa.index(max(mupa))) # ได้ 5 หรือเขียนแบบนี้ก็ได้\nprint(max(mupa, key=mupa.index)) # ได้ 5 การใช้เมธอด index นี้เหมือนกับ index ที่ใช้กับสายอักขระซึ่งอธิบายไปในบทที่แล้ว แต่ลิสต์จะไม่มี rindex และไม่มี find กับ rfind ด้วย\nผลรวมและค่าเฉลี่ยของตัวเลขในลิสต์ หากมีลิสต์ที่ประกอบไปด้วยจำนวนตัวเลข สามารถหาค่ารวมของสมาชิกในลิสต์ทั้งหมดได้โดยใช้ for ไล่สมาชิกทีละตัวแล้วให้บวกไปเรื่อย ๆ\nx = [124.3,45.4,34.5,199.8,444.3,322.2,401.1] ruam = 0 for s in x: ruam +=s print(ruam) # ได้ 1571.6 ส่วนค่าเฉลี่ยก็แค่นำความยาวของลิสต์มาหารอีกที\nchalia = ruam/len(x) print(\u0026#39;ค่าเฉลี่ยเท่ากับ %.2f\u0026#39;%chalia) # ได้ ค่าเฉลี่ยเท่ากับ 224.51 ในภาษาไพธอนมีฟังก์ชันที่ใช้สำหรับหาค่าผลรวมของลิสต์โดยเฉพาะ คือ sum สามารถใช้เพื่อหาผลรวมและค่าเฉลี่ยได้ดังนี้\nprint(sum(x)) # ได้ 1571.6  print(sum(x)/len(x)) # ได้ 224.5142857142857 นับจำนวนสิ่งที่ต้องการในลิสต์ หากต้องการหาว่าในลิสต์นั้นมีสมาชิกที่เราต้องการค้นอยู่กี่ตัวอาจทำได้โดยลองกำหนดตัวแปรขึ้นมาตัวหนึ่งใช้เก็บค่าจำนวนที่นับโดยเริ่มจาก 0 จากนั้นใช้ for วนเพื่อตรวจว่าสมาชิกแต่ละตัวตรงกับค่าที่ต้องการหรือไม่ ถ้าตรงก็บวกเพิ่มไปเรื่อย ๆ\nตัวอย่าง หาว่ามี 2 กี่ตัวในลิสต์ w\nw = [1,2,1,2,2,2,1,2,2,1,1,1,1,2,1,1,2,2] nap = 0 for b in w: if(b==2): nap += 1 print(nap) # ได้ 9 นอกจากนี้ยังอาจทำได้ง่ายๆโดยใช้เมธอด count เช่นเดียวกับที่ใช้ในสายอักขระ\nprint(w.count(2)) # ได้ 9 การจัดเรียงลิสต์ วิธีการจัดเรียงสมาชิกในลิสต์ตามลำดับค่ามากน้อยนั้นมีอยู่หลายวิธี แต่วิธีที่เข้าใจง่ายที่สุดและนิยมสอนกันในเบื้องต้นก็คือการเรียงลำดับแบบฟอง (bubble sort) คือตรวจดูค่าแล้วสลับลำดับทีละคู่ไปเรื่อยๆ โดยไล่จากตัวแรกกับตัวที่สอง ไปตัวที่สองกับตัวที่สาม แล้วไล่ไปเรื่อยๆจนถึงตัวรองสุดท้ายกับตัวสุดท้าย จากนั้นก็วนสลับอย่างนี้ไปอีกเรื่อย ๆ จนเรียงกันหมด\nx = [35,24,30,17,15,6,8,2] for i in range(len(x)-1): # ทำซ้ำไป len(x)-1 ครั้ง  for j in range(len(x)-i-1): # ทำซ้ำโดยไล่ตั้งแต่ j เป็น 0 ไปจนถึง j เป็น len(x)-i-2  if(x[j]\u0026gt;x[j+1]): # ถ้าตัวซ้ายมากกว่าตัวขวาให้สลับ  x[j],x[j+1] = x[j+1],x[j] print(x) ผลลัพธ์\n[24, 30, 17, 15, 6, 8, 2, 35] [24, 17, 15, 6, 8, 2, 30, 35] [17, 15, 6, 8, 2, 24, 30, 35] [15, 6, 8, 2, 17, 24, 30, 35] [6, 8, 2, 15, 17, 24, 30, 35] [6, 2, 8, 15, 17, 24, 30, 35] [2, 6, 8, 15, 17, 24, 30, 35] อย่างไรก็ตามตามในทางปฏิบัติแล้วมีวิธีอื่นที่เร็วกว่า ตัวอย่างนี้แค่ยกมาเพื่อฝึกกระบวนการคิดเท่านั้น ที่จริงแล้วในไพธอนมีคำสั่งเฉพาะที่ใช้ในการทำให้สมาชิกของลิสต์เรียงกันทันทีโดยง่าย นั่นคือเมธอด sort\nx = [35,24,30,17,15,6,8,2] x.sort() print(x) # ได้ [2, 6, 8, 15, 17, 24, 30, 35] ซึ่งจะพบว่านอกจากจะเขียนง่ายกว่าแล้วยังทำงานเร็วกว่ามากอย่างเทียบไม่ติด ดังนั้นในทางปฏิบัติแล้วจึงควรใช้วิธีนี้มากกว่า หากต้องการเรียงกลับด้านก็เพิ่มคีย์เวิร์ด reverse เข้าไปเป็น reverse=True (หรือใช้ 1 แทน True ก็ได้)\nx = [35,24,30,17,15,6,8,2] x.sort(reverse=1) print(x) # ได้ [35, 30, 24, 17, 15, 8, 6, 2] นอกจากนี้ยังอาจใช้ฟังก์ชัน sorted ซึ่งจะคืนค่าลิสต์ที่เรียงแล้ว\nx = [35,24,30,17,15,6,8,2] print(sorted(x)) # ได้ [2, 6, 8, 15, 17, 24, 30, 35] อนึ่ง ฟังก์ชัน sorted ไม่ได้เป็นการแก้ไขตัวลิสต์แต่เป็นการสร้างลิสต์ใหม่โดยใช้สมาชิกของลิสต์เก่ามาจัดเรียง ดังนั้นทูเพิลก็สามารถใช้ฟังก์ชัน sorted ได้ แต่ผลที่ไดจะออกมาเป็นลิสต์ ต้องแปลงกลับเป็นทูเพิลอีกที\ny = (489,378,112,388,98,14,333) y = tuple(sorted(y)) print(y) # ได้ (14, 98, 112, 333, 378, 388, 489) การสร้างคีย์ในการเรียงขึ้นเอง ในการเรียงนั้นปกติหากเป็นตัวเลขก็จะเรียงตามค่าสูงต่ำ หากเป็นตัวอักษรก็จะเรียงตามลำดับในยูนิโค้ด แต่ก็สามารถตั้งคีย์ขึ้นมาเองเพื่อใช้เป็นดัชนี ในการค้นได้เช่นกัน โดยการเพิ่มคีย์เวิร์ด key ลงไปในฟังก์ชัน sorted ดัชนีที่ใช้อาจเป็นสายอักขระหรือลิสต์ก็ได้\nตัวอย่าง ลองทำให้อักษรเรียงตามลำดับในแป้นพิมพ์เกษมณีโดยไล่จากแถวบนไปแถวล่าง ซ้ายไปขวา\nkedma = \u0026#39;ภถคตจขชฎพฑธรณนยญบฐลฃฅฟหฆกฏดฌษสศวซงผปฉอฮทมฒฬฝ\u0026#39; a = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ฆ\u0026#39;,\u0026#39;ง\u0026#39;,\u0026#39;จ\u0026#39;,\u0026#39;ฉ\u0026#39;,\u0026#39;ช\u0026#39;,\u0026#39;ซ\u0026#39;] print(sorted(a,key=kedma.index)) ได้\n[\u0026#39;ค\u0026#39;, \u0026#39;จ\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ช\u0026#39;, \u0026#39;ก\u0026#39;, \u0026#39;ซ\u0026#39;, \u0026#39;ง\u0026#39;, \u0026#39;ฉ\u0026#39;] สรุปเนื้อหา ในบทนี้ได้พูดถึงกระบวนการจัดการกับสมาชิกภายในลิสต์แบบต่างๆทั้งแบบใช้ฟังก์ชันหรือเมธอดช่วยและแบบที่ไม่ใช้ การใช้ฟังก์ชันหรือเมธอดช่วยนั้นจะง่ายกว่า แต่เพื่อให้เข้าใจหลักการคิดและกระบวนการที่ซ่อนอยู่ภายในจึงอธิบายวิธีที่เห็นภาพชัดก่อน\nเรื่องของลิสต์นั้นยังมีรายละเอียดอีกมาก ที่แนะนำมาจนถึงตอนนี้เป็นแค่พื้นฐานส่วนหนึ่ง ที่เหลือต้องนำไปต่อยอดกันต่อไป\nอ้างอิง\nhttp://docs.python.jp/3/library/stdtypes.html\nhttp://www.tohoho-web.com/python/list.html\nhttp://minus9d.hatenablog.com/entry/2015/01/04/235442\nhttp://kaisk.hatenadiary.com/entry/2014/11/04/232558\nhttp://d.hatena.ne.jp/yumimue/20071218/1197985024\nhttps://ja.wikipedia.org/wiki/バブルソート\n Reference : https://phyblas.hinaboshi.com/tsuchinoko12\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/beginer/dictionary/",
	"title": "ดิกชันนารี (Dictionary)",
	"tags": [],
	"description": "",
	"content": "ดิกชันนารีเป็นวัตถุที่เก็บค่าข้อมูลหลายๆตัวเช่นเดียวกับลิสต์และทูเพิล แต่จะต่างกันตรงที่ต้องประกอบไปด้วย ๒ ส่วน คือ คีย์ (key) กับ ค่า (value) อยู่ด้วยกันเหมือนเป็นคู่อันดับ ลิสต์และทูเพิลจะใช้เลขดัชนีเป็นตัวชี้ถึงค่าภายในลำดับ แต่ว่าในดิกชันนารีจะใช้คีย์แทน คีย์นั้นเหมือนเป็นสิ่งที่มาใช้แทนเลขดัชนีในลิสต์หรือทูเพิล คือแทนที่จะใช้ตัวเลขเพื่อชี้สมาชิกก็เปลี่ยนมาใช้คีย์ซึ่งเป็นอะไรก็ได้ที่กำหนดขึ้นเอง\nการสร้างและเข้าถึงข้อมูลในดิกชันนารี ดิกชันนารีสามารถสร้างได้โดยใช้วงเล็บปีกกาเช่นเดียวกับเซ็ต แต่ภายในใส่สมาชิกเป็นคู่ๆโดยแต่ละคู่ใส่คีย์ทางซ้ายแล้วคั่นด้วยโคลอน : แล้วตามด้วยค่า จากนั้นก็คั่นด้วยจุลภาค , แล้วตามด้วยคู่ถัดไป\nตัวอย่าง ดิกชันนารีที่เก็บข้อมูลตึกสูงในไทย\ntueksung = {\u0026#39;มหานคร\u0026#39;: 313, \u0026#39;ใบหยก 2\u0026#39;: 304, \u0026#39;อมันตา ลุมพินี\u0026#39;: 212, \u0026#39;อื้อจือเหลียง\u0026#39;: 160, \u0026#39;จัตุรัสจามจุรี\u0026#39;: 157, \u0026#39;ใบหยก 1\u0026#39;: 151} เวลาต้องการเข้าถึงข้อมูลก็ใช้ชื่อดิกชันนารีตามด้วย [ ] ซึ่งใส่ชื่อคีย์\nprint(tueksung[\u0026#39;จัตุรัสจามจุรี\u0026#39;]) # ได้ 157  print(tueksung[\u0026#39;ใบหยก 2\u0026#39;]) # ได้ 304 ดิกชันนารีไม่สามารถใช้ตัวเลขเพื่อระบุสมาชิกโดยอาศัยลำดับได้อย่างในลิสต์ ต้องใช้คีย์ตามที่ใส่เข้าไปเท่านั้น\nprint(tueksung[1]) # ได้ KeyError: 1 ทั้งคีย์และค่าจะเป็นข้อมูลชนิดไหนก็ได้ อาจเป็นตัวเลขก็ได้ เช่น ดิกชันนารีที่เก็บชื่อของโปเกมอน\npokemon = {151: \u0026#39;mew\u0026#39;, 152: \u0026#39;chicorita\u0026#39;, 153: \u0026#39;bayleaf\u0026#39;,154: \u0026#39;meganium\u0026#39;, 155: \u0026#39;hinoarashi\u0026#39;, 156: \u0026#39;magmarashi\u0026#39;,157: \u0026#39;bakphoon\u0026#39;, 158: \u0026#39;waninoko\u0026#39;,159: \u0026#39;alligates\u0026#39;, 160: \u0026#39;ordile\u0026#39;} print(pokemon[151]) # ได้ mew กรณีที่ใช้คีย์เป็นตัวเลขจำนวนเต็มแบบนี้ดูเผินๆอาจดูคล้ายกับลิสต์หรือทูเพิล แต่ต่างกันตรงที่ตัวเลขที่ใส่ต้องเป็นเลขที่มีอยู่ในคีย์เท่านั้นและไม่จำเป็นต้องไล่จาก 0\nการซ้ำกันของคีย์และค่า ภายในดิกชันนารีหนึ่งๆ ค่าอาจจะซ้ำกันได้ แต่คีย์จะซ้ำกันไม่ได้\nkhanaen = {\u0026#39;ฟิสิกส์\u0026#39;:97,\u0026#39;ฟิสิกส์\u0026#39;:91,\u0026#39;เคมี\u0026#39;:96,\u0026#39;คณิตศาสตร์\u0026#39;:87} print(khanaen) # ได้ {\u0026#39;ฟิสิกส์\u0026#39;: 91, \u0026#39;เคมี\u0026#39;: 96, \u0026#39;คณิตศาสตร์\u0026#39;: 87} จะเห็นว่าใส่ค่าซ้ำลงไปแต่สุดท้ายก็เหลือแค่ตัวเดียว ทั้งนี้เพราะว่าคีย์เป็นสิ่งที่ต้องใช้อ้างอิงเพื่อชี้ถึงค่าในดิกชันนารี จึงไม่สามารถซ้ำกันได้ เช่นเดียวกับฟังก์ชันทางคณิตศาสตร์ที่โดเมนต้องไม่ซ้ำ ถ้าซ้ำกันละก็พอจะเรียกหาค่าก็จะเกิดความคลุมเครือไม่รู้จะเรียกตัวไหน ในขณะที่ค่านั้นต่อให้ใส่ซ้ำกันจะไม่มีปัญหาอะไร\nkhanaen = {\u0026#39;ฟิสิกส์ 1\u0026#39;:97,\u0026#39;ฟิสิกส์ 2\u0026#39;:91,\u0026#39;เคมี 1\u0026#39;:91,\u0026#39;เคมี 2\u0026#39;:97} print(khanaen) # ได้ {\u0026#39;ฟิสิกส์ 1\u0026#39;: 97, \u0026#39;ฟิสิกส์ 2\u0026#39;: 91, \u0026#39;เคมี 1\u0026#39;: 91, \u0026#39;เคมี 2\u0026#39;: 97} ในที่นี้ค่าของ \u0026ldquo;ฟิสิกส์ 1\u0026rdquo; ซ้ำกับ \u0026ldquo;เคมี 2\u0026rdquo; และ \u0026ldquo;เคมี 1\u0026rdquo; ซ้ำกับ \u0026ldquo;ฟิสิกส์ 2\u0026rdquo; จะเห็นว่าสามารถซ้ำกันได้\nkeys, values และ items รายการคีย์ทั้งหมดสามารถแสดงได้โดยเมธอด keys ตัวอย่าง ดิกชันนารีแสดงรายชื่อเมืองเอก (เรียกว่าเสิ่งฮุ่ย (shěnghuì, 省会) ในภาษาจีน) ของมณฑลในจีน\nshenghui = {\u0026#39;กวางตุ้ง\u0026#39;: \u0026#39;กว่างโจว\u0026#39;,\u0026#39;เจ้อเจียง\u0026#39;: \u0026#39;หางโจว\u0026#39;, \u0026#39;เหลียวหนิง\u0026#39;: \u0026#39;เสิ่นหยาง\u0026#39;,\u0026#39;เหอเป่ย์\u0026#39;: \u0026#39;สือเจียจวาง\u0026#39;, \u0026#39;เหอหนาน\u0026#39;: \u0026#39;เจิ้งโจว\u0026#39;,\u0026#39;ฝูเจี้ยน\u0026#39;: \u0026#39;ฝูโจว\u0026#39;, \u0026#39;ทิเบต\u0026#39;: \u0026#39;ลาซ่า\u0026#39;,\u0026#39;ซินเจียง\u0026#39;: \u0026#39;อูหลู่มู่ฉี\u0026#39;} print(shenghui.keys()) ผลที่ได้\ndict_keys([\u0026#39;กวางตุ้ง\u0026#39;, \u0026#39;เจ้อเจียง\u0026#39;, \u0026#39;เหลียวหนิง\u0026#39;, \u0026#39;เหอเป่ย์\u0026#39;, \u0026#39;เหอหนาน\u0026#39;, \u0026#39;ฝูเจี้ยน\u0026#39;, \u0026#39;ทิเบต\u0026#39;, \u0026#39;ซินเจียง\u0026#39;]) ข้อมูลที่ได้นี้เป็นชนิด dict_keys ซึ่งถือเป็นคลาสเฉพาะคลาสนึง ไม่สามารถเปลี่ยนแปลงแก้ไขค่าในนี้ได้เช่นเดียวกับทูเพิล ไม่สามารถใช้ตัวเลขชี้ถึงค่าข้างในได้ แต่สามารถใช้ in เพื่อตรวจดูสมาชิกข้างในได้ สามารถแปลงเป็นลิสต์หรือทูเพิล หรือใช้ join เพื่อเชื่อมกันได้\n\u0026#39;ไต้หวัน\u0026#39; in shenghui.keys() # ได้ False  \u0026#39;ทิเบต\u0026#39; in shenghui.keys() # ได้ True  {\u0026#39;เหอหนาน\u0026#39;,\u0026#39;เหอเป่ย์\u0026#39;}.issubset(shenghui.keys()) # ได้ True  {\u0026#39;เหอหนาน\u0026#39;,\u0026#39;เหอเป่ย์\u0026#39;,\u0026#39;หูหนาน\u0026#39;,\u0026#39;หูเป่ย์\u0026#39;}.intersection( shenghui.keys()) # ได้ {\u0026#39;เหอหนาน\u0026#39;, \u0026#39;เหอเป่ย์\u0026#39;}  print(tuple(shenghui.keys())) # ได้ (\u0026#39;กวางตุ้ง\u0026#39;, \u0026#39;เจ้อเจียง\u0026#39;, \u0026#39;เหลียวหนิง\u0026#39;, \u0026#39;เหอเป่ย์\u0026#39;, \u0026#39;เหอหนาน\u0026#39;, \u0026#39;ฝูเจี้ยน\u0026#39;, \u0026#39;ทิเบต\u0026#39;, \u0026#39;ซินเจียง\u0026#39;)  print(\u0026#39;|\u0026#39;.join(shenghui.keys())) # ได้ กวางตุ้ง|เจ้อเจียง|เหลียวหนิง|เหอเป่ย์|เหอหนาน|ฝูเจี้ยน|ทิเบต|ซินเจียง ส่วนค่าในดิกชันนารีสามารถแสดงทั้งหมดโดยเมธอด values\nprint(shenghui.values()) จะได้ออกมาเป็นข้อมูลชนิด dict_values ซึ่งก็มีคุณสมบัติเหมือนกับ dict_keys\ndict_values([\u0026#39;กว่างโจว\u0026#39;, \u0026#39;หางโจว\u0026#39;, \u0026#39;เสิ่นหยาง\u0026#39;, \u0026#39;สือเจียจวาง\u0026#39;, \u0026#39;เจิ้งโจว\u0026#39;, \u0026#39;ฝูโจว\u0026#39;, \u0026#39;ลาซ่า\u0026#39;, \u0026#39;อูหลู่มู่ฉี\u0026#39;]) และถ้าต้องการให้แสดงคีย์กับค่าคู่กันในรูปของทูเพิลให้ใช้เมธอด items\nprint(shenghui.items()) จะได้ข้อมูลชนิด dict_items\ndict_items([(\u0026#39;กวางตุ้ง\u0026#39;, \u0026#39;กว่างโจว\u0026#39;), (\u0026#39;เจ้อเจียง\u0026#39;, \u0026#39;หางโจว\u0026#39;), (\u0026#39;เหลียวหนิง\u0026#39;, \u0026#39;เสิ่นหยาง\u0026#39;), (\u0026#39;เหอเป่ย์\u0026#39;, \u0026#39;สือเจียจวาง\u0026#39;), (\u0026#39;เหอหนาน\u0026#39;, \u0026#39;เจิ้งโจว\u0026#39;), (\u0026#39;ฝูเจี้ยน\u0026#39;, \u0026#39;ฝูโจว\u0026#39;), (\u0026#39;ทิเบต\u0026#39;, \u0026#39;ลาซ่า\u0026#39;), (\u0026#39;ซินเจียง\u0026#39;, \u0026#39;อูหลู่มู่ฉี\u0026#39;)]) ***ในไพธอน 2 เมธอด keys, values และ items จะได้ผลเป็นลิสต์ แทนที่จะได้เป็นคลาสเฉพาะ รายละเอียด\nการใช้ for คู่กับดิกชันนารี เมื่อใช้ for กับดิกชันนารี ตัวแปรจะไล่ตามคีย์ ไม่ใช่ค่า\nfor s in shenghui: print(s,end=\u0026#39; \u0026#39;) # ได้ กวางตุ้ง เจ้อเจียง เหลียวหนิง เหอเป่ย์ เหอหนาน ฝูเจี้ยน ทิเบต ซินเจียง แต่ก็สามารถเข้าถึงค่าได้ทันทีโดยใส่คีย์ใน [ ]\nfor s in shenghui: print(shenghui[s],end=\u0026#39; \u0026#39;) # ได้ กว่างโจว หางโจว เสิ่นหยาง สือเจียจวาง เจิ้งโจว ฝูโจว ลาซ่า อูหลู่มู่ฉี หรือใช้เมธอด values ก็สามารถไล่ตามค่าได้\nfor v in shenghui.values(): print(v,end=\u0026#39; \u0026#39;) # ได้ กว่างโจว หางโจว เสิ่นหยาง สือเจียจวาง เจิ้งโจว ฝูโจว ลาซ่า อูหลู่มู่ฉี  หากจะใช้ทั้งคีย์และค่าก็อาจใช้เมธอด items\nfor v in shenghui.items(): print(v[0],v[1],sep=\u0026#39;\u0026gt;\u0026#39;,end=\u0026#39; \u0026#39;) # กวางตุ้ง\u0026gt;กว่างโจว เจ้อเจียง\u0026gt;หางโจว เหลียวหนิง\u0026gt;เสิ่นหยาง เหอเป่ย์\u0026gt;สือเจียจวาง เหอหนาน\u0026gt;เจิ้งโจว ฝูเจี้ยน\u0026gt;ฝูโจว ทิเบต\u0026gt;ลาซ่า ซินเจียง\u0026gt;อูหลู่มู่ฉี การเพิ่มข้อมูลและแก้ไขดิกชันนารี การเพิ่มเติมข้อมูลสามารถทำได้โดยใช้ = เพื่อป้อนค่าใหม่ลงไปได้เลย ตัวอย่าง พื้นที่ของจังหวัดในไทย\nphuenthi = {\u0026#39;นครราชสีมา\u0026#39;: 20494, \u0026#39;เชียงใหม่\u0026#39;: 20107, \u0026#39;กาญจนบุรี\u0026#39;: 19483, \u0026#39;ตาก\u0026#39;: 16407, \u0026#39;อุบลราชธานี\u0026#39;: 15774, \u0026#39;สุราษฎร์ธานี\u0026#39;: 12891} phuenthi[\u0026#39;ชัยภูมิ\u0026#39;] = 12778 phuenthi[\u0026#39;แม่ฮ่องสอน\u0026#39;] = 12681 print(phuenthi) # ได้ {\u0026#39;นครราชสีมา\u0026#39;: 20494, \u0026#39;เชียงใหม่\u0026#39;: 20107, \u0026#39;กาญจนบุรี\u0026#39;: 19483, \u0026#39;ตาก\u0026#39;: 16407, \u0026#39;อุบลราชธานี\u0026#39;: 15774, \u0026#39;สุราษฎร์ธานี\u0026#39;: 12891, \u0026#39;ชัยภูมิ\u0026#39;: 12778, \u0026#39;แม่ฮ่องสอน\u0026#39;: 12681} หรืออาจใช้เมธอด update เพื่อรับเอาข้อมูลจากดิกชันนารีอื่นมาก็ได้\nphuenthi.update({\u0026#39;เพชรบูรณ์\u0026#39;: 12668, \u0026#39;ลำปาง\u0026#39;: 12534}) print(phuenthi) # ได้ {\u0026#39;นครราชสีมา\u0026#39;: 20494, \u0026#39;เชียงใหม่\u0026#39;: 20107, \u0026#39;กาญจนบุรี\u0026#39;: 19483, \u0026#39;ตาก\u0026#39;: 16407, \u0026#39;อุบลราชธานี\u0026#39;: 15774, \u0026#39;สุราษฎร์ธานี\u0026#39;: 12891, \u0026#39;ชัยภูมิ\u0026#39;: 12778, \u0026#39;แม่ฮ่องสอน\u0026#39;: 12681, \u0026#39;เพชรบูรณ์\u0026#39;: 12668, \u0026#39;ลำปาง\u0026#39;: 12534} ในการใช้ = นั้นจะเป็นการเพิ่มข้อมูลก็ต่อเมื่อคีย์ที่ใส่ไปนั้นไม่มีอยู่เดิม แต่หากคีย์ที่ใส่ไปนั้นมีอยู่ก่อนแล้วจะเป็นการแก้ค่าเขียนทับลงไปใหม่แทน ตัวอย่างการประยุกต์ใช้ ลองเขียนโปรแกรมสำหรับนับจำนวนตัวอักษรแต่ละตัวที่มีอยู่ในสายอักขระ\nr = \u0026#34;Si schiudono i boccioli color di rosa. L\u0026#39;ostinato inverno ha annunciato la propria fine.\u0026#34; # สายอักขระที่ต้องการวิเคราะห์  nap = {} # สร้างดิกชันนารีสำหรับเก็บค่าจำนวนของแต่ละตัวอักษร  for s in r.lower(): #เปลี่ยนให้เป็นตัวพิมพ์เล็กเพื่อจะนับรวมพิมพ์ใหญ่พิมพ์เล็กด้วยกัน  if(s\u0026lt;\u0026#39;a\u0026#39; or s\u0026gt;\u0026#39;z\u0026#39;): continue # เอาเฉพาะที่เป็นอักษรโรมัน a ถึง z ถ้าเจอสัญลักษณ์หรือช่องว่างให้ข้าม  if(s not in nap): # ถ้ายังไม่มีอยู่ในดิกชันนารี ให้ป้อนค่าใหม่โดยเริ่มนับ 1  nap[s] = 1 else: # ถ้ามีอยู่ในดิกชันนารีแล้ว ให้แก้ค่าโดยบวกเพิ่มอีก 1  nap[s] += 1 print(nap) (ที่มามาจากเนื้อเพลง)\nผลที่ได้\n{\u0026#39;s\u0026#39;: 4, \u0026#39;i\u0026#39;: 11, \u0026#39;c\u0026#39;: 5, \u0026#39;h\u0026#39;: 2, \u0026#39;u\u0026#39;: 2, \u0026#39;d\u0026#39;: 2, \u0026#39;o\u0026#39;: 12, \u0026#39;n\u0026#39;: 8, \u0026#39;b\u0026#39;: 1, \u0026#39;l\u0026#39;: 4, \u0026#39;r\u0026#39;: 5, \u0026#39;a\u0026#39;: 7, \u0026#39;t\u0026#39;: 3, \u0026#39;v\u0026#39;: 1, \u0026#39;e\u0026#39;: 2, \u0026#39;p\u0026#39;: 2, \u0026#39;f\u0026#39;: 1} หากต้องการให้แสดงผลโดยเรียงตามลำดับอักษรก็ใช้ sorted\nfor q in sorted(nap): print(\u0026#39;%s: %d\u0026#39;%(q,nap[q])) หรือถ้าจะให้เรียงตามลำดับที่ปรากฏก็\nfor q in sorted(nap, key=r.lower().index): print(\u0026#39;%s: %d\u0026#39;%(q,nap[q])) การใช้ for สร้างดิกชันนารี เช่นเดียวกับลิสต์ ดิกชันนารีก็สามารถสร้างขึ้นจาก for ได้ ตัวอย่าง ลองใช้ดิกชันนารีเพื่อสร้างฟังก์ชันทางคณิตศาสตร์ขึ้นมา\nf = {x:3*x+2 for x in range(100)} # สร้างฟังก์ชัน 3x+2 ที่มีโดเมนเป็นจำนวนเต็ม 0 ถึง 99  print(\u0026#39;f(3)=%d\u0026#39;%f[3]) # ได้ f(3)=11  print(\u0026#39;f(23)=%d\u0026#39;%f[23]) # ได้ f(23)=71  print(\u0026#39;f(99)=%d\u0026#39;%f[99]) # ได้ f(99)=299 ซึ่งการเขียนแบบนี้จะมีค่าเท่ากับการใช้ for เพื่อวนเพิ่มค่าไปทีละค่า\nf = {} # สร้างดิกชันนารีเปล่าขึ้นมาก่อน  for x in range(100): f[x] = 3*x+2 # ใส่เพิ่มไปทีละค่า การลบข้อมูลในดิกชันนารี สามารถลบทีละตัวได้โดยใช้เมธอด pop แล้วระบุคีย์ที่ต้องการลบ ตัวอย่าง ดิกชันนารีที่เก็บรหัสนักศึกษาและคะแนนวิชาภาษาไพธอนเบื้องต้น 1\npython1 = {5966208114: 54, 5966100309: 59, 5966117558: 49, 5966209223: 62, 5966195674: 48, 5966119902: 43} สมมุติว่ามีนักศึกษาถอนวิชานี้ไปคนนึงเลยต้องลบข้อมูลออก\npython1.pop(5966119902) print(python1) # ได้ {5966208114: 54, 5966100309: 59, 5966117558: 49, 5966209223: 62, 5966195674: 48} หรืออาจลบโดยใช้คำสั่ง del ก็ได้\ndel ชื่อดิกชันนารี[คีย์ที่ต้องการลบ] เช่น สมมุติว่านักศึกษาอีกคนก็ถอนวิชานี้\ndel python1[5966195674] print(python1) # ได้ {5966208114: 54, 5966100309: 59, 5966117558: 49, 5966209223: 62} หากต้องการลบทั้งหมดให้ใช้เมธอด clear สมมุติว่านักศึกษาคนอื่นๆก็พากันถอนวิชานี้ออกหมด\npython1.clear() print(python1) # ได้ {} ถ้าจะลบทั้งดิกชันนารีออกก็ใช้คำสั่ง del ตามด้วยชื่อดิกชันนารีโดยไม่ต้องใส่คีย์ สมมุติว่าพอคนถอนไปหมด อาจารย์ก็ลบข้อมูลของวิชานี้ทิ้งเสียเลย\ndel python1 print(python1) # NameError: name \u0026#39;python1\u0026#39; is not defined คีย์หรือค่ามากกว่าหนึ่งตัว บางครั้งค่าที่ต้องการอาจไม่ได้มีแค่ค่าเดียวแต่ต้องการเก็บสองค่าขึ้นไป กรณีแบบนี้สามารถใช้ค่าเป็นลิสต์หรือทูเพิลได้ ตัวอย่างเช่น บันทึกการเดินหมากในเกมโกะซึ่งตารางมีขนาด 19×19 แต่ละช่องแทนด้วยพิกัดในแกน x และ y\ngoban = {} # สร้างดิกเปล่า แทนตารางโกะเปล่า  goban[\u0026#39;ดำ1\u0026#39;] = [16,4] # ฝ่ายดำลงหมากตาที่ 1  goban[\u0026#39;ขาว1\u0026#39;] = [4,4] goban[\u0026#39;ดำ2\u0026#39;] = [16,16] goban[\u0026#39;ขาว2\u0026#39;] = [4,17] goban[\u0026#39;ดำ3\u0026#39;] = [3,15] print(goban) ผลหลังเดินไป ๕ ตา\n{\u0026#39;ดำ1\u0026#39;: [16, 4], \u0026#39;ขาว1\u0026#39;: [4, 4], \u0026#39;ดำ2\u0026#39;: [16, 16], \u0026#39;ขาว2\u0026#39;: [4, 17], \u0026#39;ดำ3\u0026#39;: [3, 15]} ที่มาของหมากกระดานนี้ ศึก Google AlphaGo ปะทะ ฝานฮุย (樊麾)\nhttps://www.youtube.com/watch?v=d9bXaLUPe9I\nกรณีที่ต้องการคีย์สองตัวขึ้นไปก็สามารถทำได้เช่นกัน เพียงแต่คีย์ไม่สามารถใช้ลิสต์ได้ ต้องใช้ทูเพิลเท่านั้น เช่น ตัวอย่างที่แล้ว คราวนี้ใช้ตำแหน่งบนตารางเป็นคีย์\ngoban = {} # สร้างดิกเปล่า แทนตารางโกะเปล่า  goban[(16,4)] = \u0026#39;ดำ1\u0026#39; # ฝ่ายดำลงหมากตาที่ 1  goban[(4,4)] = \u0026#39;ขาว1\u0026#39; goban[(16,16)] = \u0026#39;ดำ2\u0026#39; goban[(4,17)] = \u0026#39;ขาว2\u0026#39; goban[(3,15)] = \u0026#39;ดำ3\u0026#39; print(goban) ผลหลังเดินไป ๕ ตา\n{(16, 4): \u0026#39;ดำ1\u0026#39;, (4, 4): \u0026#39;ขาว1\u0026#39;, (16, 16): \u0026#39;ดำ2\u0026#39;, (4, 17): \u0026#39;ขาว2\u0026#39;, (3, 15): \u0026#39;ดำ3\u0026#39;} กรณีนี้จะสะดวกเวลาที่จะค้นว่าตำแหน่งไหนมีการลงหมากไปหรือยังและเป็นหมากอะไรที่ลงไว้ เช่น\nx,y = int(input()),int(input()) # ป้อนค่าตำแหน่ง  if((x,y) in goban.keys()): print(goban[(x,y)]) # ถ้ามีหมากอยู่ก็จะบอกว่าเป็นหมากอะไร  else: print(\u0026#39;ว่างเปล่า\u0026#39;) # ถ้าไม่มีก็จะบอกว่าว่างเปล่า ดิกชันนารีซ้อนดิกชันนารี ค่าภายในดิกชันนารีนอกจากจะใช้ทูเพิลหรือลิสต์ได้แล้วก็ยังสามารถใช้เป็นดิกชัน นารีย่อยข้างในได้อีกด้วย พอซ้อนกันหลายชั้นพอเรียกใช้ก็ต้องใส่ [ ] ซึ่งมีคีย์ใส่อยู่ซ้อนกัน\nตัวอย่าง ลองสร้างดิกชันนารีเก็บข้อมูลของโปเกมอนจำนวน ๔ ตัว แต่ละตัวใช้ชื่อเป็นคีย์ พอค้นแล้วจะได้ค่าซึ่งเป็นดิกชันนารีที่ประกอบด้วย หมายเลข, ส่วนสูง, น้ำหนัก, และ ชนิด\nkhomun = {\u0026#39;ฟุชิงิดาเนะ\u0026#39;: {\u0026#39;หมายเลข\u0026#39;: \u0026#39;001\u0026#39;,\u0026#39;ส่วนสูง\u0026#39;: 0.7,\u0026#39;น้ำหนัก\u0026#39;: 6.9,\u0026#39;ชนิด\u0026#39;:[\u0026#39;พืช\u0026#39;,\u0026#39;พิษ\u0026#39;]}, \u0026#39;ฮิโตคาเงะ\u0026#39;: {\u0026#39;หมายเลข\u0026#39;: \u0026#39;004\u0026#39;,\u0026#39;ส่วนสูง\u0026#39;: 0.6,\u0026#39;น้ำหนัก\u0026#39;: 8.5,\u0026#39;ชนิด\u0026#39;:[\u0026#39;ไฟ\u0026#39;]}, \u0026#39;เซนิงาเมะ\u0026#39;: {\u0026#39;หมายเลข\u0026#39;: \u0026#39;007\u0026#39;,\u0026#39;ส่วนสูง\u0026#39;: 0.5,\u0026#39;น้ำหนัก\u0026#39;: 9.0,\u0026#39;ชนิด\u0026#39;:[\u0026#39;น้ำ\u0026#39;]}, \u0026#39;พีคาชู\u0026#39;: {\u0026#39;หมายเลข\u0026#39;: \u0026#39;025\u0026#39;,\u0026#39;ส่วนสูง\u0026#39;: 0.4,\u0026#39;น้ำหนัก\u0026#39;: 6.0,\u0026#39;ชนิด\u0026#39;:[\u0026#39;ไฟฟ้า\u0026#39;]}} เวลาเข้าถึงค่าภายในก็ เช่น\nprint(khomun[\u0026#39;พีคาชู\u0026#39;][\u0026#39;น้ำหนัก\u0026#39;]) # ได้ 6.0  print(khomun[\u0026#39;ฟุชิงิดาเนะ\u0026#39;][\u0026#39;ชนิด\u0026#39;]) # ได้ [\u0026#39;พืช\u0026#39;, \u0026#39;พิษ\u0026#39;]  print(khomun[\u0026#39;ฮิโตคาเงะ\u0026#39;][\u0026#39;หมายเลข\u0026#39;]) # ได้ 004 สามารถใช้ for เพื่อแสดงค่าทั้งหมด\nfor pk in sorted(khomun): print(\u0026#39;====\u0026#39;+pk+\u0026#39;====\u0026#39;) # แสดงชื่อ  for s in khomun[pk]: if(s!=\u0026#39;ชนิด\u0026#39;): print(s+\u0026#39;: %s\u0026#39;%khomun[pk][s]) # แสดงหมายเลข, น้ำหนัก, ส่วนสูง  else: print(s+\u0026#39;: \u0026#39;+\u0026#39; + \u0026#39;.join(khomun[pk][s])) # แสดงชนิด ผลลัพธ์\n====พีคาชู==== หมายเลข: 025 ส่วนสูง: 0.4 น้ำหนัก: 6.0 ชนิด: ไฟฟ้า ====ฟุชิงิดาเนะ==== หมายเลข: 001 ส่วนสูง: 0.7 น้ำหนัก: 6.9 ชนิด: พืช + พิษ ====ฮิโตคาเงะ==== หมายเลข: 004 ส่วนสูง: 0.6 น้ำหนัก: 8.5 ชนิด: ไฟ ====เซนิงาเมะ==== หมายเลข: 007 ส่วนสูง: 0.5 น้ำหนัก: 9.0 ชนิด: น้ำ สรุปเนื้อหา ดิกชันนารีเป็นข้อมูลอีกประเภทหนึ่งที่สามารถนำมาประยุกต์ใช้งานได้มากเช่น เดียวกับลิสต์, ทูเพิล และเซ็ต หากแยกใช้ข้อมูลแต่ละอย่างตามความเหมาะสมของงานแล้วก็จะสามารถทำงานอะไร ต่างๆได้อย่างมีประสิทธิภาพ\nอ้างอิง http://www.python-izm.com/contents/basis/dict.shtml\nhttp://www.pythonweb.jp/tutorial/dictionary\nhttp://www.tohoho-web.com/python/list.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko14\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/beginer/module/",
	"title": "การเรียกใช้มอดูล (Module)",
	"tags": [],
	"description": "",
	"content": "ในบทที่ผ่านๆมาได้เรียนรู้ทั้งคำสั่งและฟังก์ชันต่างๆไปหลายรูปแบบหลายชนิด ทั้งหมดนั้นเป็นฟังก์ชันที่ถูกเตรียมไว้สามารถใช้ได้ทันทีโดยไม่ต้องมีการเตรียมการอะไรก่อน แต่ก็ยังมีฟังก์ชันหรือคำสั่งบางส่วนที่ยังไม่สามารถใช้ได้ทันทีหากไม่มีการเรียกใช้ก่อน ซึ่งก็คือฟังก์ชันที่อยู่ภายในมอดูลต่างๆ\nมอดูลภายในตัวและมอดูลเสริมภายนอก ฟังก์ชันและคำสั่งต่างๆที่สามารถเรียกมาเพิ่มเติมได้นั้นจะถูกเก็บในรูปของชุดคำสั่ง ซึ่งเรียกว่ามอดูล (module) มีมอดูลมากมายที่ติดตัวมาตั้งแต่ติดตั้งภาษาไพธอน ซึ่งเรียกมอดูลเหล่านี้ว่ามอดูลภายในตัว (built-in module)\nแต่ก็ยังมีมอดูลอีกประเภทที่ไม่ได้ติดตัวมาแต่แรก อาจถูกสร้างโดยนักเขียนโปรแกรมที่ไม่ได้มีส่วนเกี่ยวข้องกับกลุ่มผู้พัฒนาภาษาไพธอนโดยตรง แล้วก็ถูกนำมาแจกตามเว็บให้คนทั่วไปโหลด หรือเราเองก็อาจสามารถเขียนมันขึ้นมาเพิ่มเติมเองไว้ใช้เองได้ (เรื่องการสร้างมอดูลอ่านได้ในบทที่ ๓๔)\nมอดูลเสริมเหล่านี้ต้องติดตั้งเพิ่มเติมเอาเองโดยโหลดตามเว็บ บางมอดูลแค่โหลดแล้วนำมาใส่ในโฟลเดอร์ก็สามารถใช้ได้ทันที แต่ก็มีอยู่หลายอันที่ต้องมีขั้นตอนในการติดตั้ง อย่างไรก็ตามสำหรับ ใครที่ใช้โปรแกรมแพ็กเกจอย่าง anaconda spyder จะมีมอดูลเสริมติดตัวอยู่แล้วเป็นจำนวนมาก สามารถเรียกใช้ได้ทันทีเช่นเดียวกับมอดูลภายในตัว มอดูลเสริมมักถูกเก็บรวมอยู่แยกจากมอดูลภายในตัว โดยจะรวมอยู่ในโฟลเดอร์เดียว เช่น สำหรับ anaconda python3.5 ใน mac แล้วมอดูลเสริมถูกเก็บอยู่ใน\nUsers/\u0026lt;ชื่อผู้ใช้\u0026gt;/anaconda/lib/python3.5/site-packages สำหรับใน windows จะเป็น\nC:\\Anaconda3\\Lib\\site-packages การเรียกใช้ คำสั่งที่ใช้ในการเรียกใช้มอดูลก็คือ import โดยพิมพ์ import แล้วตามด้วยชื่อมอดูลที่ต้องการเรียกใช้ เช่น เรียกใช้มอดูลที่ชื่อ math ซึ่งเป็นมอดูลที่เก็บฟังก์ชันที่เกี่ยวกับการคำนวณทางคณิตศาสตร์\nimport math เพียงเท่านี้ก็จะสามารถใช้ฟังก์ชันภายในมอดูล math ได้แล้ว ขอยกตัวอย่างมาใช้ดูสักอัน เช่นฟังก์ชันชื่อ sin ซึ่งใช้คำนวณค่าไซน์ เวลาที่ใช้ก็ให้พิมพ์ชื่อมอดูลแล้วจึงตามด้วยชื่อฟังก์ชันนั้นโดยมีจุดคั่น\nmath.sin(1.57) # ได้ 0.9999996829318346 จะเห็นว่าชื่อฟังก์ชันในที่นี้อยู่ต่อจากจุด ดูแล้วคล้ายกับเมธอด แต่ความจริงแล้วไม่ใช่ ปกติจุด . เป็นตัวบอกถึงความสัมพันธ์แบบไล่เรียงหน่วยใหญ่ไปหาหน่วยเล็ก จุดในที่นี้แค่บอกว่าฟังก์ชันนี้เป็นฟังก์ชันในสังกัดของมอดูลไหนเท่านั้น\nอย่างไรก็ตามจริงๆแล้วมอดูลก็ถือเป็นออบเจ็กต์ชนิดหนึ่ง ดังนั้นอาจมองว่าฟังก์ชันเป็นเมธอดของมอดูลก็ได้เช่นกัน เพราะเมธอดก็คือฟังก์ชันที่สังกัดอยู่กับออบเจ็กต์คลาสต่างๆนั่นเอง หากใครเคยใช้ภาษาซีมาก่อนอาจคุ้นเคยกับคำว่า include คำสั่ง import ในภาษาไพธอนนี้เทียบเท่าได้กับ include ในภาษาซี คือเป็นการเรียกใช้ชุดคำสั่งที่จะมาใช้งานในโปรแกรม เพียงแต่ในภาษา ไพธอนคำสั่งพื้นฐานต่างๆสามารถใช้ได้ทันทีโดยไม่ต้องเรียกใช้ก่อน ผิดกับภาษาซีซึ่งมักจะต้องเริ่มด้วยการเรียกใช้ stdio.h และ conio.h เป็นประจำ\nดังนั้นทำให้การใช้งานในระดับพื้นฐานอาจไม่จำเป็นต้อง import อะไรเลย แต่พอต้องการใช้งานในระดับเฉพาะทางขึ้นมาหน่อยจึงจะเรียกใช้ หากลองเปรียบเทียบกับภาษาอื่นๆก็จะเห็นทั้งที่ใช้ include และ import เช่นใน php ใช้ include ใน javascript ใช้ import ความหมายเหมือนกันเพียงแต่ในแต่ละภาษาใช้ต่างกันเท่านั้น\nในภาษาไพธอนมอดูลก็ถือว่าเป็นออบเจ็กต์ชนิดหนึ่ง คือออบเจ็กต์ชนิดมอดูล ลองใช้ฟังก์ชัน type เพื่อหาชนิดดูได้\nprint(type(math)) # ได้ \u0026lt;class \u0026#39;module\u0026#39;\u0026gt; ส่วนสิ่งที่มากับมอดูลนั้นอาจเป็นออบเจ็กต์ชนิดใดก็ได้มีได้หลายอย่าง ชนิดอาจแตกต่างกันออกไป โดยส่วนใหญ่แล้วจะเป็นฟังก์ชัน เช่น\nprint(type(math.sin)) # \u0026lt;class \u0026#39;builtin_function_or_method\u0026#39;\u0026gt; เนื่องจาก math เป็นมอดูลภายในตัว ดังนั้นฟังก์ชันที่อยู่ในนี้ก็เลยมีชนิดเป็นฟังก์ชันหรือเมธอดภายในตัว แต่หากเป็นฟังก์ชันในมอดูลชนิดอื่นก็อาจมีชนิดที่ต่างกันออกไป ซึ่งก็แล้วแต่ผู้สร้างมอดูลนั้นจะกำหนด นอกจากฟังก์ชันแล้วมอดูลก็อาจประกอบด้วยข้อมูลหรือออบเจ็กต์ที่เป็นค่าตัวเลขหรือสายอักขระก็ได้ เช่น\nprint(math.pi) # ได้ 3.141592653589793 pi นี้คือค่า π เป็นแค่ค่าคงที่ตัวหนึ่ง หากหาชนิดก็จะได้ว่าเป็น float\nการลบมอดูล หากไม่ต้องการใช้มอดูลไหนแล้วก็อาจลบทิ้งโดยใช้คำสั่ง del จากนั้นก็จะไม่สามารถใช้มอดูลนั้นได้อีกจนกว่าจำเรียกใช้ใหม่\ndel math math.sin(1.57) # ได้ NameError: name \u0026#39;math\u0026#39; is not defined หรืออาจลบแค่ฟังก์ชันในมอดูลนั้นตัวเดียว เช่น\ndel math.sin แบบนี้ก็จะใช้ไม่ได้แค่ math.sin ส่วนฟังก์ชันอื่นเช่น math.cos ก็ยังใช้ได้อยู่\nการละชื่อมอดูล โดยทั่วไปฟังก์ชันที่อยู่ภายในมอดูลที่เรียกเข้ามาด้วยคำสั่ง import ธรรมดานั้นเวลาจะใช้จะต้องมีชื่อมอดูลนำหน้าเสมอ แต่ก็มีวิธีที่จะทำให้ไม่ต้องใส่ชื่อมอดูลนำหน้าก็ได้ ซึ่งทำได้โดยใช้คำสั่ง from เช่น\nfrom math import * เท่านี้ก็สามารถใช้ฟังก์ชันทั้งหมดในมอดูล math ได้โดยไม่จำเป็นต้องมี math. นำหน้าแล้ว เช่นพิมพ์แค่ sin(1.57) ง่ายๆสั้นๆ ดอกจันทน์ * ในที่นี้มีความหมายว่าเรียกใช้ทุกสิ่งทุกอย่างที่อยู่ภายในมอดูลนั้นออกมา ให้หมด แต่ว่าถ้าหากอยากเรียกใช้แค่บางอันก็ทำได้โดยแค่เปลี่ยน * เป็นชื่อของสิ่งที่ต้องการใช้ เช่น\nform math import sin ถ้าทำแบบนี้ก็จะใช้ได้แค่ฟังก์ชัน sin ส่วนฟังก์ชันอื่นจะยังใช้ไม่ได้ อย่างไรก็ตามการใช้ from กับ * นี้โดยทั่วไปแล้วจะไม่ใช้ถ้าไม่แน่ใจว่าจะไม่มีผลกระทบอะไร เนื่องจากแต่ละมอดูลอาจมีฟังก์ชันที่ชื่อเหมือนกัน ซึ่งจะทำให้เกิดการซ้อนทับกันได้ โดยฟังก์ชันจากมอดูลที่เรียกใช้ทีหลังจะไปทับของมอดูลตัวที่เรียกก่อน สำหรับผู้เริ่มฝึกหัดแล้ว เพื่อความชัดเจนบางทีก็ควรจะเหลือชื่อมอดูลต้นทางเอาไว้น่าจะดีต่อการเรียน รู้มากกว่า ดังนั้นแนะนำว่าอย่าใช้ form แต่ให้ import โดยตรงดีกว่า\nการย่อชื่อมอดูลและฟังก์ชัน หากชื่อยาวๆก็สามารถย่อลงได้ บ่อยครั้งที่ชุดคำสั่งยาวๆมักถูกย่อชื่อลง การย่อชื่อสามารถทำได้โดยเขียน as ต่อท้ายตามด้วยชื่อที่ต้องการย่อ เช่น\nimport random as rd จากนั้นเวลาเรียกใช้มอดูลนี้ก็พิมพ์แค่ชื่อที่ถูกย่อแล้วตามด้วยชื่อฟังก์ชัน เช่น\nrd.uniform(0,100) # จะได้ค่าเลขสุ่มซึ่งอยู่ในช่วง 0 ถึง 100 มอดูล random นี้เป็นมอดูลที่ประกอบด้วยฟังก์ชันที่เกี่ยวข้องกับการสุ่ม (รายละเอียดเกี่ยวมอดูล random อ่านได้ใน https://phyblas.hinaboshi.com/20160508) ฟังก์ชัน uniform นั้นจะคืนค่าเป็นจำนวนจริงสุ่มภายในช่วงระหว่างอาร์กิวเมนต์ ๒ ตัวที่ใส่ลงไป สิ่งที่ย่อชื่อได้นั้นไม่เพียงแต่ชื่อมอดูลเท่านั้น แต่ชื่อฟังก์ชันภายในมอดูลก็สามารถย่อได้เช่นกัน เช่น\nfrom random import uniform as unif เพียงเท่านี้ก็สามารถใช้ random.uniform ได้โดยพิมพ์แค่ unif(0,100) ชื่อมอดูลที่ถูกเรียกขึ้นมานั้นมีสถานะเหมือนตัวแปรตัวหนึ่ง จะใช้ชื่อนี้เป็นตัวแปรทำอย่างอื่นอีกไม่ได้ ถ้าใช้จะถูกเขียนทับ เช่น\nimport math math = 100 math.sin(1.57) # ได้ AttributeError: \u0026#39;int\u0026#39; object has no attribute \u0026#39;sin\u0026#39; นั่นเพราะพอแทนค่าลงไปแบบนี้กลายเป็นว่าตัวแปรที่ชื่อ math ไปรับค่า 100 แล้วมันก็จะไม่ใช่เป็นมอดูลที่ชื่อ math อีกต่อไป กลายเป็นค่าจำนวนเต็มธรรมดา เราจะใช้มันไม่ได้อีกจนกว่าจะ import ใหม่ หรือแม้แต่เวลาที่ใช้ชื่อย่อก็เช่นกัน ต้องระวังไม่ให้ชื่อย่อนั้นไปซ้ำกับชื่อตัวแปรที่ต้องการจะใช้\nมอดูลย่อยภายในมอดูลหลัก ปกติแล้วภายในมอดูลหนึ่งจะประกอบไปด้วยฟังก์ชันมากมายอยู่ บางทีฟังก์ชันภายในมอดูลนั้นเองก็อาจจะแบ่งเป็นหมวดหมู่ต่างๆซึ่งมีลักษณะ เฉพาะต่างกันออกไป เมื่อเป็นแบบนี้บางมอดูลจึงได้มีการแบ่งมอดูลออก เป็นส่วนย่อยๆลงไปอีก เพื่อความเป็นระเบียบ มอดูลที่เป็นหน่วยย่อยลงไปอีกนั้นเรียกว่าซับมอดูล (submodule)\nยกตัวอย่างเช่นมอดูลชื่อ os มอดูลนี้มีไว้สำหรับจัดการกับสิ่งที่เกี่ยวข้องกับระบบปฏิบัติการ เช่นฟังก์ชัน os.uname นั้นจะคืนค่าข้อมูลที่ใช้จำแนกบ่งบอกถึงตัวเครื่องนี้ os.getcwd จะคืนค่าชื่อของโฟลเดอร์ที่ใช้ทำงานอยู่ (ที่อยู่ของไฟล์ที่รัน) แต่ว่าภายในมอดูล os นี้ก็ยังประกอบไปด้วยมอดูลย่อยที่ชื่อว่า path อยู่ ภายในนี้มีฟังก์ชันที่เกี่ยวข้องกับพาธ (เส้นทางที่บ่งชี้ตำแหน่งของไฟล์หรือส่วนประกอบต่างๆ) เช่น os.path.abspath เป็นฟังก์ชันที่จะคืนค่าพาธสัมบูรณ์ของไฟล์\nตัวอย่างการใช้มอดูล os\nimport os print(os.uname()) print(os.getcwd()) print(os.path.abspath(\u0026#39;untitled0.py\u0026#39;)) จะเห็นว่าเมื่อเรียกใช้มอดูล os โดย import เฉยๆเวลาที่ใช้ os.path.abspath จะต้องพิมพ์ยาวไล่ตั้งแต่ชื่อมอดูลหลัก ตามด้วยชื่อมอดูลย่อย แล้วจึงจะเป็นชื่อฟังก์ชัน อย่างไรก็ตามสามารถย่อได้โดยใช้ from\nfrom os import path แบบนี้ก็จะสามารถละ os. ด้านหน้าไปได้ path.abspath หรือย่อกว่านั้นคือละชื่อมอดูลย่อยไปด้วย\nfrom os.path import * หรือ\nfrom os.path import abspath แบบนี้ก็จะใช้ฟังก์ชัน abspath ได้โดยพิมพ์แค่ชื่อ abspath มอดูลย่อยก็สามารถทำการย่อชื่อได้ เช่น\nfrom os import path as op หรือ\nimport os.path as op สองแบบนี้มีค่าเท่ากัน คือเวลาเรียกใช้ abspath จะต้องพิมพ์เป็น op.abspath\nจะเห็นได้ว่าการเรียกใช้มอดูลมีทางเลือกอยู่หลากหลาย มีความยืดหยุ่น ถือเป็นความสะดวกอย่างหนึ่งของภาษาไพธอน เพียงแต่อาจจะต้องเสียเวลาทำความเข้าใจกันสักเล็กน้อย อนึ่ง มอดูลย่อยนั้นก็อาจจะมีมอดูลย่อยแยกเล็กลงไปอีก ซึ่งยิ่งย่อยก็จะยิ่งคั่นด้วยจุด . ไปเรื่อยๆ อาจมีย่อยลงไปอีกกี่ชั้นก็ได้ แล้วแต่คนออกแบบมอดูลจะออกแบบมา\nคลาสที่มากับมอดูล สิ่งที่ได้มาจากการเรียกใช้มอดูลนั้นไม่ได้มีเพียงฟังก์ชันใหม่หรือตัวแปรใหม่ เท่านั้น แต่ยังทำให้สามารถใช้ออบเจ็กต์ชนิดใหม่ได้ด้วยหากในมอดูลนั้นมีการจำกัดความ คลาสใหม่เฉพาะขึ้นมา เรื่องของการสร้างคลาสนั้นจะพูดถึงในบทหลังจาก นี้ไปอีกเพราะเป็นเรื่องที่ซับซ้อน แต่ในบทนี้จะพูดถึงคร่าวๆเกี่ยวกับการใช้ออบเจ็กต์จากคลาสที่ถูกสร้างภายใน มอดูลที่เรียกใช้ ในที่นี้ขอยกตัวอย่างมอดูล fractions ซึ่งเป็นมอดูลที่ใช้จัดการเลขเศษส่วน การทำงานของมอดูลนี้ก็คือนิยามออบเจ็กต์ (หรือก็คือข้อมูล) ชนิดใหม่ขึ้นมาชนิดหนึ่ง ซึ่งก็คือ \u0026ldquo;เลขเศษส่วน\u0026rdquo;\nแนวคิดของมอดูลนี้ก็คือ ปกติแล้วจะเห็นว่าตัวเลขจำนวนจริงต่างๆที่ถูกคำนวณภายในโปรแกรมนั้นจะอยู่ใน รูปของเลขทศนิยม แม้จะเป็นตัวเลขที่เขียนเศษส่วนแล้วดูเข้าใจง่ายกว่าก็ตาม เช่น 1/3 ก็จะกลายเป็น 0.3333333333333333 ซึ่งค่าที่ได้ก็จะเป็นเพียงค่าประมาณเท่านั้น หากนำมาคำนวณก็อาจเกิดความคลาดเคลื่อนทีละเล็กน้อย\nเพื่อรองรับความ จำเป็นในการใช้เลขในรูปของเศษส่วนซึ่งอาจเกิดขึ้นในบางสถานการณ์ มอดูล fractions จึงได้นิยามข้อมูลชนิดใหม่ ซึ่งสามารถเก็บตัวเลขให้อยู่ในรูปเศษส่วนได้\nตัวอย่างการใช้\nimport fractions a = fractions.Fraction(1,3) print(a) # ได้ 1/3  print(type(a)) # ได้ชนิดของข้อมูลเป็น \u0026lt;class \u0026#39;fractions.Fraction\u0026#39;\u0026gt; ในที่นี้จะเห็นว่าตัวแปร a กลายเป็นออบเจ็กต์ชนิดใหม่ ซึ่งก็คือชนิด fractions.Fraction ชื่ออาจจะดูยาวไปสักหน่อยเพราะต้องขึ้นต้นด้วยชื่อมอดูลก่อน รงส่วน a = fractions.Fraction(1,3) นั้นเป็นการประกาศตัวแปรและใส่ค่าให้ โดยเวลาสร้างข้อมูลชนิดนี้ทำได้หลายวิธี แต่ในที่นี้ใช้วิธีที่ง่ายที่สุดก็คือใส่อาร์กิวเมนต์เป็นเลขเศษตามด้วยเลขส่วน มองดูแล้วอาจรู้สึกว่ายุ่งยากต้องพิมพ์ตั้งยาวขนาดนี้เพื่อแค่ให้ได้จำนวนเศษส่วนมาตัวหนึ่ง อย่างไรก็ตามสามารถย่อได้ เช่น\nfrom fractions import Fraction as fr a = fr(1,3) แบบนี้จะดูง่ายขึ้นเยอะ เพียงแต่ว่าเวลาถามถึงชื่อชนิดข้อมูลโดย print(type(a)) ก็ยังจะได้ผลเป็น \u0026lt;class 'fractions.Fraction'\u0026gt; เหมือนเดิม เพราะในที่นีคำว่า fr แค่มาแทน fractions.Fraction เพื่อความสะดวกเท่านั้น ข้อมูลเลขเศษส่วนเวลาที่สั่ง print จะแสดงผลออกมาเป็นเลขเศษส่วน คือเป็นเลขเศษคั่นด้วย / แล้วตามด้วยเลขส่วน นี่เป็นตัวอย่างคร่าวๆของการสร้างและใช้ออบเจ็กต์ชนิดใหม่ ที่จริงแล้วยังมีออบเจ็กต์อีกจำนวนมากมายหลายชนิดซึ่งจะต้องได้เจอต่อไปอีก เยอะ\nตัวอย่างมอดูลอื่นๆ หลังจากที่ได้ลองยกตัวอย่างมอดูลบางส่วนไปแล้ว คราวนี้จะลองยกตัวอย่างแนะนำมอดูลอื่นๆซึ่งเป็นมอดูลภายในตัว ที่จริงมีอยู่มากมายคงยกมาได้ไม่หมด เอาแค่ให้พอเห็นภาพโดยรวม\n time ทำหน้าที่จัดการเกี่ยวกับเวลา datetime ยามออบเจ็กต์ชนิดวันเวลาขึ้นมา ช่วยให้การคำนวณอะไรที่เกี่ยวกับวันเวลาเป็นไปได้อย่างสะดวก decimal นิยามเลขทศนิยมฐานสิบซึ่งมีความแม่นยำสูงกว่าเลขทศนิยมตามที่ต้องการ sys เก็บตัวแปรต่างๆที่ควบคุมจัดการระบบ io จัดการกับการรับเข้าและนำออกข้อมูล re สำหรับใช้เอ็กซ์เพรชชันแบบปกติ platform ให้ข้อมูลเกี่ยวกับแพล็ตฟอร์มที่ใช้อยู่ zipfile สำหรับจัดการไฟล์ zip เช่นอัดรวมไฟล์และแตกไฟล์  นอกจากนี้ขอยกตัวอย่างมอดูลเสริมภายนอกที่เป็นที่นิยมจำนวนหนึ่งด้วย\n numpy นิยามออบเจ็กต์ชนิดแถวอาเรย์ที่สามารถคำนวณเมทริกซ์ ใช้ในการคำนวณได้อย่างมีประสิทธิภาพ scipy เครื่องมือสำคัญที่ใช้ในการคำนวณทางวิทยาศาสตร์ matplotlib สำหรับวาดกราฟ pandas สำหรับจัดการกับข้อมูลอย่างเป็นระบบในรูปแบบตาราง mayavi สำหรับวาดกราฟสามมิติ py2exe สำหรับเปลี่ยนโปรแกรมภาษาไพธอนให้เป็น .exe xlrd สำหรับจัดการไฟล์ excel PyQt / PySide สำหรับสร้างกราฟิกยูเซอร์อินเทอร์เฟซ (GUI) OpenGL สำหรับแสดงผลภาพกราฟิก  ใน IDE ที่เป็นแพ็กเกจเช่น anaconda spyder นั้นจะมีมอดูลเสริมอยู่หลายตัวติดมาตอนลงอยู่แล้ว แต่มอดูลไหนที่ไม่มีก็สามารถติดตั้งเพิ่มได้อย่างไม่ยาก\nมอดูลเสริมมีอยู่มากมาย หากรู้ว่าตัวเองต้องการเขียนโปรแกรมสำหรับใช้งานด้านไหนก็ลองหามอดูลที่ เกี่ยวข้อง จะมีประโยชน์สามารถใช้งานอะไรได้อย่างกว้างขวาง\nสรุปเนื้อหา ในบทนี้ได้แนะนำให้รู้จักกับวิธีการเรียกใช้มอดูลและได้แนะนำมอดูลที่สำคัญไปส่วนหนึ่งแล้ว การเรียกใช้มอดูลทำให้เราสามารถใช้ฟังก์ชันได้มากขึ้น หรือใช้คลาสใหม่ที่นิยามภายในมอดูลนั้นได้ มอดูลอาจประกอบไปด้วยมอดูลย่อย การเรียกใช้มอดูลมีอยู่หลายวิธี สามารถเลือกใช้ตามความเหมาะสม\nอ้างอิง\nhttp://www.tohoho-web.com/python/module.html\nhttp://docs.python.jp/3/tutorial/modules.html\nhttp://docs.python.jp/3/library/index.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko15\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/intermediate/read_files/",
	"title": "การอ่านข้อมูลจากไฟล์",
	"tags": [],
	"description": "",
	"content": "การอ่านและเขียนไฟล์เป็นเรื่องสำคัญมากอย่างหนึ่งในการเขียนโปรแกรม เพราะบางทีเราอาจต้องการบันทึกข้อมูลเก็บเอาไว้หรือนำข้อมูลจากที่ไหนมาใช้ ไฟล์มีหลากหลายชนิดต่างกันไปตามแต่ว่าใช้ทำอะไร แต่โดยหลักๆแล้วก็จะประกอบไปด้วยตัวหนังสือ หากเปิดด้วยโปรแกรมสำหรับอ่านเขียนข้อความเช่น notepad ก็จะเห็นเป็นโค้ดตัวหนังสือเรียงต่อๆกัน\nไฟล์ยังแบ่งเป็นไฟล์ข้อความ ที่มนุษย์อ่านรู้เรื่องได้ กับไฟล์ที่มีแต่โค้ดเลขฐานสองที่คอมเท่านั้นที่อ่านได้ ซึ่งเรียกว่าไฟล์ชนิดไบนารี (binary) อย่างไรก็ตามในบทนี้จะพูดถึงการจัดการกับไฟล์ที่เป็นตัวหนังสือที่สามารถ อ่านได้ จะไม่พูดถึงไฟล์แบบไบนารี\nการจัดการไฟล์นั้นโดยรวมๆแล้วประกอบไปด้วย\n นำข้อมูลจากไฟล์มาอ่าน เขียนไฟล์ขึ้นมาใหม่ แก้ไขไฟล์ที่มีอยู่เดิม  ขั้นตอนการจัดการไฟล์นั้นมีหลักๆ ๓ ขั้น คือ\n เปิดไฟล์ ใช้ไฟล์ (เพื่ออ่านหรือเขียน) ปิดไฟล์  ในที่นี้ขอยกข้อความสำหรับเป็นไฟล์ตัวอย่าง เป็นเนื้อเพลงของเพลง nishikaze no okurimono\n(ที่มา)\nไฟล์ตัวอย่าง nishikaze.txt\nQuando Zefiro danza prendendo Flora per mano, il mar Tirreno si muta in azzurro e giunge la primavera. Finisce il cupo inverno il porto è pieno di barche tornate a casa. Quel ragazzo che cammina lungo il molo con le guance tinte tornerà dal suo amor. Per il gentile vento che soffia da est il ciel si fa via via sereno, i pesci risvegliatisi dal lungo sonno sporgon furtivamente la testa tra le onde. Quando Zefiro sussurra a Flora parole d\u0026#39;amore, i boccioli dei fiori si gonfian di rosa e giunge la primavera. I fischi a vapore giungono alla banchina il porto è pieno di gente che va in paesi lontani. Con la speranza e l\u0026#39;inquietudine nel cuore, i pionieri raggiungeranno terre mai viste. Il vento dell\u0026#39;est insieme ai fiori si dirige verso nuove città, le rondini, cantando la canzone appena imparata, gioiscono della nuova stagion. คัดลอกข้อความลงไปเซฟ ให้เซฟลงไว้ที่โฟลเดอร์เดียวกับไฟล์โปรแกรม เวลาเซฟนั้นให้ดูด้วยว่าเอนโค้ดเป็นอะไร ในที่นี้ขอให้เลือกเป็น utf-8 (ใน notepad หากเลือกเป็น unicode จะหมายถึง utf-16)\nเพื่อให้เห็นภาพรวมก่อนขอเริ่มด้วยโค้ดตั้งแต่เปิดไฟล์ ใช้ไฟล์ แล้วก็ปิดไฟล์\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # เปิดไฟล์  print(f.read()) # อ่านไฟล์  f.close() # ปิดไฟล์ จบ ๓ ขั้นตอนสั้นๆ ผลที่ได้ก็คือข้อความจากภายในไฟล์นั้นทั้งหมดถูกแสดงผลออกมา\nต่อไปจะเริ่มอธิบายทีละส่วนอย่างละเอียด\nการเปิดไฟล์ ขั้นตอนแรกในการจัดการไฟล์ก็คือเปิดไฟล์ โดยใช้ฟังก์ชัน open\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) อาร์กิวเมนต์ ตัวแรกคือชื่อไฟล์ สามารถใส่แค่ชื่อไฟล์ถ้าหากอยู่ในโฟลเดอร์เดียวกับไฟล์โปรแกรมที่รัน แต่ถ้าไม่ใช่ก็ต้องใส่พาธไล่ตำแหน่งให้ถูก เช่นถ้าเก็บไว้ในโฟล์เดอร์ชื่อ xxx ซึ่งอยู่ที่เดียวกับไฟล์โปรแกรมก็ต้องใส่เป็น xxx/nishikaze.txt เป็นต้น สามารถใช้ได้ทั้งพาธสัมบูรณ์และพาธสัมพัทธ์\nส่วนอาร์กิวเมนต์ตัวที่สองซึ่งในที่นี้ใส่เป็น \u0026lsquo;r\u0026rsquo; นี้คือโหมดของการเปิดไฟล์ ซึ่ง r หมายถึงว่าเราจะเปิดไฟล์นี้ขึ้นมาเพื่ออ่าน\nโหมดในการเปิดไฟล์ซึ่งต้องระบุเป็นอาร์กิวเมนต์ตัวที่ ๒ ของฟังก์ชัน open นั้นมีอยู่หลากหลาย สามารถเลือกได้ดังนี้\n r เปิดเพื่ออ่านอย่างเดียว หากไม่มีไฟล์ชื่อนี้อยู่จะเกิดขัดข้องขึ้น r+ เปิดเพื่ออ่านและสามารถเขียนทับได้ หากไม่มีไฟล์ชื่อนี้อยู่จะเกิดขัดข้องขึ้น w เปิดเพื่อเขียนไฟล์ทับ หากไม่มีไฟล์ชื่อนี้อยู่จะเป็นการสร้างไฟล์ใหม่หากมีไฟล์อยู่แล้วก็จะเขียนทับ x เตรียมพื้นที่ว่างเพื่อจะเขียนไฟล์ เมื่อใช้โหมดนี้จะต้องไม่มีไฟล์ชื่อนี้อยู่ หากมีไฟล์ชื่อนี้อยู่แล้วจะเกิดขัดข้องขึ้น a เปิดเพื่อเขียนไฟล์ต่อ หากไม่มีไฟล์ชื่อนี้อยู่จะเป็นการสร้างไฟล์ใหม่ หากมีอยู่แล้วจะเป็นการเขียนต่อ  สรุปเป็นตารางเพื่อให้เข้าใจง่ายขึ้น\n   โหมด อ่าน เขียน หากไม่มีไฟล์อยู่เดิม หากมีไฟล์อยู่เดิม     r ได้ ไม่ได้ เกิดขัดข้อง เปิดอ่านได้   w ไม่ได้ ได้ สร้างไฟล์ใหม่ขึ้น ลบข้อมูลเก่าแล้วเขียนใหม่   a ไม่ได้ ได้ สร้างไฟล์ใหม่ขึ้น เขียนต่อจากที่มีอยู่เดิม   x ไม่ได้ ได้ สร้างไฟล์ใหม่ขึ้น เกิดขัดข้อง   r+ ได้ ได้ เกิดขัดข้อง เปิดอ่านได้ เมื่อเขียนจะเขียนต่อจากที่มีอยู่เดิม   w+ ได้ ได้ สร้างไฟล์ใหม่ขึ้น ลบข้อมูลเก่าแล้วเขียนใหม่   a+ ได้ ได้ สร้างไฟล์ใหม่ขึ้น เขียนต่อจากที่มีอยู่เดิม    นอกจากนี้ยังมีโหมดอื่นๆอีก เช่น b ซึ่งเป็นโหมดสำหรับเปิดไฟล์ชนิดไบนารี ซึ่งในที่นี้จะไม่พูดถึง หากไม่ได้ระบุโหมดจะถูกกำหนดเป็นโหมด r โดยอัตโนมัติ ดังนั้นหากจะเลือกโหมดอ่านไม่จำเป็นต้องใส่ ,r ก็ได้ ปล่อยว่างไว้เลย ดังนั้นจะเขียนแบบนี้ก็ได้\nf = open(\u0026#39;/Users/patn/Desktop/nishikaze.txt\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) ส่วนคีย์ encoding ที่ใส่ลงไปท้ายสุดนั้นเป็นการระบุว่าจะถอดรหัสแบบไหน ในที่นี้เลือก utf-8 ที่จริงแล้วคีย์ encoding อาจไม่จำเป็นต้องใส่หากว่าเครื่องเรากำหนดรูปแบบการถอดรหัสมาตรฐานเป็น utf-8 อยู่แล้ว ก็จะใส่แค่\nf = open(\u0026#39;/Users/patn/Desktop/nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;) อย่างไรก็ตามโดยทั่วไปอาจไม่เป็นแบบนั้น หากใส่ไปทั้ง ๆ แบบนี้ไฟล์จะถูกอ่านโดย ถอดรหัสเป็นแบบไหนก็ไม่รู้ ซึ่งก็ขึ้นอยู่กับเครื่องและระบบปฏิบัติการ มีปัจจัยมาเกี่ยวข้องด้วยมากมาย โดยปกติระบบจะกำหนดรูปแบบ การถอดรหัสมาตรฐานไว้ให้อยู่แล้ว หากไม่ได้แก้ไขเปลี่ยนแปลงอะไรไฟล์ก็จะถูกอ่านแบบนั้น เช่นบางเครื่องอาจเป็น cp874, cp932, cp1252 หรือ US-ASCII หรือบางเครื่องอาจเป็น utf-8 ก็เป็นได้\nหากบังเอิญรูปแบบการถอดรหัสมาตรฐานนี้ ไปตรงกับไฟล์ที่จะเซฟก็จะสามารถอ่านไฟล์ ได้โดยไม่มีปัญหาอะไร แต่เพื่อความปลอดภัยเพื่อให้สามารถรันได้กับทุกเครื่องแล้วระบุ encoding ไว้ตลอดดีที่สุด หากต้องการรู้ว่าเครื่องตัวเองรูปแบบการถอดรหัส มาตรฐานเป็นแบบไหนก็ทำได้โดยเรียกใช้ฟังก์ชัน getpreferredencoding ซึ่งอยู่ในมอดูล locale\nimport locale print(locale.getpreferredencoding()) ไฟล์ที่เปิดขึ้นมานั้นจะอยู่ในรูปของออบเจ็กต์ชนิดหนึ่งซึ่งออบเจ็กต์นี้จะต้องเอาตัวแปรมารับเพื่อที่จะนำไปใช้งานต่อไป ในที่นี้ใ้ชตัวแปร f มารับไฟล์ ต่อจากนี้ไปตัวแปร f ก็จะเป็นตัวแทนของไฟล์ที่เปิดขึ้นมา ซึ่งเราจะใช้เมธอดต่างๆเพื่อจัดการกับไฟล์ต่อไป\nการอ่านไฟล์ เมื่อเปิดมาแล้วขั้นตอนต่อไปก็คือการนำไฟล์มาอ่าน หรือก็คือการเอาข้อมูลภายในไฟล์มาใช้ คำสั่งที่ใช้ในการอ่านไฟล์มีอยู่หลายตัว ขอเริ่มจากวิธีที่ง่ายที่สุดก็คือใช้เมธอดที่ชื่อ read\nไฟล์ที่อ่านมานั้นโดยปกติจะเริ่มถูกอ่านจากข้อความแรกสุดไล่ไปเรื่อยๆจนจบ โดยระหว่างที่อ่านไป โปรแกรมจะมีการจำไว้ว่าอ่านถึงไหนแล้ว read เป็นเมธอดของออบเจ็กต์ของไฟล์ มีไว้สำหรับอ่านเอาข้อมูลที่มีอยู่ในไฟล์ตั้งแต่จุดที่อ่านไปถึงปัจจุบัน จนถึงสิ้นสุดไฟล์ โดยจะคืนค่าที่อ่านได้ออกมา ในที่นี้เราใช้ read ตั้งแต่เริ่ม จึงเป็นการอ่านไฟล์ ตั้งแต่ต้นรวดเดียวไปจนจบทั้งหมด\nและในที่นี้เราใช้คำสั่ง print เพื่อให้แสดงผลค่าที่อ่านได้ออกมาทันที ดังนั้นข้อความในไฟล์ทังหมดจึงถูกแสดงผลออกมาทันที และหลังจากเปิดไฟล์ขึ้นมา แล้วจัดการทำอะไรเสร็จเรียบร้อยแล้ว ขั้นตอนสุดท้ายก็คือปิดไฟล์ ซึ่งทำได้โดยเมธอด close\nการอ่านไฟล์ในตำแหน่งที่ต้องการ read นั้นถ้าไม่ได้ใส่อาร์กิวเมนต์อะไรลงไปจะเป็นการอ่านจนจบไฟล์ แต่ถ้าใส่ก็จะเป็นการอ่านจำนวนตัวอักษรเท่ากับจำนวนที่ระบุ\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) print(f.read(44)) f.close() แบบนี้จะได้ข้อความเฉพาะในบรรทัดแรกออกมา\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) while(1): s = f.read(50) if(s==\u0026#39;\u0026#39;): break #ถ้า s ว่างเปล่าแสดงว่าสิ้นสุดไฟล์อ่านไม่ได้แล้ว ให้หยุดวนซ้ำ  print(s) f.close() แบบนี้จะเป็นการอ่านไปทีละ ๕๐ ตัวจนกว่าจะจบ และจะเห็นได้ว่าเมื่อไฟล์ถูกเมธอด read อ่านไปจนจบแล้ว หากลองใช้คำสั่ง read อีกรอบผลที่ได้ก็คือจะได้สายอักขระเปล่า จะอ่านซ้ำอีกกี่รอบก็ยังคงว่างเปล่า แต่ก็ไม่ได้หมายความว่าไฟล์นี้จะไม่สามารถใช้อะไรได้แล้ว เราสามารถย้ายตำแหน่งที่อ่านได้อย่างอิสระด้วยเมธอด seek\nf.seek(0) แบบนี้จะเป็นการย้ายตำแหน่งที่อ่านไปยังจุดเริ่มต้นของไฟล์ พอทำแบบนี้แล้วก็สามารถใช้คำสั่ง read อ่านข้อความทั้งหมดได้อีกครั้ง เลข 0 ที่อยู่ในวงเล็บคือตำแหน่งของไฟล์ที่ต้องการอ่าน จะย้ายไปยังส่วนไหนของไฟล์ก็ได้ แต่ที่ต้องระวังก็คือหน่วยในการนับตำแหน่งภายในไฟล์ด้วย seek นั้นใช้เป็นหน่วยไบต์ไม่ใช่หน่วยตัวอักษรเหมือนอย่าง read และโดยทั่วไปแล้วตัวอักษรที่เป็น utf-8 นั้นจะมีจำนวนบิตในแต่ละอักษรไม่เท่ากัน อักษรที่ตรงกับ ASCII จะเป็น 1 ไบต์ แต่อักษรอื่นอาจเป็น 2 หรือ 3 ไบต์ ดังนั้นจึงนับจำนวนอักษรไปโดยตรงไม่ได้ สำหรับอักษรไทยนั้นเป็นอักษรที่ใช้ 3 ไบต์ ดังนั้นตัวหนึ่งจะคิดเป็น 3 หน่วย\nลองดูตัวอย่างอีกไฟล์ (ที่มา) ไฟล์ตัวอย่าง riki.txt บันทึกเป็น utf-8 เหมือนเดิม\nหากเปรียบโลกนี้เป็นนาฬิกาเรือนใหญ่ยักษ์ จะประกอบขึ้นจากฟันเฟืองไร้ชื่อจำนวนมหาศาลเพียงใดกัน ถึงกระนั้น แม้เพียงฟันเฟืองอันเล็กๆก็ตาม หากสั่งสมไปเรื่อยๆ ก็ย่อมทำให้โลกเปลี่ยนแปลงไปได้ทีละน้อย ลองพิมพ์\nf = open(\u0026#39;riki.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.seek(3) print(f.read()) f.close() ผลที่ได้ก็คือข้อความที่เหมือนที่อยู่ในไฟล์ยกเว้นแค่ตัดอักษรตัวแรกออกไป นั่นเพราะ f.seek(3) หมายความว่าเลื่อนตำแหน่งไป 3 ไบต์ ซึ่งหมายถึง 1 ตัวอักษรไทย และหากลองรันเหมือนเดิมโดยเพิ่มเลขเป็น 6, 9, 12 หรืออะไรที่หาร 3 ลงตัวไปเรื่อยๆก็จะพบว่าอักษรค่อยๆหายไปทีละตัว แต่หากเปลี่ยนตัวเลขเป็นอะไรที่หาร 3 ไม่ลงตัวเมื่อไหร่ก็จะขึ้นว่า\nUnicodeDecodeError: \u0026#39;utf-8\u0026#39; codec can\u0026#39;t decode byte 0xb8 in position 0: invalid start byte นั่นเพราะอักษรไทยประกอบด้วย 3 ไบต์ ถ้าหากไปอ่านในตำแหน่งครึ่งๆกลางๆมันก็จะไม่สามารถอ่านได้ แต่ปัญหายังมีอีก หากลอง f.seek(120) ก็จะพบว่ามีปัญหาเช่นกันแม้ว่าจะหาร 3 ลงตัว ที่เป็นแบบนี้เพราะบรรทัดแรกมีอักษรเพียง 39 ตัว ซึ่งคิดเป็นไบต์ที่ 117 และรหัสขึ้นบรรทัดใหม่นั้นคิดเป็น 1 ไบต์ ดังนั้นไบต์ที่ 117 จึงเป็นรหัสขึ้นบรรทัดใหม่ และอักษรตั้งแต่บรรทัดใหม่ก็จะเริ่มจาก 118 แล้วก็ตามด้วย 121, 124 ไปเรื่อยๆ ดังนั้นจะเห็นว่าการใช้ seek กับ utf-8 ในกรณีที่ไม่ใช่อักษร ASCII นั้นค่อนข้างลำบากทีเดียว\nดังนั้นแทนที่จะใช้ seek เพื่อไปยังตำแหน่งต่างๆในไฟล์ น่าจะใช้ seek แค่เพื่อกลับมายังจุดเริ่มต้น จากนั้นใช้ read เพื่ออ่านไล่ไปจนถึงข้อความตำแหน่งที่ต้องการจะดีกว่า เพราะ read นับจำนวนตามตัวอักษร หรือบางครั้งอาจเป็นการสะดวกกว่าหาก read ทั้งหมดเก็บไว้ในสายอักขระแล้วค่อยมาวิเคราะห์ภายในโปรแกรม เพราะสายอักขระในโปรแกรมจะนับลำดับตามตัวอักษรอยู่แล้ว ทำให้จัดการง่ายกว่า\nf = open(\u0026#39;riki.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) s = f.read() print(s[0:2]) # หา  print(s[34:39]) # ยักษ์  print(s[122:126]) # เล็ก  f.close() หากต้องการรู้ตำแหน่งว่าอ่านไปถึงไหนแล้วสามารถใช้เมธอด tell ซึ่งจะคืนค่าตำแหน่งที่อ่านไฟล์กลับมา แต่ก็เป็นหน่วยไบต์เช่นเดียวกับ seek\nการอ่านไฟล์แยกทีละบรรทัด โดยปกติแล้วการอ่านไฟล์นั้นจะนิยมอ่านแยกทีละบรรทัด เพราะข้อมูลก็มักจะเก็บแยกเป็นบรรทัดเพื่อความเป็นระเบียบเช่นกัน เมธอดที่ใช้ในการอ่านแยกบรรทัดมีอยู่ ๒ ตัวคือ readlines กับ readline\nreadlines เป็นการอ่านไฟล์ทั้งหมดเช่นเดียวกับ read แต่จะเก็บแยกเป็นบรรทัด\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) r = f.readlines() print(r) f.close() แบบนี้จะได้ว่าตัวแปร r เก็บข้อความจากไฟล์โดยแยกเป็นบรรทัด หากต้องการเข้าถึงบรรทัดไหนก็แค่ใส่ [ ] เช่น\nprint(r[1]) จะได้ข้อความบรรทัดที่ ๒ (เพราะบรรทัดแรกนับเป็น 0) โดยจะเห็นว่านบรรทัดถูกเว้น เครื่องหมายขึ้นบรรทัดใหม่ \\n ถูกรวมอยู่ในนี้ด้วย ส่วนอีกวิธีคือเมธอด readline เมธอดนี้คล้ายกับ readlines ชื่อก็คล้ายกัน ต่างกันแค่ s หายไปตัวเดียวเท่านั้น readline เป็นการอ่านข้อความทีละบรรทัด โดยการใช้ครั้งหนึ่งจะเป็นการอ่านบรรทัดหนึ่ง และพอใช้อีกครั้งก็จะอ่านซ้ำ และอ่านไปจนจบ\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) for i in range(5): r = f.readline() print(r) f.close() แบบนี้ก็จะได้ข้อความ ๕ บรรทัดแรก และหาก f.readline() อีกครั้งก็จะได้ข้อความบรรทัดที่ ๖ ออกมา\nการอ่านไฟล์ด้วย for นอกจากการอ่านไฟล์ด้วยเมธอดต่างๆแล้วมีอีกวิธีหนึ่งที่สามารถอ่านไฟล์ได้โดยไม่ จำเป็นต้องใช้เมธอดใดๆเลย นั่นคือใช้ for วนภายในออบเจ็กต์ตัวไฟล์\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) for r in f: print(\u0026#39;~~ \u0026#39;+r,end=\u0026#39;\u0026#39;) f.close() ผลที่ได้ก็คือไฟล์ถูกอ่านทีละบรรทัดและถูก print ในแต่ละรอบที่วน มองดูโค้ดแล้วอาจจะรู้สึกงงๆว่า f ซึ่งเป็นออบเจ็กต์ของไฟล์ถูกนำมาใช้เป็นตัววนภายในคำสั่ง for โดยตรงเลย แบบนี้ได้ด้วยหรือ ทั้งๆที่ปกติแล้วคำสั่ง for จะถูกใช้กับออบเจ็กต์ชนิดลำดับเช่นลิสต์, ทูเพิล, ดิกชันนารี ความจริงแล้วโค้ดนี้มีค่าเท่ากับ\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) for r in f.readlines(): # ต่างกันตรงบรรทัดนี้  print(\u0026#39;~~ \u0026#39;+r,end=\u0026#39;\u0026#39;) f.close() นั่นคือเมื่อออบเจ็กต์ของไฟล์ถูกใช้กับ for มันจะถูกตัดแบ่งเป็นบรรทัด แล้วถูกดึงข้อมูลมาอ่านทีละบรรทัด เหมือนการใช้เมธอด readlines\nการใช้ with จัดการไฟล์ ปกติแล้วหากใช้ฟังก์ชัน open จะต้องตามด้วยเมธอด close เพื่อปิดไฟล์ แต่ก็มีอีกวิธีที่สามารถทำได้แทนที่จะใช้ close นั่นคือใช้ with เพื่อกำหนดขอบเขตที่ไฟล์จะถูกเปิดใช้งาน ตัวอย่างที่แล้วหากเขียนด้วย with จะได้แบบนี้\nwith open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) as f: for r in f.readlines(): print(\u0026#39;~~ \u0026#39;+r,end=\u0026#39;\u0026#39;) จะเห็นว่าต่างกันแค่บรรทัดแรกตรง open ใช้ with แล้วบรรทัดต่อมาก็ต้องมีการร่นเข้ามา และไม่ต้องปิดท้ายด้วย close แล้ว ส่วนตรงที่ประกาศตัวแปรที่จะใช้แทนออบเจ็กต์ของไฟล์นั้น แทนที่จะใช้ f= ก็ใช้ as f แทน โครงสร้างโดยทั่วไปของการใช้ with กับ open คือ\nwith open() as `ชื่อตัวแปรที่จะเก็บออบเจ็กต์ของไฟล์`: `เนื้อหาส่วนที่จะใช้ไฟล์` การใช้โครงสร้างแบบนี้มีความหมายว่าไฟล์จะถูกเปิดอยู่เฉพาะในขอบเขตภายใน โครงสร้าง with นี้เท่านั้น พอหลุดจากตรงนี้ไปไฟล์จะถูกปิดไปโดยอัตโนมัติจึงไม่ต้อง close จะใช้วิธีไหนก็ไม่ต่างกันแต่บางคนชอบใช้วิธีนี้มากกว่าเพราะรับรองได้ว่าไฟล์จะ ถูกปิดหลังจากใช้เสร็จแน่นอน ไม่ต้องพะวงว่าจะลืมปิดท้ายด้วย close หรือในกรณีที่เกิดข้อผิดพลาดระหว่างดำเนินโปรแกรมจนทำให้หยุดทำงานไปก่อนที่จะไปถึง close แบบนี้ไฟล์ก็จะไม่ถูกปิด แต่หากใช้ with ต่อให้มีข้อผิดพลาดขึ้นมากลางคันไฟล์ก็จะถูกปิดแน่นอน ดังนั้นจึงปลอดภัยสบายใจกว่า จะเห็นว่าการเปิดไฟล์อ่านมีอยู่หลากหลายวิธี นอกจากที่กล่าวถึงไปนี้ก็ยังมีวิธีอื่นอีกด้วย เช่นใช้มอดูล linecache เป็นต้น\nสรุปเนื้อหา  การอ่านไฟล์ทำได้โดยการใช้คำสั่ง open เพื่อสร้างออบเจ็กต์ที่แทนตัวไฟล์ขึ้นมา จากนั้นใช้เมธอดต่างๆเพื่อจัดการกับไฟล์ แล้วก็ลงท้ายด้วยเมธอด close เพื่อปิด การเปิดไฟล์จำเป็นต้องกำหนดโหมดว่าจะอ่านหรือเขียน และควรระบุรูปแบบการเอนโค้ดตัวหนังสือ เมธอดที่ใช้อ่านดึงข้อมูลคือ read readline readlines หรืออาจใช้คำสั่ง for โดยไม่ใช้เมธอดก็ได้ ไฟล์จะถูกอ่านไล่ตั้งแต่ต้นจนจบ โดยมีการนับจำนวนตำแหน่งไปเรื่อยๆ เมธอด seek มีไว้ย้ายตำแหน่งที่อ่านไฟล์ไปยังจุดที่ต้องการ แต่ต้องระวังว่าหน่วยเป็นไบต์ สามารถใช้โครงสร้าง with เพื่อจัดการกับไฟล์ได้ ซึ่งจะไม่ต้องใช้ close เมื่อปิดไฟล์  Reference : https://phyblas.hinaboshi.com/tsuchinoko17\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/intermediate/write_files/",
	"title": "การเขียนข้อมูลลงไฟล์",
	"tags": [],
	"description": "",
	"content": "การเปิดไฟล์สำหรับเขียน การเขียนไฟล์นั้นก็เช่นเดียวกับการอ่านไฟล์ คือจะต้องเปิดไฟล์ขึ้นมาเสียก่อน เพียงแต่ต้องกำหนดโหมดการใช้งานเป็น w หรือ a แทนที่จะเป็น r แบบตอนอ่าน ที่อาจจะฟังดูแปลกหน่อย ก็คือแม้ว่าไฟล์ที่จะเขียนนั้นยังไม่ได้มีตัวตนอยู่ ก็ตาม แต่ก็ยังต้องใช้คำสั่ง open เพื่อเปิดอะไรที่ว่างเปล่านั้นขึ้น ซึ่งการเปิดในที่นี้นั้นเท่ากับเป็นการสร้างไฟล์ขึ้นมา หาก open ไฟล์ในโหมด w จะพบว่าไฟล์นั้นถูกสร้างขึ้นมาทันทีหากมันไม่ได้มีตัวตนอยู่แต่แรก\nf = open(\u0026#39;xxxx.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.close() ลองไปดูจะพบว่ามีไฟล์ชื่อ xxxx.txt โผล่มาในโฟลเดอร์เดียวกับไฟล์โปรแกรม และภายในว่างเปล่าไม่มีอะไร โหมด w กับ a นั้นจะต่างกันตรงที่ว่าในกรณีที่ไฟล์เดิมมีตัวตนอยู่แล้วถ้าเป็นโหมด w ไฟล์จะถูกเขียนทับใหม่ทันที แต่ถ้าเป็น a จะเป็นการเขียนต่อจากไฟล์เดิม การเขียนไฟล์ก็ต้องเลือกรูปแบบการเอนโค้ดเช่นกัน ในที่นี้ใช้เป็น utf-8 เช่นเคย\nคำสั่งเขียนไฟล์ มี ๒ เมธอดที่ใช้ในการเขียนไฟล์ คือ write กับ writelines ข้อแตกต่างคือ write จะใช้กับสายอักขระอันเดียว แต่ writelines จะใช้กับลิสต์ของสายอักขระ กรณีที่ใช้กับสายอักขระเดียวยาวต่อเนื่อง จะใช้ write หรือ writelines ก็ได้เหมือนกันทั้งคู่\ns = \u0026#39;\u0026#39;\u0026#39;เวลาที่เข้าหาผู้อื่น ให้มีหัวใจที่อบอุ่นดั่งฤดูใบไม้ผลิ เวลาที่ทำงาน ให้มีหัวใจที่เร่าร้อนดั่งฤดูร้อน เวลาที่คิดอะไร ให้มีหัวใจที่แจ่มใสดั่งฤดูใบไม้ร่วง เวลาที่เผชิญหน้ากับตัวเอง ให้มีหัวใจที่เข้มงวดดั่งฤดูหนาว\u0026#39;\u0026#39;\u0026#39; f = open(\u0026#39;samejima.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.write(s) #หรือ f.writelines(s)  f.close() (ที่มาของข้อความ)\nแต่ถ้ามีสายอักขระหลายๆอันแยกกันอยู่จะใช้ได้แต่ writelines เช่น\ns = [\u0026#39;เวลาที่เข้าหาผู้อื่น ให้มีหัวใจที่อบอุ่นดั่งฤดูใบไม้ผลิ\u0026#39;, \u0026#39;เวลาที่ทำงาน ให้มีหัวใจที่เร่าร้อนดั่งฤดูร้อน\u0026#39;, \u0026#39;เวลาที่คิดอะไร ให้มีหัวใจที่แจ่มใสดั่งฤดูใบไม้ร่วง\u0026#39;, \u0026#39;เวลาที่เผชิญหน้ากับตัวเอง ให้มีหัวใจที่เข้มงวดดั่งฤดูหนาว\u0026#39;] f = open(\u0026#39;samejima.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.writelines(s) f.close() เพียงแต่ว่าจะไม่มีการเว้นบรรทัดให้ระหว่างสายอักขระแต่ละท่อน ถ้าต้องการก็ต้องเพิ่มเอาเอง ถ้าจะใช้ write ก็อาจใช้เป็น f.write('\\n\u0026rsquo;.join(s)) คือใช้เมธอด join เพื่อรวมสายอักขระเข้าด้วยกันโดยมีการขึ้นบรรทัดใหม่เป็นตัวแบ่ง หรืออาจจะเขียนต่อๆกันไปเลยก็ได้ การใช้คำสั่ง write หลายครั้งจะเป็นการเขียนต่อไปเรื่อยๆ โดยจะไม่มีการขึ้นบรรทัดใหม่ให้ดังนั้นต้องเติม \u0026lsquo;\\n\u0026rsquo; ไปด้วย\nfor a in s: f.write(a+\u0026#39;\\n\u0026#39;) สิ่งที่จะเขียนได้นั้นต้องเป็นสายอักขระเท่านั้น หากไม่ใช่สายอักขระก็ต้องแปลงก่อน\nตัวอย่าง โปรแกรมเขียนเลข 1 ถึง 10000 ลงไฟล์\nf = open(\u0026#39;10000.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) for i in range(1,10001): f.write(\u0026#39;|%d|\u0026#39;%i) if(i%100==0): f.write(\u0026#39;\\n\u0026#39;) # ขึ้นบรรทัดใหม่ถ้านับถึง 100  f.close() แค่พิมพ์โค้ดสั้นๆแค่นี้ก็มีเลขโผล่ขึ้นมาถึงหมื่นภายในพริบตา ขนาดไฟล์หลายสิบกิโลไบต์ ลองคิดดูว่าถ้าเปลี่ยนจากหมื่นเป็นพันล้านจะเป็นอย่างไร เท่านี้ก็สามารถไปประยุกต์สร้างไวรัสอย่างง่ายๆได้แล้ว ลองเขียนโปรแกรมทำนองนี้แล้วส่งให้ไปรันในเครื่องคนอื่นก็จะเกิดไฟล์ขนาดใหญ่ขึ้นอย่างรวดเร็ว แค่คิดก็น่ากลัวแล้ว ตัวอย่างทั้งหมดนี้ใช้โหมด r คือพอเปิดไฟล์มาก็จะถูกลบทิ้งแล้วเริ่มเขียนใหม่ทันที ถ้าอยากให้ไฟล์เขียนต่อก็แค่เปลี่ยน r เป็น a เท่านั้น ลองทำดูกันได้\nการคัดลอกไฟล์ เมื่อสามารถเปิดอ่านและสามารถเขียนไฟล์ได้แล้ว ต่อไปสิ่งที่จะทำได้ตามมาอย่างไม่ยากก็คือการนำข้อมูลจากไฟล์หนึ่งคัดลอกไปลงในอีกไฟล์ ซึ่งก็คือการอ่านไฟล์หนึ่ง ดึงข้อมูลมา แล้วก็นำไปเขียนในอีกไฟล์ ลองดูตัวอย่าง\nf1 = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # เปิดไฟล์ต้นฉบับ  f2 = open(\u0026#39;nishikaze2.txt\u0026#39;,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # กำหนดไฟล์ใหม่ที่จะเขียน  a = f1.read() # นำข้อมูลจากไฟล์ต้นฉบับมาเก็บในตัวแปร  f2.write(a) # นำข้อมูลจากตัวแปรมาเขียนลงในไฟล์ใหม่  f1.close() # ปิดไฟล์ต้นฉบับ  f2.close() # ปิดไฟล์ที่เขียนเสร็จ เท่านี้ก็จะได้ไฟล์ใหมที่เหมือนกับไฟล์ต้นฉบับทุกประการ แต่ความจริงแล้วนอกจากนี้ยังมีอีกวิธีที่ง่ายกว่านั้น นั่นคือใช้ฟังก์ชัน copyfile ในมอดูล shutil\nimport shutil shutil.copyfile(\u0026#39;nishikaze.txt\u0026#39;, \u0026#39;nishikaze2.txt\u0026#39;) นอกจากนี้ยังมีฟังก์ชัน move เอาไว้ย้ายไฟล์\nimport shutil shutil.move(\u0026#39;nishikaze2.txt\u0026#39;, \u0026#39;nishikaze3.txt\u0026#39;) เท่านี้ข้อมูลจากไฟล์เดิมก็ย้ายไปอยู่ในไฟล์ชื่อใหม่ แค่การคัดลอกมาทั้งหมดอาจดูง่ายไปไม่ค่อยมีอะไร เราลองมาทำอะไรที่ต้องออกแรงมากกว่านั้นสักหน่อย ต่อไปเป็นการนำข้อความจากไฟล์ต้นฉบับมาแตกออกเป็นไฟล์ย่อยแบ่งทีละบรรทัด\nf = open(\u0026#39;nishikaze.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # เปิดไฟล์ต้นฉบับ  i = 1 for r in f: # วนซ้ำเพื่อแยกวิเคราะห์ทีละบรรทัด  if(r==\u0026#39;\\n\u0026#39;): continue # หากบรรทัดไหนว่างเปล่าก็ข้ามไปเลย ไม่ต้องสร้างไฟล์ บรรทัดที่ว่างคือบรรทัดที่มีแต่ \\n คือคำสั่งขึ้นบรรทัดใหม่  fw = open(\u0026#39;n%02d.txt\u0026#39;%i,\u0026#39;w\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) # สร้างไฟล์ใหม่ ตั้งชื่อเป็น n ตามด้วยหมายเลข  fw.writelines(r) # เขียนข้อมูลที่อ่านได้ในบรรทัดนั้นลงไฟล์  fw.close() # ปิดไฟล์ที่เขียน  i += 1 f.close() # ปิดไฟล์ต้นฉบับ การจัดเก็บข้อมูลเพื่อใช้งาน โดยทั่วไปแล้วข้อมูลมักจะถูกจัดเก็บเป็นแถวๆอย่างเป็นระเบียบเพื่อให้อ่านง่ายและสะดวกต่อการใช้งาน เราอาจเก็บข้อมูลในลักษณะคล้ายตารางโดยแยกเป็นแถวและมีการเว้นวรรคระหว่างข้อมูลแต่ละตัว ยกตัวอย่าง เช่นสร้างระบบบันทึกคะแนนสอบโดยให้นักเรียนแต่ละคนป้อนคะแนนสอบแต่ละวิชาแล้วข้อมูลก็ถูกบันทึกลงไปเรื่อยๆ\nrahat = input(\u0026#39;ป้อนรหัสผู้สอบ: \u0026#39;) physics = input(\u0026#39;คะแนนฟิสิกส์: \u0026#39;) chemi = input(\u0026#39;คะแนนเคมี: \u0026#39;) chiwa = input(\u0026#39;คะแนนชีวะ: \u0026#39;) f = open(\u0026#39;khanaen.txt\u0026#39;,\u0026#39;a\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) f.write(\u0026#39;%s%s%s%s\\n\u0026#39;%(rahat,physics,chemi,chiwa)) f.close() แบบนี้พอรันโปรแกรมแต่ละครั้งก็จะมีข้อความขึ้นมาให้กรอกรหัส แตามด้วยคะแนนแต่ละวิชา เมื่อกรอกครบคะแนนก็จะถูกบันทึกลงไฟล์ สมมุติว่ามีนักศึกษามาบันทึกคะแนนแล้วทั้งหมด ๓ คน ไฟล์ก็จะออกมาในลักษณะนี้\n590001 90 76 84 590003 99 90 88 590007 80 92 100 ข้อมูลแบบนี้นำมาใช้งานได้ง่าย หากต้องการดึงข้อมูลคะแนนทั้งหมดมาวิเคราะห์ก็เปิดไฟล์ขึ้นมาอ่านแล้ว read แล้ว split แยกเอาแต่ละส่วน เช่นเอาข้อมูลที่ได้นี้มาหาค่าต่ำสุด สูงสุด และค่าเฉลี่ย\nf = open(\u0026#39;khanaen.txt\u0026#39;,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) physics = [] chemi = [] chiwa = [] for s in f: a = s.split() physics += [int(a[1])] chemi += [int(a[2])] chiwa += [int(a[3])] f.close() print(\u0026#39;คะแนนฟิสิกส์ ต่ำสุด=%d, สูงสุด=%d, เฉลี่ย=%.2f\u0026#39;%(min(physics),max(physics),sum(physics)/len(physics))) print(\u0026#39;คะแนนเคมี ต่ำสุด=%d, สูงสุด=%d, เฉลี่ย=%.2f\u0026#39;%(min(chemi),max(chemi),sum(chemi)/len(chemi))) print(\u0026#39;คะแนนชีววิทยา ต่ำสุด=%d, สูงสุด=%d, เฉลี่ย=%.2f\u0026#39;%(min(chiwa),max(chiwa),sum(chiwa)/len(chiwa))) บางครั้งตัวกั้นข้อมูลก็อาจใช้แท็บ \\t หรือในกรณีไฟล์ชนิด .csv จะกั้นด้วยจุลภาค , จะใช้เป็นอะไรก็ได้ แต่เวลาเปิดอ่านข้อมูลก็ต้องรู้และระบุตัวแยกให้ถูกต้อง\nสรุปเนื้อหา  การเขียนไฟล์ก็คล้ายกับการอ่านไฟล์ ต้องเปิดไฟล์ขึ้นมาก่อน โดยต้องเลือกโหมดเป็น w หรือ a w กับ a ต่างกันตรงที่ w เป็นการเขียนทับ ส่วน a เป็นการเขียนต่อ เมธอดที่ใช้เขียนคือ write และ writelines write ใช้กับสายอักขระ ส่วน writelines ใช้กับลิสต์ของสายอักขระ การคัดลอกไฟล์ทำได้โดยเปิดไฟล์ขึ้นมาอ่านแล้วเขียนใส่อีกไฟล์ หรือใช้ shutil.copyfile ก็ได้ สามารถใช้การอ่านและเขียนไฟล์เพื่อจัดการกับข้อมูลอย่างเป็นระบบได้  อ้างอิง\nhttp://docs.python.jp/3/library/functions.html\nhttp://diveintopython3-ja.rdy.jp/files.html\nhttp://www.ops.dti.ne.jp/ironpython.beginner/textfile.html\nhttp://www.yukun.info/blog/2008/09/python-file-write-writelines.html\nReference : https://phyblas.hinaboshi.com/tsuchinoko18\n"
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/intermediate/create_function/",
	"title": "การสร้างฟังก์ชัน",
	"tags": [],
	"description": "",
	"content": "หลังจากที่ได้เห็นฟังก์ชันต่างๆมากมายที่เป็นพื้นฐานที่ใช้กันทั่วไปแล้ว ได้เวลาที่จะมาลองสร้างฟังก์ชันขึ้นมาใช้เอง ปกติเราจะสร้างฟังก์ชันขึ้นมาใช้ก็ต่อเมื่อพบว่ามีคำสั่งอะไรบางส่วนที่มีความเป็นระบบและต้องการนำมาใช้บ่อย ๆ เช่นถ้ามีชุดคำสั่งหนึ่งที่ยาวๆแล้วต้องถูกใช้บ่อยหลายครั้งภายในโปรแกรมของเรา หากเราเอาโค้ดตรงส่วนนั้นมาทำเป็นฟังก์ชันอันหนึ่งเราก็จะเขียนมันแค่ครั้งเดียว จากนั้นพอต้องใช้ชุดคำสั่งตรงนั้นเมื่อไหร่เราก็เรียกใช้ฟังก์ชันขึ้นมา\nพอทำแบบนี้ก็จะประหยัดแรงในการเขียน โค้ดโดยรวมจะดูสั้นลงมาก และเข้าใจง่ายขึ้น การสร้างฟังก์ชัน จะทำให้การเขียนโปรแกรมของเราดูมีระบบระเบียบขึ้นมามาก.\nการสร้างและเรียกใช้ฟังก์ชัน ฟังก์ชันในทางภาษาคอมพิวเตอร์ก็คล้ายกับฟังก์ชันในทางคณิตศาสตร์ คือใส่อาร์กิวเมนต์เข้าไปแล้วได้ผลลัพธ์เป็นค่าอะไรบางอย่างคืนกลับออกมา ตัวอย่างการสร้างฟังก์ชันและใช้งาน\ndef f(x): # นิยามฟังก์ชัน f ที่มีพารามิเตอร์เป็น x  return x**3+3*x**2+3*x+1 # ค่าคืนกลับของฟังก์ชัน  print(f(7)) # เรียกใช้ฟังก์ชัน ได้ 512  print(f(13)) # เรียกใช้ฟังก์ชัน ได้ 2744 คำสั่งที่ใช้ในการสร้างฟังก์ชันก็คือ def ซึ่งก็ย่อมาจาก definition ซึ่งแปลว่าการนิยามนั่นเอง คำสั่งนี้มีไว้นิยามฟังก์ชันขึ้นมา จากนั้นหลังคำว่า def ก็ใส่ชื่อของฟังก์ชันที่ต้องการ ในที่นี้ตั้งชื่อง่ายๆว่า f จากนั้นก็ตามด้วยวงเล็บซึ่งภายในบรรจุสิ่งที่เรียกว่า พารามิเตอร์ (parameter) ซึ่งก็คือตัวแปรที่จะรับเข้ามาและเป็นตัวกำหนดอะไรต่างๆภายในฟังก์ชัน\nการตั้งชื่อฟังก์ชันเป็นไปตามกฏการตั้งชื่อตัวแปรทั่วไป\nหลังชื่อฟังก์ชันและพารามิเตอร์แล้วก็จะตามด้วยโคลอน : จากนั้นก็ขึ้นบรรทัดใหม่โดยมีการร่น และภายในส่วนนั้นจะเป็นรายละเอียดของฟังก์ชัน สำหรับฟังก์ชันที่มี การคืนค่าคืนกลับนั้น ค่าคืนกลับกำหนดโดยคำสั่ง return โดยพิมพ์คำว่า return แล้วเว้นวรรคตามด้วยค่าที่ต้องการให้คืนกลับ ในตัวอย่างนี้ค่าคืนกลับคือผลการคำนวณทางคณิตศาสตร์ตามที่เราต้องการ\nการนิยามฟังก์ชันก็สิ้นสุดลงเพียงเท่านี้ การประกาศสร้างฟังก์ชันจะใส่ไว้ตรงไหนก็ได้ภายในตัวโปรแกรม คำสั่งที่อยู่ภายในฟังก์ชันจะไม่มีการทำงานจนกว่าจะถูกเรียกใช้\nการเรียกใช้ฟังก์ชันทำได้โดยพิมพ์ชื่อของฟังก์ชันตามด้วยวงเล็บที่ใส่ อาร์กิวเมนต์ที่สอดคล้องกับพารามิเตอร์ที่ของฟังก์ชันนั้นไว้ข้างใน คำว่าพารามิเตอร์นั้นมีความหมายใกล้เคียงกับอาร์กิวเมนต์ แต่พารามิเตอร์คือตัวแปรที่ใช้ตอนสร้างฟังก์ชัน แต่เวลาที่เรียกใช้ฟังก์ชันค่าที่ป้อนเข้าไปจะเรียกว่าอาร์กิวเมนต์\nในตัวอย่างนี้ใส่ค่าอาร์กิวเมนต์เป็น 7 จากนั้นค่านี้จะถูกนำไปแทนพารามิเตอร์ x ภายในฟังก์ชัน แล้วก็ถูกนำไปคำนวณแล้วได้ค่า 7**3+3*7**2+3*7+1 = 512 กลับออกมา หลังจากนั้นพอใส่อาร์กิวเมนต์เป็น 13 ก็ทำในลักษณะเดียวกัน แต่จะได้ผลลัพธ์ต่างกัน\nพารามิเตอร์อาจไม่จำเป็นต้องมีเลยก็ได้ ถ้าไม่ต้องการรับค่าอะไรมาใช้ในฟังก์ชัน แบบนั้นวงเล็บหลังชื่อฟังก์ชันก็เว้นว่างเป็น f() หรืออาจมีหลายตัว ซึ่งก็จะคั่นด้วยจุลภาค โดยที่เวลาเรียกใช้จะต้องใส่ลำดับของอาร์กิวเมนต์ให้ตรงกับพารามิเตอร์ที่สอดคล้องกันด้วย ตัวอย่าง สมการในทฤษฎีสัมพัทธภาพพิเศษของไอนสไตน์ E = mc^2 พลังงานเท่ากับมวลคูณความเร็วแสงกำลังสอง\ndef E(m,c): return m*c**2 m = 9.10938356e-31 # มวลอิเล็กตรอน  c = 2.99792458e8 # ความเร็วแสง  print(E(m,c)) # พลังงานจากมวลของอิเล็กตรอน ในการป้อนค่าให้พารามิเตอร์นั้นนอกจากใส่ในรูปแบบของอาร์กิวเมนต์แล้วก็ยังสามารถใส่ในรูปแบบคีย์เวิร์ดได้ด้วย\nprint(E(m=9.10938356e-31,c=2.99792458e8)) กรณีใช้คีย์เวิร์ดจะมีข้อดีคือสามารถสลับลำดับยังไงก็ได้ ไม่จำเป็นต้องเรียง ดังนั้นจะเขียนแบบนี้ก็ได้ผลเหมือนเดิม\nprint(E(c=2.99792458e8,m=9.10938356e-31)) หรือจะใส่ปนกันทั้งคีย์และอาร์กิวเมนต์ก็ได้ แต่ว่าอาร์กิวเมนต์ต้องขึ้นก่อนเสมอ\nprint(E(m,c=2.99792458e8)) แต่จะไม่สามารถใส่ตัวแรกเป็นคีย์เวิร์ดและตัวที่สองเป็นอาร์กิวเมนต์ได้ เพราะถ้ามีอาร์กิวเมนต์อยู่สักตัวจะถูกตีความว่าเป็นพารามิเตอร์ตัวแรกสุดก่อนแล้วไล่ลำดับมา\nprint(E(2.99792458e8,m=9.10938356e-31)) # ได้ TypeError: E() got multiple values for argument \u0026#39;m\u0026#39; กรณีนี้ 2.99792458e8 ถูกตีความเป็นค่า m ซึ่งเป็นพารามิเตอร์ตัวแรก พอมีการใส่คีย์เวิร์ด m= ลงไปอีกจึงกลายเป็นว่าได้ค่าซ้อนกัน จึงขัดข้องทันที ฟังก์ชันอาจไม่จำเป็นต้องมีการคืนค่าเสมอไป หากไม่มีการคืนค่าก็ไม่ต้องใส่คำสั่ง return ตัวอย่าง ฟังก์ชันที่จะพิมพ์ดอกจันตามจำนวนที่ป้อนเข้าไป\ndef daodaodao(x,y): # นิยามฟังก์ชัน พารามิเตอร์คือจำนวนดาวในแนวนอนและแนวตั้งตามลำดับ  for i in range(y): for j in range(x): print(\u0026#39;*\u0026#39;,end=\u0026#39;\u0026#39;) # พิมพ์ดอกจัน  print(\u0026#39;\u0026#39;) # ขึ้นบรรทัดใหม่  daodaodao(30,10) # เรียกใช้ สร้างดอกจันแถวละ ๓๐ ดอก จำนวน ๑๐ แถว การแตกลิสต์มาใช้เป็นอาร์กิวเมนต์ของฟังก์ชัน บางครั้งเราอาจเก็บข้อมูลที่จะนำมาใช้เป็นอาร์กิวเมนต์ของฟังก์ชันไว้ในรูปแบบของลิสต์ ซึ่งบางครั้งก็สะดวกกว่า กรณีแบบนี้แทนที่จะต้องมาไล่เขียนแจกแจงสมาชิกในลิสต์ สามารถแตกสมาชิกทั้งหมดของลิสต์มาใช้เป็นอาร์กิวเมนต์ได้โดยเติมดอกจัน หน้าตัวแปรลิสต์\ndef f(x,y,z): print((x**2+y**2+z**2)**0.5) xyz = [3,4,12] f(*xyz) # แทนที่จะต้องมาเขียน f(xyz[0],xyz[1],xyz[2])  # ได้ 13.0 จะใส่ลิสต์ปนกับข้อมูลเดี่ยวแบบนี้ก็ได้เช่นกัน\ndef f(x,y,z,t): print((x**2+y**2+z**2+t**2)**0.5) xyz = [3,4,12] t = 20 f(*xyz,t) วิธีการนี้จะใช้กับฟังก์ชันอะไรก็ได้ ไม่เพียงแต่ฟังก์ชันที่เราสร้างขึ้นเอง เช่นฟังก์ชัน print เองก็สามารถใช้ตัวแปรลิสต์ที่มีดอกจัน\nการใช้ดิกชันนารีเป็นคีย์เวิร์ด ในขณะที่ลิสต์สามารถใช้เป็นอาร์กิวเมนต์ได้ ดิกชันนารีก็สามารถใช้เป็นคีย์เวิร์ดได้ ซึ่งการใช้นั้นทำได้โดยใส่ดอกจันสองอันนำหน้าตัวแปรดิกชันนารี\ndef f(x,y,z): print((x**2+y**2+z**2)**0.5) xyz = {\u0026#39;x\u0026#39;:3,\u0026#39;y\u0026#39;:4,\u0026#39;z\u0026#39;:12} f(**xyz) # แทนที่จะใส่ f(xyz[\u0026#39;x\u0026#39;],xyz[\u0026#39;y\u0026#39;],xyz[\u0026#39;z\u0026#39;])  # ได้ 13.0 ในที่นี้ดิกชันนารี xyz มีคีย์เป็น x, y และ z คีย์แต่ละอันจะกลายมาเป็นคีย์เวิร์ดในฟังก์ชัน\nพารามิเตอร์แบบมีกี่ตัวก็ได้ ถ้านิยามฟังก์ชันโดยกำหนดพารามิเตอร์โดยทั่วไปแล้วจำนวนอาร์กิวเมนต์หรือคีย์เวิร์ดที่ใช้ในฟังก์ชันจะตายตัวอยู่แล้ว แต่ในบางสถานการณ์ก็อาจจะต้องการส่งค่าจำนวนมากเข้าฟังก์ชันโดยที่ไม่รู้ว่าจะ มีกี่ตัว ซึ่งสามารถทำได้โดยใช้ * หรือ ** กับพารามิเตอร์ กรณีใช้ดอกจันอันเดียว * ตัวแปรนั้นจะเก็บค่าอาร์กิวเมนต์ในรูปของลิสต์ ตัวอย่าง ผลบวกกำลังสองของอาร์กิวเมนต์ทุกตัวที่ใส่ลงไป\ndef f(*arg): a = 0 for x in arg: a += x**2 a **= 0.5 print(a) f(3,4,12) # ได้ 13.0  f(7,24,60) # ได้ 65.0 กรณีใช้ดอกจันสองอัน ** ตัวแปรนั้นจะเก็บค่าคีย์เวิร์ดในรูปของดิกชันนารี\ndef f(**kw): print((kw[\u0026#39;x\u0026#39;]**2+kw[\u0026#39;y\u0026#39;]**2+kw[\u0026#39;z\u0026#39;]**2)**0.5) f(x=3,y=4,z=12) # ได้ 13.0 พารามิเตอร์ที่มี * และ ** สามารถใช้ปนกันกับพารามิเตอร์ธรรมดาได้ แต่ต้องวางไว้ข้างหลัง\ndef f(t,**kw): print((kw[\u0026#39;x\u0026#39;]**2+kw[\u0026#39;y\u0026#39;]**2+kw[\u0026#39;z\u0026#39;]**2+t**2)**0.5) f(x=7,y=24,z=60,t=156) # ได้ 169.0 โดยในกรณีนี้เฉพาะ t เท่านั้นที่มีกำหนดพารามิเตอร์แยกไว้ต่างหาก ดังนั้นจะไม่ถูกนำมารวมใน kw ด้วย หากใช้ปนกันทั้งพารามิเตอร์ธรรมดาและที่มี * และ ** ก็จะต้องเรียงเอาพารามิเตอร์ธรรมดาไว้ก่อน แล้วค่อยตามด้วย * แล้วค่อย **\ndef f(t,*arg,**kw): a = 0 for x in arg: a += x**2 a **= 0.5 print((a**2+kw[\u0026#39;x\u0026#39;]**2+kw[\u0026#39;y\u0026#39;]**2+t**2)**0.5) f(12,15,16,x=36,y=48) # ได้ 65.0 กรณีนี้ t จะเป็น 12 ส่วน arg จะเป็น [15,16] และ kw เป็น {'x':36,'y':48}\nค่าตั้งต้นของตัวแปรในฟังก์ชัน บางครั้งฟังก์ชันก็ไม่จำเป็นจะต้องรับค่าอาร์กิวเมนต์หรือคีย์เวิร์ดให้ ครอบคลุมทุกพารามิเตอร์ที่กำหนดไว้ หากฟังก์ชันมีการกำหนดค่าตั้งต้นของพารามิเตอร์ไว้\nให้ลองนึกถึงฟังก์ชันบางตัวที่โปรแกรมมีอยู่แล้ว เช่น open สำหรับเปิดไฟล์ (บทที่ ๑๗) โดยปกติแล้วจะต้องเลือกโหมดว่าจะอ่านหรือเขียน คือเป็น r, w, a หรืออื่นๆ แต่หากไม่ใส่เลยก็จะเป็น r ไปโดยอัตโนมัติ หรืออย่างฟังก์ชัน print ที่กำหนดตัวปิดท้ายเป็นการขึ้นบรรทัดใหม่ \u0026quot;\\n\u0026quot; ไปโดยอัตโนมัติ ยกเว้นว่าเราจะใส่คีย์เวิร์ด end= เพิ่มเข้าไป\nการกำหนดค่าตั้งต้นให้พารามิเตอร์ทำได้โดยใส่ค่าไปตอนที่ประกาศพารามิเตอร์ คือในวงเล็บหลังฟังก์ชัน ค่าตั้งต้นนี้จะถูกใช้เฉพาะในกรณีที่ไม่มีการป้อนค่าให้พารามิเตอร์\nตัวอย่าง พ่อค้าคนหนึ่งมีสินค้าอยู่ ๔ ชนิด แต่ละชนิดราคาไม่เท่ากัน บางวันบางอันก็ขายดีบ้างไม่ดีบ้าง จะหารายได้ที่ได้ในแต่ละวัน\ndef raidai(a=0,b=0,c=0,d=0): print(a*200+b*300+c*400+d*500) raidai(b=15,c=20) # มี b และ c ได้ 12500  raidai(15,20,10) # มี a, b และ c ได้ 13000  raidai(15,20,d=10) # มี a, b และ d ได้ 14000  raidai() # ไม่มีอะไรเลย ได้ 0 ในตัวอย่างนี้จะเห็นว่าใส่ค่าให้ตัวแปร a b c d ไม่ครบแต่ฟังก์ชันก็ทำงานได้ตามปกติ โดยตัวแปรไหนที่ไม่ได้รับค่าก็จะเป็น 0 ซึ่งเป็นไปตามค่าที่กำหนดตั้งต้นไว้ กรณีที่ใส่เป็นอาร์กิวเมนต์ พารามิเตอร์ตัวแรกๆจะได้ค่าไปก่อน ถ้าอยากให้ตัวหลังๆมีค่าในขณะที่ตัวแรกๆไม่มีก็ต้องใช้คีย์เวิร์ดเท่านั้น\nการคืนกลับข้อมูลเป็นกลุ่ม โดยปกติแล้วฟังก์ชันที่มีค่าคืนกลับจะคืนค่าได้เพียงตัวเดียวเท่านั้น เพราะพอเจอคำสั่ง return แล้วการทำงานของฟังก์ชันจะสิ้นสุดลงทันที ไม่สามารถ return หลายครั้งได้\nแต่หากต้องการให้คืนกลับหลายตัวก็ทำได้ด้วยการให้คืนกลับเป็นข้อมูลชนิดกลุ่ม เช่นลำดับ, ทูเพิล, ดิกชันนารี ตัวอย่าง ฟังก์ชันที่คืนค่า x ยกกำลังตั้งแต่ 1 ไปจนถึงยกกำลัง n\ndef yok(x,n): return [x**i for i in range(1,n+1)] print(yok(2,12)) # ได้ [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]  print(yok(3,7)) # ได้ [3, 9, 27, 81, 243, 729, 2187] ขอบเขตของตัวแปร ปกติแล้วหากในฟังก์ชันมีการสร้างตัวแปรขึ้นมา ตัวแปรนั้นจะหายไปทันทีที่จบการใช้งานฟังก์ชันนั้น หากเรียกใช้ตัวแปรนั้นหลังจากนั้นก็จะพบว่ามันไม่มีตัวตนอยู่แล้ว ไม่สามารถใช้งานได้\ndef baba(): c = 1 baba() print(c) # ได้ NameError: name \u0026#39;c\u0026#39; is not defined หากต้องการให้ตัวแปรที่ถูกนิยามภายในฟังก์ชันั้นคงอยู่ต่อไปแม้ฟังก์ชันจะทำงาน จบลงแล้ว แบบนี้จะต้องใช้คำสั่ง global เพื่อประกาศว่าตัวแปรนั้นเป็นตัวแปรสากล สามารถใช้ได้ทั้งโปรแกรม การประกาศนั้นต้องทำการที่จะป้อนค่าให้ตัวแปร\ndef baba(): global c c = 1 baba() print(c) # ได้ 1 นอกจากนี้ global ยังใช้ในกรณีที่ต้องการให้ตัวแปรที่นิยามจากนอกฟังก์ชัน สามารถแก้ไขเปลี่ยนแปลงค่าภายในฟังก์ชันได้ โดยปกติแล้วกรณีที่ตัวแปรภายในฟังก์ชัน ชื่อซ้ำกับนอกฟังก์ชันจะถือว่าเป็น ตัวแปรคนละตัวเดียวกัน และการกระทำภายในฟังก์ชันนั้น จะเป็นการทำกับตัวแปรภายในฟังก์ชัน ไม่ส่งผลต่อตัวแปรนอกฟังก์ชัน\ndef baba(): a = 3 # กำหนดค่าตัวแปร a ขึ้นมาใหม่ ไม่เกี่ยวกับนอกฟังก์ชัน  print(a) # ได้ 3  a = 2 baba() print(a) # ได้ 2 เพราะไม่ได้รับผลจากการเปลี่ยนแปลงค่าที่เกิดในฟังก์ชัน แต่ในกรณีที่ภายในฟังก์ชันไม่ได้กำหนดตัวแปรชื่อเดียวกันอยู่ ตัวแปรภายในฟังก์ชันนั้น จึงเป็นตัวแปรที่ถูกนิยามจากภายนอก\ndef baba(): print(a) # แสดงผลค่า a ซึ่งกำหนดจากนอกฟังก์ชัน  a = 2 baba() สรุปคือเวลาที่มีการเรียกใช้ตัวแปรภายในฟังก์ชัน โปรแกรมจะทำการหาว่ามีตัวแปรชื่อนั้น อยู่ภายในฟังก์ชันหรือเปล่าก่อน ถ้ามีก็ใช้ตัวแปรนั้น แต่ถ้าไม่มีจึงไปหานอกฟังก์ชัน\nข้อควรระวังคือ หากมีการป้อนค่าให้กับตัวแปรภายในฟังก์ชัน โปรแกรมจะถือว่าตัวแปรนั้น เป็นตัวแปรในฟังก์ชัน หากมีการเรียกใช้ก่อนส่วนที่ให้ค่าจะขัดข้องทันที\ndef baba(): print(a) # ถูกเรียกใช้ก่อนป้อนค่า  a = 3 a = 2 baba() # ได้ UnboundLocalError: local variable \u0026#39;a\u0026#39; referenced before assignment หากต้องการให้ตัวแปรสามารถทั้งใช้และเปลี่ยนแปลงค่าได้ภายในฟังก์ชันจำเป็นต้องใช้คำสั่ง global ตัวอย่าง\ndef baba(): global b a=1 b=1 a=2 b=2 baba() print(a) # ได้ 2  print(b) # ได้ 1 ในนี้จะเห็นว่ามีการกำหนดค่าให้ทั้ง a และ b ๒ ที่คือทั้งในและนอกฟังก์ชัน ที่ต่างกันคือ b มีการกระกาศ global แต่ a ไม่มี ซึ่งทำให้ค่า b ภายในฟังก์ชันกลายเป็นตัวเดียวกับ b นอกฟังก์ชัน\nความเปลี่ยนแปลงค่าของตัวแปรที่ถูกใช้เป็นอาร์กิวเมนต์ โดยปกติแล้วค่าของตัวแปรที่ถูกใช้เป็นอาร์กิวเมนต์ของฟังก์ชันจะไม่มีการ เปลี่ยนค่า เพราะฟังก์ชันแค่ดึงค่าของตัวแปรไปใช้เพื่อทำอะไรบางอย่าง หากต้องการใช้ฟังก์ชัน เพื่อให้ตัวแปรมีการเปลี่ยนแปลงค่าจะไม่สามารถทำได้ โดยตรงแต่ต้องใช้ = กับฟังก์ชันอีกที เช่น\ndef f(x): return x+1 x = f(x) แบบนี้ x จะมีค่าเพิ่มขึ้นมา 1 อย่างไรก็ตาม หากตัวแปรที่เป็นอาร์กิวเมนต์คือลิสต์ ความเปลี่ยนแปลงอาจเกิดขึ้นกับสมาชิกในลิสต์ได้ ในกรณีที่มีการป้อนค่าใหม่ให้สมาชิกนั้นโดยตรงในฟังก์ชัน\ndef plian(s): s[0] = \u0026#39;k\u0026#39; s[3] = \u0026#39;ng\u0026#39; listA = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;] plian(listA) print(listA) # ได้ [\u0026#39;k\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ng\u0026#39;] ที่เป็นอย่างนี้เพราะตัวแปรลิสต์นั้นมีหน้าที่ชี้ตำแหน่งของตัวแปร แม้ว่าตัวแปรลิสต์ภายในกับภายนอกฟังก์ชันจะเป็นคนละตัวกัน แต่การที่ฟังก์ชันรับค่าลิสต์นั้นมาก็เท่ากับว่ารับเอาตำแหน่งที่ถูกชี้นั้นมา ดังนั้นลิสต์ภายในและนอกฟังก์ชันจะชี้ไปที่ตัวแปรตัวเดียวกัน เมื่อมีการแก้ไขค่าตัวแปรนั้นก็จะเปลี่ยนแปลงตามไปด้วย แต่ว่าถ้าหากเป็นการป้อนค่า ให้กับลิสต์นั้นเท่ากับเป็นการแก้ตัวลิสต์ทั้งลิสต์ ไม่ได้เป็นการแก้ตัวแปรที่ถูกลิสต์ชี้อยู่ ดังนั้นค่าในลิสต์เดิมจะไม่มีการเปลี่ยนแปลงไป\ndef plian2(s): s = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;] return s listA = [\u0026#39;ก\u0026#39;,\u0026#39;ข\u0026#39;,\u0026#39;ค\u0026#39;,\u0026#39;ง\u0026#39;] plian2(listA) print(listA) # ได้ [\u0026#39;ก\u0026#39;, \u0026#39;ข\u0026#39;, \u0026#39;ค\u0026#39;, \u0026#39;ง\u0026#39;] อ้างอิง\n http://docs.python.jp/3/reference/compound_stmts.html http://www.python-izm.com/contents/application/function.shtml http://www.geocities.jp/m_hiroi/light/python02.html http://www.ops.dti.ne.jp/ironpython.beginner/argskw.html   Reference : https://phyblas.hinaboshi.com/tsuchinoko19\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/intermediate/recursive_function/",
	"title": "ฟังก์ชันเวียนเกิด",
	"tags": [],
	"description": "",
	"content": "ฟังก์ชันเวียนเกิด (Recursive Function) คือฟังก์ชันที่มีการคืนค่าเป็นตัวฟังก์ชันนั้นเอง ทำให้ต้องมีการเรียกใช้ตัวฟังก์ชันนั้นซ้ำ และในฟังก์ชันที่เรียกซ้ำนั้น ก็มีการเรียกฟังก์ชันเดิมซ้ำอีก วนเวียนอย่างนี้ไปเรื่อยๆ จนถึงจุดหนึ่ง จะมีเงื่อนไขที่ทำให้ฟังก์ชันนั้นคืน ค่ากลับโดยที่ไม่ต้องเรียกฟังก์ชันซ้ำอีก การวนซ้ำจึงหยุดลง อธิบายด้วยคำพูดแบบนี้ยังไงก็คงจะยังเข้าใจยากอยู่ มาดูตัวอย่างน่าจะช่วยให้เห็นภาพชัดกว่า\nแฟ็กทอเรียล ฟังก์ชันแฟ็กทอเรียลนั้นเป็นหนึ่งในตัวอย่างที่ง่ายที่สุดของการใช้ฟังก์ชันเวียนเกิด\nลองดูตัวอย่างการใช้ สร้างฟังก์ชัน fac(x) = x! = 1×2×3×...×x\ndef fac(x): if(x\u0026gt;1): return fac(x-1)*x else: return 1 print(fac(6)) # ได้ 720 จะเห็นว่าฟังก์ชัน fac ในที่นี้มีการเรียกตัวมันเองคือฟังก์ชัน fac ซ้ำอีกภายในนั้น การเรียกซ้ำนี้จะเกิดขึ้นตราบใดที่ยังมากกว่า 1 แต่ถ้าเป็น 1 จะคืนค่า 1 โดยไม่มีการเรียกซ้ำ ลองนึกตามทีละขั้น สมมุติเราเรียกใช้ฟังก์ชันโดยใส่อาร์กิวเมนต์เป็น 1 คือ fac(1)\nแบบนี้ฟังก์ชันจะเข้า else ทันทีเพราะ x เป็น 1 ดังนั้นจึงคืนค่า 1 กลับมา ซึ่งเป็นไปตามที่ควรจะเป็น\nต่อไปลองคิดกรณี fac(2) กรณี นี้เมื่อเรียกใช้ x=2 จะเข้าเงื่อนไขแรก ซึ่งจะต้อง return fac(x-1)*x ทำให้มีการเรียกใช้ฟังก์ชันนั้นซ้ำ แต่คราวนี้อาร์กิวเมนต์ต่างไปโดยลดลงไป 1 เป็น x-1 ก็คือเหลือ 1 ซึ่งจะคืนค่า 1 กลับมา จากนั้นก็ถูกนำไปคูณกับ x ก็คือ 2 ดังนั้นผลที่ได้ก็คือได้ 2\nคิดต่อไป กรณี fac(3)\nเมื่อ เรียกใช้ x=3 จะเข้าเงื่อนไขแรก เรียก return fac(x-1)*x เมื่อแทนค่า x จะได้เป็น return fac(2)*3 ซึ่ง fac(2) ก็รู้ค่าแล้วจากกรณี x=2 ว่าเป็น 2 ดังนั้นเอามาคูณกันก็ได้ผลลัพธ์เป็น 6\nกรณี x=4 ก็จะ return fac(3)*4 จึงได้ผลเป็น 24\nกรณี x=5 ก็จะ return fac(4)*3 จึงได้ผลเป็น 120\nกรณี x=6 ก็จะ return fac(5)*4 จึงได้ผลเป็น 720\nเป็นอย่างนี้ซ้ำไปเรื่อยๆเป็นจำนวนครั้งตามค่าของ x ที่ใส่ลงไป เพราะเมื่อเรียกใช้ฟังก์ชัน ภายในฟังก์ชันจะมีการเรียกฟังก์ชันเดิมซ้ำด้วย x ที่ต่ำลงไปทีละขั้น พอเรียกซ้ำก็จะเรียก x ที่ต่ำลงไปเรื่อยๆจนในที่สุดก็เป็น 1 และไม่มีการเรียกซ้ำอีก\nสุดท้ายผลที่ได้จึงเป็นการคูณสะสมเพิ่มไปเรื่อยๆ กลายเป็นฟังก์ชันแฟ็กทอเรียลตามที่ต้องการ หากจะลองเขียนเป็นฟังก์ชันธรรมดาที่ไม่ต้องมีการเวียนเกิดก็สามารถทำได้โดยใช้การวนทำซ้ำ ลองเปรียบเทียบกันดู\ndef fac(x): f = 1 # ตั้งต้นที่ 1  for i in range(2,x+1): # ใช้ for วนซ้ำ ไล่ตั้งแต่ 2  f = f*i # คูณเพิ่มไปเรื่อยๆ  return f # คืนผลลัพธ์ที่ได้กลับไป  print(fac(6)) ข้อดีข้อเสียของการใช้ฟังก์ชันแบบเวียนเกิดเมื่อเทียบกับการไม่ใช้ ข้อดี\n หากใช้ได้คล่องแล้วจะมองปัญหาออกได้ง่ายขึ้น เข้าใจง่ายกว่า เขียนแล้วดูสั้นกว่า ง่ายกว่ามากในกรณีที่มีการทำซ้ำซ้อนกันเป็นวังวนในจำนวนที่ไม่แน่นอน  ข้อเสีย\n เปลืองหน่วยความจำมากกว่า ในบางกรณีอาจทำงานช้ากว่า  สรุปก็คือวิธีการนี้ไม่ได้ทำให้โปรแกรมทำงานเร็วขึ้น แถมอาจช้าลงอีก เพียงแต่ในบางปัญหาจะทำให้ดูเรียบง่ายขึ้น เขียนฟังก์ชันสั้นเกินคาดทั้งๆที่น่าจะซับซ้อน ดังนั้นที่สำคัญคือมองปัญหาให้ออกว่าเวลาไหนควรจะใช้ เลือกใช้ตามความเหมาะสม เพื่อให้เห็นภาพชัดลองดูตัวอย่างอื่นเปรียบเทียบกันอีก\nฟีโบนัชชี ลำดับฟีโบนัชชี (Fibonacci) คือลำดับที่มีสมาชิก ๒ ตัวแรกมีค่าเท่ากับ 1 นอกนั้นตัวถัดไปจะมีค่าเท่ากับสองตัวก่อนหน้าบวกกัน\n1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, ... ลองมาเขียนเป็นฟังก์ชันในไพธอนดู\ndef fib(x): if(x\u0026gt;2): return fib(x-1)+fib(x-2) else: return 1 print(fib(8)) จะเห็นว่าฟังก์ชันนี้มีการกำหนดเงื่อนไขตามที่ได้กล่าวข้างต้น คือถ้า x เป็นตัวที่ 1 หรือ 2 จะมีค่าเป็น 1 แต่ถ้าเป็นตัวถัดจากนั้นจะมีค่าเท่ากับสองตัวก่อนหน้าบวกกัน ฟังก์ชันแบบนี้ถ้าไม่ใช้เป็นแบบเวียนเกิด ใช้การวนซ้ำธรรมดาจะเป็นอย่างไร\ndef fib(x): a = 1 b = 1 f = 1 for i in range(3,x+1): f = a+b a = b b = f return f print(fib(8)) คราวนี้จะเห็นว่าใช้ฟังก์ชันแบบเวียนเกิดดูแล้วการเขียนดูเรียบง่ายกว่าพอสมควร แต่อย่างไรก็ตาม ภายใต้ความเรียบง่ายของมัน ก็แฝงไปด้วยความน่ากลัว ลองพิจารณาดูจะเห็นว่ากรณีใช้ฟังก์ชันเวียนเกิดนั้นเมื่อเรียกใช้ฟังก์ชันครั้ง หนึ่งจะมีการเรียกตัวมันเองถึง ๒ ครั้ง คือ fib(x) จะมีการเรียก fib(x-1) และ fib(x-2) ขึ้นมา และภายในนั้น fib(x-1) ก็จะทำการเรียก fib(x-2) และ fib(x-3) ส่วน fib(x-2) ก็ไปเรียก fib(x-3) กับ fib(x-4) แล้วก็วนเรียกซ้ำเพิ่มไปเรื่อยๆ จำนวนครั้งที่เรียกมีแต่จะเพิ่มขึ้นเรื่อยๆเป็นทวีคูณ\nการเรียกในแต่ละครั้งเป็นการคำนวณใหม่ทุกครั้ง แม้ว่า fib(x-2) จะถูกเรียกซ้ำ 2 ครั้ง fib(x-3) ถูกเรียกซ้ำ 3 ครั้ง แต่มันก็ไม่ได้เก็บค่าเดิมเอาไว้ แต่กลับคำนวณใหม่แยกกัน ผลก็คือเครื่องทำงานหนักและประสิทธิภาพการทำงานต่ำ ในขณะที่ถ้าใช้ for วนซ้ำธรรมดา ตัวแปรมีการเก็บค่าเสร็จแล้วก็นำมาใช้แล้วล้างใหม่ทุกรอบ พอเป็นแบบนี้แล้วเครื่องจึงทำงานเบากว่ามาก\nสรุป กรณีนี้ฟังก์ชันเวียนเกิดเขียนง่ายแต่ประสิทธิภาพแย่ ฟิโบนัชชีจึงเป็นตัวอย่างของกรณีที่ไม่ควรจะใช้ บางครั้งการเขียนสั้นไม่ได้แปลว่าเป็นโปรแกรมที่ดี ต้องพิจารณาด้วยว่าโปรแกรมมีการทำงานอย่างไรอยู่เบื้องหลังคำสั่งนั้น\nฟังก์ชันสำหรับยุบลิสต์ ลองดูตัวอย่างการใช้ที่ไม่ได้เกี่ยวข้องกับฟังก์ชันทางคณิตศาสตร์กันบ้าง ตัวอย่างหนึ่งที่จะช่วยให้เห็นว่าใช้ฟังก์ชันเวียนเกิดแล้วง่ายก็คือการยุบลิสต์ สมมุติว่ามีลิสต์หน้าตาซับซ้อนแบบนี้อยู่ [[['a','b'],['c','d']],[['e','f'],['g',['h','i']]],['j','k'],'l']\nจะเห็นว่าเป็นลิสต์ซ้อนกันหลายชั้น สูงสุดคือ h กับ i นี้ซ้อนอยู่ในชั้นที่ ๔ คือเป็นลิสต์ในลิสต์ในลิสต์ในลิสต์ เราจะทำให้ทั้งหมดนี้มาอยู่ในลิสต์อันเดียว คือกลายเป็น ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'] สามารถทำได้ด้วยการสร้างฟังก์ชันเวียนเกิด\ndef yup(l): y = [] # สร้างลิสต์เปล่าขึ้นมาก่อน  for c in l: if(type(c)==list): # ตรวจชนิดของสมาชิกว่าเป็นลิสต์หรือเปล่า  y += yup(c) # ถ้าเป็นลิสต์ให้เรียกฟังก์ชันซ้ำเพื่อยุบก่อนค่อยเพิ่มเข้าไป  else: y += [c] # ถ้าไม่ใช่ลิสต์ให้เพิ่มเข้าไปในสมาชิก  return y # คืนค่าลิสต์ที่ได้  lia = [[[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;],[\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;]],[[\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;],[\u0026#39;g\u0026#39;,[\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;]]],[\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;],\u0026#39;l\u0026#39;] print(yup(lia)) ในนี้จะเห็นว่าฟังก์ชัน yup มีการเรียกใช้ตัวมันเองในกรณีที่สมาชิกเป็นลิสต์ เพื่อให้ลิสต์นั้นยุบก่อนที่จะบวกเพิ่มเข้าไป ถ้าภายในลิสต์นั้น มีลิสต์อยู่อีกจึงทำการเรียกตัวเองซ้ำอีก ปัญหานี้ยากที่จะใช้การวนซ้ำด้วย for เพราะเราไม่รู้ว่าจะต้องมีวังวนซ้อนอยู่กี่ชั้น\nหอคอยฮานอย ตัวอย่างปัญหาอีกอย่างที่ดูเหมือนจะยากแต่ถ้าใช้ฟังก์ชันเวียนเกิดจะดูแล้วง่ายลงไปทันที\nรายละเอียดเขียนไว้ใน https://phyblas.hinaboshi.com/20160301\nอ้างอิง\nhttp://www2.cc.niigata-u.ac.jp/~takeuchi/tbasic/BackGround/Recursive.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko20\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/intermediate/lambda/",
	"title": "คำสั่งพิเศษที่เกี่ยวข้องกับฟังก์ชัน",
	"tags": [],
	"description": "",
	"content": "ในบทนี้จะพูดถึงคำสั่งบางอย่างที่เกี่ยวข้องกับฟังก์ชัน ซึ่งความจริงแล้ว อาจไม่ได้มีความจำเป็นต้องใช้มากนัก เพียงแต่ในบางกรณี ก็ทำให้การเขียนโค้ดดูสั้นกระชับเรียบง่ายขึ้น จึงเหมาะใน บางกรณี และต่อให้บางคนไม่ได้กะจะใช้แต่ก็อาจเรียนรู้ไว้เผื่อไปศึกษาโค้ดของคนอื่น ได้ คำสั่งเหล่านั้นได้แก่ lambda, map, filter, any และ all\nlambda นอกจากการนิยามฟังก์ชันแบบทั่วไปที่ใช้กันแล้ว สำหรับฟังก์ชันที่แค่ต้องการให้มีการคืนค่า โดยที่ไม่ได้มีการดำเนินการอะไรอาจสามารถนิยามได้โดยใช้คำสั่ง lambda ลองยกตัวอย่างฟังก์ชันคำนวณง่ายๆ\ndef f(x): return x**3+4*x**2+5**x+1 หากนิยามโดยใช้ lambda ก็จะเป็น\nf = lambda x:x**3+4*x**2+5**x+1 รูปแบบการเขียนอาจดูเข้าใจยากสักหน่อย แต่จะเห็นว่าดูแล้วเขียนสั้นลงเล็กน้อย\nสรุปรูปแบบการเขียนคือ\n\u0026lt;ชื่อตัวแปรที่ต้องการให้เป็นฟังก์ชัน\u0026gt; = lambda \u0026lt;อาร์กิวเมนต์\u0026gt;:\u0026lt;ค่าคืนกลับ\u0026gt; ผลที่ได้ก็จะมีค่าเท่ากับการใช้ def ลองเทียบกันดู\ndef \u0026lt;ชื่อตัวแปรที่ต้องการให้เป็นฟังก์ชัน\u0026gt;(\u0026lt;อาร์กิวเมนต์\u0026gt;): return \u0026lt;ค่าคืนกลับ\u0026gt; หากมีอาร์กิวเมนต์หลายตัวก็ใช้จุลภาคคั่นเช่นเดียวกับการนิยามฟังก์ชันทั่วไป เช่น\nf = lambda x,y,z:x+y+z print(f(3,4,5)) # ได้ 12 จะได้ฟังก์ชันสำหรับบวกค่าตัวเลข ๓ ตัว\nข้อด้อยของการใช้ lambda ก็คือไม่สามารถสร้างฟังก์ชันสำหรับดำเนินการอะไรได้ ทำได้แต่ฟังก์ชันสำหรับคืนค่า แต่ข้อดีคือถ้าต้องการแค่ประกาศฟังก์ชันที่มีแค่การคืนค่าแล้วละก็ จะเขียนสั้นกว่าใช้ def สามารถสร้างฟังก์ชันพร้อมกันหลายๆตัวได้อย่างรวดเร็ว เช่นตัวอย่างนี้ สร้างฟังก์ชันบวกลบคูณหารพร้อมกัน\nf4 = [lambda x,y:x+y,lambda x,y:x-y,lambda x,y:x*y,lambda x,y:x/y] print(f4[0](4,5)) # 9  print(f4[1](4,5)) # -1  print(f4[2](4,5)) # 20  print(f4[3](4,5)) # 0.8 การทำแบบนี้ถ้าใช้ def ก็ต้องประกาศฟังก์ชันทีละตัว แล้วค่อยเอาชื่อฟังก์ชันมาเก็บรวมกันในลิสต์ ไม่สามารถทำทุกอย่างในบรรทัดเดียวได้แบบที่ใช้ lambda นอกจากนี้ lambda ยังมีข้อดีตรงที่สามารถสร้างแล้วใช้งานได้ทันทีโดยที่อาจไม่ต้องตั้งชื่อ ฟังก์ชัน (ไม่ต้องสร้างตัวแปรออบเจ็กต์ฟังก์ชัน) ซึ่งทำให้สะดวก ใช้งานได้รวดเร็ว เช่น\nprint((lambda x:x**2)(10)) # ได้ 100  print([(lambda x:x+10)(x) for x in range(10,20)]) # ได้ [20, 21, 22, 23, 24, 25, 26, 27, 28, 29] ด้านหลังโคลอน : จะต้องเป็นค่าอะไรสักอย่างที่ต้องการให้คืนกลับ แต่จะใส่เป็นฟังก์ชันที่สั่งให้ทำงานอะไรบางอย่างก็ได้ แต่ในกรณีแบบนั้นหากฟังก์ชันนั้นไม่ได้ส่งค่าคืนกลับมาก็จะได้ None\nprint((lambda x:print(x*2))(7)) # จะมีเลข 14 ถูก print ออกมาก่อน จากนั้นจะได้ None ดังนั้นเราอาจใช้สร้างฟังก์ชันธรรมดาที่ไม่มีการคืนค่าก็ได้ เช่นฟังก์ชันที่จะพิมพ์เลข ๒ เท่าของที่ใส่เข้าไป\nprintx2 = lambda x:print(x*2) printx2(12) # ได้ 24 หลัง lambda อาจไม่จำเป็นจะต้องใส่ตัวแปรเลยก็ได้ กรณีแบบนี้ก็จะได้ฟังก์ชันที่ไม่ต้องการอาร์กิวเมนต์\nprint((lambda:1)()) # ได้ 1 map บางครั้งมีลิสต์อยู่อันหนึ่ง และมีฟังก์ชันอยู่อันหนึ่งซึ่งต้องการจะให้ใช้สมาชิกในลิสต์นั้นเพื่อเป็น อาร์กิวเมนต์ของฟังก์ชันแล้วคืนค่าออกมาโดยแยกกัน โดยทั่วไปก็จะต้องใช้ for เพื่อวนทำซ้ำให้ครบทุกตัว\ndef f(x): return x**3 xxxx = [2,7,11,16] x3 = [] for x in xxxx: x3 += [f(x)] print(x3) # ได้ [8, 343, 1331, 4096] แต่ว่ามีวิธีที่จะเขียนให้ง่ายและสั้นขึ้นมาก คือการใช้คำสั่ง map\ndef f(x): return x**3 xxxx = [2,7,11,16] x3 = list(map(f,xxxx)) print(x3) # ได้ [8, 343, 1331, 4096] map นั้นเป็นคำสั่งสำหรับให้คืนค่าที่ฟังก์ชันหนึ่งทำกับกลุ่มข้อมูลหนึ่ง การใช้ map นั้นเป็นการสร้างออบเจ็กต์ชนิดหนึ่งคือชนิด map ซึ่งเป็นอิเทอเรเตอร์ตัวหนึ่ง ถ้าต้องการให้เป็นลิสต์ก็ต้องคร่อมด้วย list() ไปอีกทีดังตัวอย่าง\nออบเจ็กต์ map สามารถทำงานได้เหมือนกับเป็นลิสต์เมื่อใช้คู่กับ for ดังนั้นในกรณีที่จะใช้กับ for อยู่แล้วก็ไม่จำเป็นต้องแปลงเป็นลิสต์ก็ได้\nสรุปโครงสร้างของการใช้ map\n\u0026lt;ตัวแปรที่รับค่าออบเจ็กต์ map\u0026gt; = map(\u0026lt;ฟังก์ชัน\u0026gt;,\u0026lt;ลิสต์\u0026gt;) หรือถ้าต้องการเปลี่ยนเป็นลิสต์ทันที\n\u0026lt;ตัวแปรที่รับค่าออบเจ็กต์ map\u0026gt; = list(map(\u0026lt;ฟังก์ชัน\u0026gt;,\u0026lt;ลิสต์\u0026gt;)) อนึ่ง ที่จริงแล้ววิธีที่เขียนสั้นๆได้อีกวิธีคือใช้ for สร้างลิสต์\nx3 = [f(x) for x in xxxx] ผลที่ได้ก็เหมือนกัน จะใช้แบบไหนก็แล้วแต่กรณี แล้วแต่ความถนัด ออบเจ็กต์ map เป็นอิเทอเรเตอร์ ซึ่งมีข้อดีคือจะประหยัดหน่วยความจำกว่าลิสต์และทำงานเร็วกว่าในกรณีที่ไม่มีความ จำเป็นต้องใช้งานในรูปแบบลิสต์ บางครั้ง map ยังใช้คู่กับ lambda เพื่อจะได้ไม่ต้องนิยามฟังก์ชันขึ้นมาก่อน ทำให้การเขียนยิ่งสั้นกะทัดรัด\nxxxx = [2,7,11,16] x3 = list(map(lambda x:x**3,xxxx)) print(x3) # ได้ [8, 343, 1331, 4096] ลองประยุกต์ใช้กับอย่างอื่นอีก เช่น เปลี่ยนตัวเลขเป็นสายอักขระ\nprint(list(map(str,range(10)))) # ได้ [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;]  print(\u0026#39;\u0026#39;.join(map(str,range(10)))) # ได้ 0123456789 จะเห็นว่าเมธอด join สามารถใช้กับออบเจ็กต์ map ได้โดยตรงโดยไม่ต้องแปลงเป็นลิสต์ก่อน\nmap คืนค่าเป็นอิเทอเรเตอร์แบบนี้แค่ในไพธอน 3 เท่านั้น ส่วนในไพธอน 2 นั้น map จะคืนค่าเป็นลิสต์ไม่ใช่อิเทอเรเตอร์ ดังนั้นไม่ต้องมาแปลงเป็นลิสต์อีกทีเพื่อแสดงผล\nfilter ก็เช่นเดียวกัน\n รายละเอียด\n filter บางครั้งเรามีลิสต์อยู่อันหนึ่ง แล้วต้องการคัดกรองส่วนประกอบบางอย่างออกไป โดยทั่วไปแล้วก็อาขใช้ for วนเพื่อตรวจแต่ละอันแล้วดูเงื่อนไขว่าตรงหรือเปล่าถ้าไม่ตรงก็คัดออก ตัวอย่าง มีลิสต์อยู่อันหนึ่งที่มีสายอักขระอยู่หลายตัว จะกรองเอาเฉพาะสายอักขระที่สั้นกว่า 6 ตัวอักษร\nk = [\u0026#39;egao\u0026#39;,\u0026#39;kibou\u0026#39;,\u0026#39;yuuki\u0026#39;,\u0026#39;jishin\u0026#39;,\u0026#39;kagayaki\u0026#39;,\u0026#39;ai\u0026#39;,\u0026#39;yasashisa\u0026#39;] f = [] for s in k: if(len(s)\u0026lt;6): f += [s] print(f) # ได้ [\u0026#39;egao\u0026#39;, \u0026#39;kibou\u0026#39;, \u0026#39;yuuki\u0026#39;, \u0026#39;ai\u0026#39;] หรืออาจเขียนสั้นๆด้วยวิธีการสร้างลิสต์ใหม่จาก for เป็น\nf = [s for s in k if(len(s)\u0026lt;6)] print(f) # ได้ [\u0026#39;egao\u0026#39;, \u0026#39;kibou\u0026#39;, \u0026#39;yuuki\u0026#39;, \u0026#39;ai\u0026#39;] แต่ก็มีอีกวิธีหนึ่งที่สามารถใช้ได้ คือใช้ filter ซึ่งมีวิธีการเขียนดังนี้\ndef filt(s): # นิยามฟังก์ชันสำหรับคัดกรองขึ้นมาก่อน  return len(s)\u0026lt;6 f = list(filter(filt,k)) print(f) # ได้ [\u0026#39;egao\u0026#39;, \u0026#39;kibou\u0026#39;, \u0026#39;yuuki\u0026#39;, \u0026#39;ai\u0026#39;] เขียนแบบนี้อาจดูเข้าใจยากสักหน่อย อาร์กิวเมนต์ตัวแรกของ filter คือฟังก์ชันซึ่งจะถูกพิจารณาค่าความจริงเท็จ ในที่นี้ชื่อ filt ส่วนตัวที่สองคือลิสต์ที่จะนำมาคัดกรอง คือลิสต์ k filter จะทำการกรองสมาชิกในลิสต์ที่แทนค่าลงในฟังก์ชันนั้นแล้วได้ค่าความจริงเป็น จริง เอาที่ให้ค่าเป็นเท็จออกไป ในที่นี้จะเป็นจริงเมื่อความยาวของสายอักขระน้อยกว่า 6 ผลที่ได้จะอยู่ในรูปของออบเจ็กต์ชนิด filter ซึ่งก็เป็นอิเทอเรเตอร์เช่นเดียวกับ map filter มักใช้คู่กับ lambda เพื่อจะทำให้ไม่จำเป็นต้องนิยามฟังก์ชันขึ้นมาก่อน ดูกะทัดรัดขึ้นมาก\nf = list(filter(lambda s:len(s)\u0026lt;6,k)) print(f) # ได้ [\u0026#39;egao\u0026#39;, \u0026#39;kibou\u0026#39;, \u0026#39;yuuki\u0026#39;, \u0026#39;ai\u0026#39;] ตัวอย่างการใช้ การหาเลขจำนวนเฉพาะโดยวิธีการตะแกรงของเอราโตสเธเนส\nตะแกรงของเอราโตสเธเนส (Ἐρατοσθένης) มีที่มาจากนักคณิตศาสตร์กรีกโบราณ เป็นการคัดกรองหาเลขที่เป็นจำนวนเฉพาะโดยการไล่ตัดตัวเลขที่หารจำนวนเฉพาะ ลงตัวไปทีละนิด โดยเริ่มดูจาก 2 ตามด้วย 3 แล้วก็ 5 ไปเรื่อยๆ กล่าวคือ เริ่มไล่ดูว่าตัวไหนหาร 2 ลงตัวก็ตัดจำนวนนั้นออก จากนั้นทำซ้ำกับ 3 ส่วนเลข 4 ถูกตัดไปแล้วจึงข้ามไปทำ 5 แล้วก็ข้ามไป 7 และ 11 ต่อไปเรื่อยๆ\nn = 121 # จำนวนตัวเลขที่จะพิจารณา  ch = range(2,n+1) i = 0 # ตำแหน่งของสมาชิกในลิสต์ที่จะใช้เป็นตัวกรอง เริ่มจากตัวแรก  while(ch[i]\u0026lt;=n**0.5): # ให้วนกรองไปเรื่อยๆจนกว่าจะถึงตัวเลขที่เท่ากับรากที่สองของ n  ch = list(filter(lambda x:x%ch[i]!=0 or x==ch[i],ch)) # คัดกรองเอาไว้เฉพาะตัวที่หารตัวที่เป็นตัวกรองอยู่ไม่ลงตัว และตัวกรองเอง  print(\u0026#39;รอบที่ %d: \u0026#39;%(i+1)+\u0026#39;,\u0026#39;.join(map(str,ch))) # แสดงผลเลขที่เหลืออยู่ในแต่ละรอบ  i += 1 # พิจารณาตัวถัดไป ผลลัพธ์\nรอบที่ 1: 2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,101,103,105,107,109,111,113,115,117,119,121 รอบที่ 2: 2,3,5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83,85,89,91,95,97,101,103,107,109,113,115,119,121 รอบที่ 3: 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,91,97,101,103,107,109,113,119,121 รอบที่ 4: 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,121 รอบที่ 5: 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113 any กับ all any เป็นฟังก์ชันสำหรับตรวจสอบความจริงเท็จของข้อมูลกลุ่ม ถ้าในกลุ่มมีข้อมูลที่มีค่าความจริงเท็จเป็น True แม้แต่ตัวเดียวจะได้ค่า True ทันที any(ลิสต์) เทียบเท่ากับ (1 in ลิสต์)\nprint(1 in [1,0,1]) # ได้ True  print(any([1,0,1])) # ได้ True  print(any([0,0,0])) # ได้ False ส่วน all นั้นจะตรวจว่าข้อมูลในกลุ่มเป็นจริงทั้งหมดหรือเปล่า ถ้ามี False แม้แต่ตัวเดียวจะเป็น False ทันที all(ลิสต์) เทียบเท่ากับ (1 in ลิสต์)\nprint(0 not in [1,0,1]) # ได้ False  print(all([1,0,1])) # ได้ False  print(all([1,1,1])) # ได้ True การประยุกต์ใช้นั้นเช่นเดียวกับ filter คือสามารถใช้คู่กับ map และ lambda ได้ โดยใช้ lambda สร้างฟังก์ชันที่ตรวจสอบเงื่อนไขที่ต้องการ จากนั้นใช้ map เพื่อให้ฟังก์ชันนั้นทำกับทุกตัวในลิสต์ ผลที่ได้ก็คือจะได้ลิสต์ที่มีค่า True หรือ False (1 หรือ 0)\nprint(any(map(lambda x:x\u0026gt;0,[-7,-1,2,6]))) # ได้ True  print(all(map(lambda x:x\u0026gt;0,(-5,0,3,9)))) # ได้ False  print(all(map(lambda x:x%2,range(-7,9,2)))) # ได้ True  print(any(map(lambda x:x%2==0,range(-5,13,4)))) # ได้ False สรุปเนื้อหา\nทั้ง lambda, map และ filter นั้นลักษณะการเขียนอาจดูแล้วเข้าใจยากในช่วงแรกๆ แต่หากใช้เป็นแล้วในบางกรณีจะช่วยให้การเขียนง่ายขึ้นมาก\nแต่ก็ไม่ใช่คำสั่งที่ขาดไม่ได้ ดังนั้นบางคนอาจไม่เคยต้องใช้มันเลย แต่ก็อาจควรเรียนรู้ไว้สักหน่อยเผื่อว่าไปอ่านโค้ดที่คนอื่นเขียนแล้วเขาใช้ จะได้เข้าใจได้\nอ้างอิง\nhttp://python.keicode.com/lang/functions-lambda.php\nhttp://atkonn.blogspot.com/2008/02/python-python27-lambda.html\nhttp://python.civic-apps.com/map-reduce-filter\nhttp://python.civic-apps.com/list-comprehensions\nhttp://diveintopython3-ja.rdy.jp/porting-code-to-python-3-with-2to3.html\nhttp://jutememo.blogspot.com/2008/09/python-map-filter-reduce.html\nhttp://cortyuming.hateblo.jp/entry/20080821/p1\n Reference : https://phyblas.hinaboshi.com/tsuchinoko21\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/python/phyblas/intermediate/inheritance/",
	"title": "การรับทอด",
	"tags": [],
	"description": "",
	"content": "นอกจากการสร้างคลาสขึ้นมาใหม่ตั้งแต่เริ่มต้นแล้วเรายังสามารถนำคลาสที่มี อยู่แล้วมาเสริมให้เป็นคลาสใหม่ได้ วิธีการนี้เรียกว่าการรับทอด (inheritance)\nวิธีการนี้มีประโยชน์เพราะสามารถใช้ประโยชน์จากคลาส เดิมที่มีอยู่แล้วโดยไม่ต้องสร้างใหม่แค่นำมาเปลี่ยนแปลงแก้ไขให้เข้ากับการใช้งานตามที่ต้องการมากขึ้นเท่านั้น\nเมื่อเราสร้างคลาสใหม่ขึ้นด้วย วิธีการรับทอด คลาสใหม่ที่สร้างจะถูกเรียกว่าเป็นซับคลาส (subclass) ของคลาสเดิม และคลาสเดิมก็จะเรียกว่าเป็นซูเปอร์คลาส (superclass) ของคลาสใหม่ คลาสที่สร้างมาจากการรับทอดจะมีแอตทริบิวต์และเมธอด เหมือนกับซูเปอร์คลาสของมัน แต่สามารถเพิ่มเมธอดหรือแอตทริบิวต์ใหม่ลงไป หรือเขียนทันของเก่าได้\nอินสแตนซ์ของซับคลาสจะเป็นอินสแตนซ์ของซูเปอร์คลาสไปด้วย แต่อินสแตนซ์ของซูเปอร์คลาสจะไม่เป็นอินสแตนซ์ของซับคลาสไปด้วย การรับทอดทำได้โดยการใส่ชื่อคลาสที่ต้องการรับทอดไว้ในวงเล็บหลังชื่อคลาสใหม่ตอนที่ประกาศสร้างคลาสใหม่ขึ้น\nการสร้างคลาสด้วยการรับทอด จะขอยกตัวอย่างที่ต่อเนื่องจากบทที่แล้ว ในบทที่แล้วได้สร้างคลาส \u0026quot;ผู้กล้า\u0026quot; ขึ้น ซึ่งผู้กล้านี้ก็อาจสามารถแบ่งย่อยเป็นอาชีพต่างๆได้อีกเช่นนักรบหรือจอมเวทย์\nในบทนี้เราจะสร้างคลาสเหล่านี้ขึ้นมาใหม่โดยรับทอดจากคลาส \u0026quot;ผู้กล้า\u0026quot;\nclass อาวุธ:  def __init__(self,ชื่อ,พลังโจมตีกายภาพ,พลังโจมตีเวทย์,ความทนทาน): self.ชื่อ = ชื่อ self.พลังโจมตีกายภาพ = พลังโจมตีกายภาพ self.พลังโจมตีเวทย์ = พลังโจมตีเวทย์ self.ความทนทาน = ความทนทาน class เสื้อผ้า:  def __init__(self,ชื่อ,พลังป้องกัน,ความทนทาน): self.ชื่อ = ชื่อ self.พลังป้องกัน = พลังป้องกัน self.ความทนทาน = ความทนทาน class ผู้กล้า:  def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,ความอดทน=4,hpสูงสุด=10): self.ชื่อ = ชื่อ self.เลเวล = เลเวล self.ความแข็งแรง = ความแข็งแรง self.ความอดทน = ความอดทน self.hpสูงสุด = hpสูงสุด self.hp = hpสูงสุด เสื้อผ้า = เสื้อผ้า(\u0026#39;ชุดเก่าๆ\u0026#39;,3,5) อาวุธ = อาวุธ(\u0026#39;มีดสั้นเก่าๆ\u0026#39;,3,0,5) เงินเดือน = 500 def พลังโจมตี(self): return self.ความแข็งแรง + self.อาวุธ.พลังโจมตีกายภาพ def พลังป้องกัน(self): return self.ความอดทน + self.เสื้อผ้า.พลังป้องกัน def ถูกโจมตี(self,ความเสียหาย): if(ความเสียหาย\u0026gt;self.พลังป้องกัน()): self.hp -= ความเสียหาย - self.พลังป้องกัน() else: self.hp -= 1 if(self.hp\u0026lt;0): self.hp = 0 class นักรบ(ผู้กล้า):  เสื้อผ้า = เสื้อผ้า(\u0026#39;ชุดนักรบฝึกหัด\u0026#39;,5,5) อาวุธ = อาวุธ(\u0026#39;ดาบฝึกหัด\u0026#39;,5,0,5) class จอมเวทย์(ผู้กล้า):  def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,พลังเวทย์=4,ความอดทน=4,hpสูงสุด=10,mpสูงสุด=10): self.ชื่อ = ชื่อ self.เลเวล = เลเวล self.พลังเวทย์ = พลังเวทย์ self.ความแข็งแรง = ความแข็งแรง self.ความอดทน = ความอดทน self.hpสูงสุด = hpสูงสุด self.hp = hpสูงสุด self.mpสูงสุด = mpสูงสุด self.mp = mpสูงสุด เสื้อผ้า = เสื้อผ้า(\u0026#39;ชุดจอมเวทย์ฝึกหัด\u0026#39;,2,5) อาวุธ = อาวุธ(\u0026#39;คฑาฝึกหัด\u0026#39;,0,5,5) def พลังโจมตีเวทย์(self): return self.พลังเวทย์ + self.อาวุธ.พลังโจมตีเวทย์ จะเห็นว่ามีการสร้างคลาสขึ้นใหม่ ๓ คลาส คือ \u0026ldquo;อาวุธ\u0026rdquo;, \u0026ldquo;เสื้อผ้า\u0026rdquo; และ \u0026ldquo;ผู้กล้า\u0026rdquo; ซึ่งใกล้เคียงกับบทที่แล้วแต่ต่างไปเล็กน้อย จากนั้นก็สร้างคลาสใหม่ขึ้นอีก ๒ คลาสโดยวิธีการรับทอด นั่นคือ \u0026ldquo;นักรบ\u0026rdquo; และ \u0026ldquo;จอมเวทย์\u0026rdquo; ซึ่งจะเห็นได้ว่ามีวงเล็บ \u0026ldquo;ผู้กล้า\u0026rdquo; อยู่ข้างหลัง ซึ่งแสดงถึงว่าทั้ง ๒ คลาสนี้รับทอดมาจาก \u0026ldquo;ผู้กล้า\u0026rdquo; นั่นเอง\nในคลาส \u0026ldquo;นักรบ\u0026rdquo; ไม่ได้มีการเพิ่มหรือแก้ไขเมธอด แต่มีแค่การใส่ค่าแอตทริบิวต์ในคลาส นั่นคือ \u0026ldquo;อาวุธ\u0026rdquo; และ \u0026ldquo;เสื้อผ้า\u0026rdquo; ใหม่ ซึ่งแอตทริบิวต์นี้จะไปทับของที่มีอยู่แล้วในคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ส่วนคลาส \u0026ldquo;จอมเวทย์\u0026rdquo; ก็มีการเปลี่ยน \u0026ldquo;อาวุธ\u0026rdquo; และ \u0026ldquo;เสื้อผ้า\u0026rdquo; เหมือนกัน และยังมีการนิยามเมธอด __init__ ขึ้นใหม่ ซึ่งเมธอดนี้จะไปทับ __init__ ทำให้ใช้อันใหม่นี้แทน ซึ่งข้อแตกต่างจะเห็นว่ามีการเพิ่ม \u0026ldquo;พลังเวทย์\u0026rdquo; และ \u0026ldquo;mpสูงสุด\u0026rdquo; ขึ้นมา\nนอกจากนี้ยังเพิ่มเมธอด \u0026ldquo;พลังโจมตีเวทย์\u0026rdquo; ซึ่งไม่ได้ถูกนิยามขึ้นในคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ตั้งแต่แรก เมธอดนี้จึงถูกสร้างขึ้นใหม่และใช้ได้เฉพาะออบเจ็กต์ของคลาส \u0026ldquo;จอมเวทย์\u0026rdquo; เท่านั้น คลาส \u0026ldquo;นักรบ\u0026rdquo; ไม่มีการนิยาม __init__ ขึ้นมาใหม่ ดังนั้นจึงมีเมธอด init ที่เหมือนกับคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ทุกประการ จะเห็นว่า __init__ ของ \u0026ldquo;จอมเวทย์\u0026rdquo; นั้นต่างจากของ \u0026ldquo;ผู้กล้า\u0026rdquo; ไม่มาก แค่เพิ่มพารามิเตอร์ขึ้นมาเท่านั้น ในกรณีแบบนี้เราอาจไม่ต้องเขียนใหม่ทั้งหมดแต่ใช้ฟังก์ชัน __init__ ของ \u0026ldquo;ผู้กล้า\u0026rdquo; ได้ สามารถทำได้โดยเขียนใหม่เป็น\nclass จอมเวทย์(ผู้กล้า):  def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,พลังเวทย์=4,ความอดทน=4,hpสูงสุด=10,mpสูงสุด=10): ผู้กล้า.__init__(self,ชื่อ,เลเวล,ความแข็งแรง,ความอดทน,hpสูงสุด) self.พลังเวทย์ = พลังเวทย์ self.mpสูงสุด = mpสูงสุด self.mp = mpสูงสุด จะเห็นว่ามีการเรียกใช้ __init__ ของ \u0026ldquo;ผู้กล้า\u0026rdquo; ภายในเมธอด __init__ ของ \u0026ldquo;จอมเวทย์\u0026rdquo; อีกที โดยพารามิเตอร์ก็ต้องใส่ให้สัมพันธ์กันด้วย พารามิเตอร์ที่ซ้ำกับคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; จะถูกป้อนค่าให้กับแอตทริบิวต์ของออบเจ็กต์ด้วย __init__ ด้านในนี้ ส่วนพารามิเตอร์ที่เหลือซึ่งเพิ่มเข้ามาก็ค่อยมาป้อนให้กับแอตทริบิวต์ของออบเจ็กต์อีกที นอกนี้ยังมีวิธีเขียนอีกแบบ นั่นคือใช้ฟังก์ชัน super\nclass จอมเวทย์(ผู้กล้า):  def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,พลังเวทย์=4,ความอดทน=4,hpสูงสุด=10,mpสูงสุด=10): super(จอมเวทย์,self).__init__(ชื่อ,เลเวล,ความแข็งแรง,ความอดทน,hpสูงสุด) self.พลังเวทย์ = พลังเวทย์ self.mpสูงสุด = mpสูงสุด self.mp = mpสูงสุด ฟังก์ชัน super ต้องการอาร์กิวเมนต์ ๒ ตัว ตัวแรกคือคลาส ตัวหลังคือออบเจ็กต์ ในที่นี้ออบเจ็กต์ถูกแทนด้วย self ผลที่ได้คือเป็นการที่ออบเจ็กต์ของคลาสนี้เรียกเมธอดของซุเปอร์คลาสของคลาส มัน ในที่นี้คืออบเจ็กต์ของคลาส \u0026ldquo;จอมเวทย์\u0026rdquo; เรียกใช้เมธอดของคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ซึ่งเป็นซูเปอร์คลาส สังเกตได้ว่าพอใช้ super แล้ว ในอาร์กิวเมนต์ของ init ก็ไม่ต้องมี self แล้ว อย่างไรก็ตามกรณีที่ฟังก์ชัน super นี้ถูกใช้ในโครงสร้างคลาสจะสามารถละอาร์กิวเมนต์ได้ ดังนั้นจึงเขียนแค่นี้ได้\nclass จอมเวทย์(ผู้กล้า):  def __init__(self,ชื่อ,เลเวล=1,ความแข็งแรง=4,พลังเวทย์=4,ความอดทน=4,hpสูงสุด=10,mpสูงสุด=10): super().__init__(ชื่อ,เลเวล,ความแข็งแรง,ความอดทน,hpสูงสุด) self.พลังเวทย์ = พลังเวทย์ self.mpสูงสุด = mpสูงสุด self.mp = mpสูงสุด ***การละแบบนี้ทำได้เฉพาะในไพธอน 3 ส่วนในไพธอน 2 ไม่สามารถละอาร์กิวเมนต์แบบนี้ได้ ต้องเขียนเต็มเท่านั้น รายละเอียด ลองสร้างออบเจ็กต์มาทดสอบการใช้กันดูได้เลย\nผู้เล่นA = จอมเวทย์(\u0026#39;มานะ\u0026#39;,1,5,8,4,12,11) ผู้เล่นB = นักรบ(\u0026#39;พากเพียร\u0026#39;,1,7,6,14) print(ผู้เล่นA.เสื้อผ้า.ชื่อ) # ได้ ชุดจอมเวทย์ฝึกหัด  print(ผู้เล่นB.เสื้อผ้า.ชื่อ) # ได้ ชุดนักรบฝึกหัด  print(ผู้เล่นA.hp) # ได้ 12  ผู้เล่นA.ถูกโจมตี(10) print(ผู้เล่นA.hp) # ได้ 8 การรับทอดหลายต่อ การรับทอดสามารถทำได้หลายต่อเป็นทอดๆกี่ครั้งก็ได้ เช่นนักรบก็อาจแบ่งเป็นนักดาบและนักธนู จอมเวทย์ก็อาจแบ่งเป็นจอมเวทมนตร์ขาวและจอมเวทมนตร์ดำ เป็นต้น\nclass นักดาบ(นักรบ):  0 class นักธนู(นักรบ):  อาวุธ = อาวุธ(\u0026#39;ธนูฝึกหัด\u0026#39;,6,0,5) class จอมเวทมนตร์ดำ(จอมเวทย์):  0 class จอมเวทมนตร์ขาว(จอมเวทย์):  0 ในที่นี้ขอละการเขียนรายละเอียดของคลาสใหม่นี้เพิ่มเติม แต่หลักการก็คล้ายๆเดิม คือ \u0026ldquo;นักดาบ\u0026rdquo; และ \u0026ldquo;นักธนู\u0026rdquo; จะรับทอดเมธอดและแอตทริบิวต์ของ \u0026ldquo;นักรบ\u0026rdquo; ซึ่งรับทอดแอตทริบิวต์ของ \u0026ldquo;ผู้กล้า\u0026rdquo; มาอีกต่อ ซับคลาสของซับคลาสของคลาสหนึ่งก็ถือเป็นซับคลาสของคลาสนั้นด้วย ดังนั้น \u0026ldquo;นักดาบ\u0026rdquo; ถือเป็นซับคลาสของ \u0026ldquo;ผู้กล้า\u0026rdquo; ไปด้วย และออบเจ็กต์ของคลาส \u0026ldquo;นักดาบ\u0026rdquo; ก็จะเป็นอินสแตนซ์ของคลาส \u0026ldquo;นักรบ\u0026rdquo; แล้วก็เป็นอินสแตนซ์ของคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ไปด้วย ความจริงแล้วคลาสที่เราสร้างขึ้นมาจากเริ่มต้นโดยไม่ได้ใส่วงเล็บไว้ข้างหลัง นั้นก็ถือเป็นการรับทอดคลาสที่ชื่อว่า \u0026ldquo;object\u0026rdquo; อยู่แล้วในตัว เพียงแต่สามารถละได้เท่านั้น โดยทั่วไปจึงไม่ต้องเขียนวงเล็บ แต่ถ้าจะเขียนก็จะเห็น\nclass ผู้กล้า(object): ซึ่งก็มีค่าเหมือนเขียน\nclass ผู้กล้า: นั่นหมายความว่าจริงๆแล้วคลาสทุกชนิดเป็นซับคลาสของคลาสที่ชื่อ object นั่นเพราะในไพธอนนั้นข้อมูลทุกอย่างล้วนเป็นออบเจ็กต์ ดังนั้นไม่ว่าอะไรก็ตามจึงเป็นอินสแตนซ์ของคลาสที่ชื่อ object นั่นเอง หากเรียงลำดับการรับทอดในตัวอย่างนี้ก็จะเป็น\nobject \u0026gt; ผู้กล้า \u0026gt; นักรบ \u0026gt; นักดาบ การรับทอดจากหลายคลาส ในการรับทอดนั้นที่จริงอาจสามารถรับทอดจากหลายๆคลาสพร้อมกันได้ ไม่จำกัดว่ารับทอดได้แค่คลาสเดียว หากจะรับทอดจากหลายคลาสก็แค่ใส่หลายๆคลาสลงในวงเล็บข้างหลังชื่อคลาสตอน ประกาศสร้างคลาส เช่น ลองสร้างคลาส \u0026ldquo;นักรบเวทย์\u0026rdquo; ขึ้นมาเป็นซับคลาสของ \u0026ldquo;นักรบ\u0026rdquo; กับ \u0026ldquo;นักเวทย์\u0026rdquo;\nclass นักรบเวทย์(นักรบ,จอมเวทย์):  0 กรณีที่คลาสทั้งสองที่รับทอดมานั้นมีการนิยามเมธอดหรือแอตทริบิวต์เหมือนกันจะยึดตามตัวที่ชื่อขึ้นก่อน ในที่นี้แอตทริบิวต์ \u0026ldquo;เสื้อผ้า\u0026rdquo; กับ \u0026ldquo;อาวุธ\u0026rdquo; ต่างก็ถูกนิยามใหม่ในคลาส \u0026ldquo;นักรบ\u0026rdquo; และ \u0026ldquo;จอมเวทย์\u0026rdquo; แต่ \u0026ldquo;นักรบ\u0026rdquo; ขึ้นก่อน ดังนั้นแอตทริบิวต์นี้จะถูกนิยามตาม \u0026ldquo;นักรบ\u0026rdquo; ในขณะที่ \u0026ldquo;จอมเวทย์\u0026rdquo; มีนิยามเมธอด __init__ ขึ้นมาใหม่แต่ \u0026ldquo;นักรบ\u0026rdquo; ไม่มี ดังนั้นเมธอด __init__ ของ \u0026ldquo;นักรบเวทย์\u0026rdquo; ก็จะรับทอด __init__ ของ \u0026ldquo;จอมเวทย์\u0026rdquo;\nผู้เล่นD = นักรบเวทย์(\u0026#39;หรรษา\u0026#39;) print(นักรบเวทย์.เสื้อผ้า.ชื่อ) # ได้ ชุดนักรบฝึกหัด  print(นักรบเวทย์.อาวุธ.ชื่อ) # ได้ ดาบฝึกหัด  print(ผู้เล่นD.mpสูงสุด) # ได้ 10 อนึ่ง ที่จริงแล้วการรับทอดจาก ๒ คลาสขึ้นไปพร้อมกันนั้นในบางภาษาเช่นภาษาจาวาจะไม่สามารถทำได้ และนักเขียนโปรแกรมบางคนก็ไม่สนับสนุนการทำแบบนี้เพราะอาจทำให้เกิดปัญหาได้ในกรณีที่ชื่อตัวแปรหรือเมธอดมีการซ้อนทับกัน กรณีแบบนี้จะต้องมีอย่างใดอย่างหนึ่งหายไปและทำให้มีการทำงานไม่สมบูรณ์ ในกรณีของ C++ หากมีเมธอดชื่อซ้ำกันแล้วไม่ได้ระบุไว้ว่าจะให้เหลือของฝ่ายไหนก็จะเกิดข้อผิดพลาดขึ้น ดังนั้นแม้ว่าภาษาไพธอนจะสามารถรับทอดจาก ๒ คลาสขึ้นไปได้ แต่ก็ไม่ควรจะทำโดยไม่มีความจำเป็นและต้องระวังด้วยว่า ๒ คลาสนั้นไม่มีเมธอดหรือแอตทริบิวต์ที่ชื่อซ้ำ ไม่มีผลข้างเคียงอะไรหากรับทอดมาพร้อมกัน\nเมธอดหรือแอตทริบิวต์ที่ชื่อขึ้นต้นด้วย __ โดยทั่วไปแล้วเมธอดและแอตทริบิวต์จะตั้งชื่อเป็นอะไรก็ได้ หลักการตั้งชื่อก็เหมือนตัวแปรทั่วไป แต่ว่าจะมีกรณีพิเศษเกิดขึ้นหากตั้งชื่อโดยมีขีดล่างสองอันนำหน้า\nเมธอดหรือแอตทริบิวต์ที่ชื่อขึ้นต้นด้วย __ จะไม่สามารถเข้าถึงได้โดยตรงจากภายนอกคลาส ยกตัวอย่าง ประกาศคลาส \u0026quot;ผู้กล้า\u0026quot; ใหม่โดยเปลี่ยนแค่ให้แอตทริบิวต์ \u0026ldquo;เงินเดือน\u0026rdquo; มี __ นำหน้า\nclass ผู้กล้า:  def __init__(self,ชื่อ): self.ชื่อ = ชื่อ __เงินเดือน = 500 จากนั้นลองสร้างออบเจ็กต์แล้วเข้าถึงค่า\nผู้เล่นJ = ผู้กล้า(\u0026#39;เจ\u0026#39;) print(ผู้เล่นJ.__เงินเดือน) จะขึ้นว่า\nAttributeError: \u0026#39;ผู้กล้า\u0026#39; object has no attribute \u0026#39;__เงินเดือน\u0026#39; หรือแม้แต่เข้าถึงผ่านคลาสก็ได้ผลแบบเดียวกัน คือจะขึ้นว่าไม่มีแอตทริบิวต์นี้\nprint(ผู้กล้า.__เงินเดือน) โดยปกติแล้วเป็นธรรมเนียมปฏิบัติที่จะตั้งชื่อแอตทริบิวต์หรือเมธอดที่ไม่ต้องการให้มีการเข้าถึงโดยตรงจากภายนอกโดยขึ้นต้นด้วยขีดล่าง แต่การใส่ขีดล่างเพียงขีดเดียวไม่มีผลอะไรในทางปฏิบัติ จึงเป็นเพียงแค่ธรรมเนียมปฏิบัติ* ส่วนการใส่ขีดล่างสองขีดจึงจะมีผลจริงๆ (*ความจริงแล้วมีผลอยู่เล็กน้อย แต่ไม่ได้สำคัญดังนั้นจะยังไม่พูดถึงในตอนนี้) แต่การเข้าถึงโดยใช้จากภายในยังสามารถทำได้ตามปกติ เช่นลองสร้างเมธอดที่ใช้ค่า \u0026quot;__เงินเดือน\u0026quot; ขึ้นมา\nclass ผู้กล้า:  def __init__(self,ชื่อ): self.ชื่อ = ชื่อ __เงินเดือน = 500 def แสดงเงินเดือน(self): return self.__เงินเดือน ผู้เล่นK = ผู้กล้า(\u0026#39;เค\u0026#39;) print(ผู้เล่นK.แสดงเงินเดือน()) # ได้ 500 จะเห็นว่าจากภายนอกเข้าถึงโดยตรงไม่ได้แต่สามารถเห็นผลของค่านั้นได้โดยอ้อมเช่นผ่านเมธอด ในที่นี้ใช้เมธอด \u0026ldquo;แสดงเงินเดือน\u0026rdquo; อย่างไรก็ตามจริงๆแล้วไม่ใช่ว่าจะเข้าถึงโดยตรงไม่ได้ หากต้องการก็สามารถทำได้เช่นกัน แต่ชื่อจะถูกเปลี่ยนโดยต้องขึ้นต้นด้วยขีดล่างหนึ่งขีดตามด้วยชื่อคลาส ในที่นี้จะเป็น _ผู้กล้า__เงินเดือน ดังนั้นลอง\nprint(ผู้เล่นK._ผู้กล้า__เงินเดือน) # ได้ 500 จะพบว่าแสดงค่าได้ตามปกติไม่เกิดปัญหา ดังนั้นก็ไม่ใช่ว่าจะสามารถซ่อนค่าแอตทริบิวต์ได้สมบูรณ์จริงๆอยู่ดีแม้จะตั้ง ชื่อแบบนี้ เพราะแค่เขียนชื่อยาวโดยเพิ่มชื่อคลาสขึ้นมาก็เข้าถึงโดยตรงได้แล้ว ในบางภาษาอาจมีการซ่อนแอตทริบิวต์หรือเมธอดจากการเข้าถึงจากภายนอก แต่ในไพธอนไม่สามารถทำแบบนั้นได้ เพียงแต่วิธีนี้มักถูกเปรียบเทียบว่าเสมือนคล้ายการซ่อนซึ่งทำได้ในบางภาษา (บางคนก็เข้าใจผิดว่านี่เป็นการซ่อน) แต่ประโยชน์จริงๆของการทำแบบ นี้คือในกรณีที่มีการสืบทอดคลาส สามารถป้องกันไม่ให้มีการเขียนทับได้แม้จะนิยามแอตทริบิวต์หรือเมธอดที่ชื่อ ซ้ำกันขึ้นมา\nclass ผู้กล้า:  def __init__(self,ชื่อ): self.ชื่อ = ชื่อ __เงินเดือน = 500 def แสดงเงินเดือน(self): return self.__เงินเดือน class นักรบ(ผู้กล้า):  __เงินเดือน = 1000 ผู้เล่นL = นักรบ(\u0026#39;แอล\u0026#39;) print(ผู้เล่นL.แสดงเงินเดือน()) # ได้ 500 จะเห็นว่าเมธอด \u0026ldquo;แสดงเงินเดือน\u0026rdquo; ซึ่งมีไว้ใช้คืนค่า __เงินเดือน นั้นคืนค่าเงินเดือน 500 ซึ่งเป็นค่าของคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ทั้งๆที่โดยปกติแล้วหากรับทอดมาแล้วมีการนิยามแอตทริบิวต์ซ้ำมันก็น่าจะถูก เขียนทับ ดังนั้นจึงควรได้ค่า 1000 ซึ่งเป็นค่าใหม่ นั่นเป็นเพราะว่าแอตทริบิวต์หรือเมธอดที่ขึ้นต้นด้วย __ จะไม่ถูกเขียนทับคลาสที่รับทอดมา เพราะชื่อจริงๆของมันจะต้องมีชื่อคลาสนำหน้า ดังนั้นจึงแบ่งแยกกันชัดเจน\nprint(ผู้เล่นL._ผู้กล้า__เงินเดือน) # ได้ 500  print(ผู้เล่นL._นักรบ__เงินเดือน) # ได้ 1000 เท่ากับว่ามีเงินเดือนของผู้กล้าแล้วก็ยังมีเงินเดือนของนักรบอีกแยกต่างหาก เมธอด \u0026ldquo;แสดงเงินเดือน\u0026rdquo; ถูกประกาศในคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; ดังนั้นจึงใช้ \u0026quot;__เงินเดือน\u0026quot; ของคลาส \u0026ldquo;ผู้กล้า\u0026rdquo; แต่หากนิยามเมธอดใหม่ในคลาส \u0026quot;นักรบ\u0026quot; ค่า \u0026quot;__เงินเดือน\u0026quot; ในคลาส \u0026ldquo;นักรบ\u0026rdquo; จะถูกใช้แทน ลองเขียนใหม่โดยเปลี่ยนจาก \u0026quot;__เงินเดือน\u0026quot; เป็น \u0026ldquo;เงินเดือน\u0026rdquo; ซึ่งไม่มีขีดล่างสองขีดนำหน้า หรือจะมีขีดเดียว หรือจะเป็นชื่ออื่นก็ได้ จะพบว่าผลลัพธ์ที่ได้นั้นจะต่างกันออกไป โดยจะได้ค่า 1000 แทนที่จะเป็น 500\nclass ผู้กล้า:  def __init__(self,ชื่อ): self.ชื่อ = ชื่อ เงินเดือน = 500 def แสดงเงินเดือน(self): return self.เงินเดือน class นักรบ(ผู้กล้า):  เงินเดือน = 1000 ผู้เล่นM = นักรบ(\u0026#39;เอ็ม\u0026#39;) print(ผู้เล่นM.แสดงเงินเดือน()) # ได้ 1000  print(ผู้เล่นM.เงินเดือน) # ได้ 1000 ตัวอย่างข้างต้นเป็นกรณีของแอตทริบิวต์ สำหรับเมธอดเองก็สามารถทำได้ในลักษณะเดียวกัน\nclass ผู้กล้า:  def __init__(self,ชื่อ): self.ชื่อ = ชื่อ def __แสดงเงินเดือน(self): return 500 class นักรบ(ผู้กล้า):  def __แสดงเงินเดือน(self): return 1000 ผู้เล่นN = นักรบ(\u0026#39;เอ็น\u0026#39;) print(ผู้เล่นN._ผู้กล้า__แสดงเงินเดือน()) # ได้ 500  print(ผู้เล่นN._นักรบ__แสดงเงินเดือน()) # ได้ 1000 อนึ่ง หากชื่อเมธอดลงท้ายด้วย __ ต่อให้ขึ้นต้นด้วย __ ก็จะไม่มีคุณสมบัติดังที่ว่านี้ เช่นพวกเมธอดพิเศษอย่าง __init__ จะเข้าถึงได้ด้วยชื่อเมธอดตามปกติ\nอ้างอิง\nhttp://docs.python.jp/3/reference/datamodel.html\nhttp://www.lifewithpython.com/2014/01/python-super-function.html\nhttp://shin.hateblo.jp/entry/2013/11/01/211716\nhttp://methane.hatenablog.jp/entry/20081227/1230400144\nhttp://yut.hatenablog.com/entry/20110120/1295533994\nhttp://qiita.com/icoxfog417/items/e8f97a6acad07903b5b0\nhttp://www.geocities.jp/m_hiroi/light/abcruby12.html\n Reference : https://phyblas.hinaboshi.com/tsuchinoko23\n "
},
{
	"uri": "https://knowledge-dragons.github.io/KM/tutorials/404.html",
	"title": "Whoops! Page not found",
	"tags": [],
	"description": "This is a 404 page",
	"content": "That page can\u0026rsquo;t be found.\nOur latest content is on the homepage.\nPhoto by Aron Visuals on Unsplash"
}]